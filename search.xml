<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「Crazyflie开源无人机」Multi-ranger扩展板入门</title>
    <url>/c.%E7%A7%91%E7%A0%94%E5%88%86%E4%BA%AB/History/211217-%E3%80%8CCrazyflie%E5%BC%80%E6%BA%90%E6%97%A0%E4%BA%BA%E6%9C%BA%E3%80%8DMulti-ranger%E6%89%A9%E5%B1%95%E6%9D%BF%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Multi-ranger 是与 Crazyflie 无人机配套使用的一块扩展板，提供了测量周围（前后左右上五个方向）4米范围内障碍物距离的能力，其采用LiDar技术，测距误差较小，可以用在无人机的自主飞行导航等应用。</p>
]]></content>
      <categories>
        <category>科研分享</category>
      </categories>
      <tags>
        <tag>Crazyflie</tag>
        <tag>无人机</tag>
        <tag>LiDar</tag>
        <tag>Multi-ranger</tag>
        <tag>VL53L1x</tag>
      </tags>
  </entry>
  <entry>
    <title>无人机 SLAM 建图常用地图类型及八叉树地图</title>
    <url>/c.%E7%A7%91%E7%A0%94%E5%88%86%E4%BA%AB/History/210924-%E6%97%A0%E4%BA%BA%E6%9C%BA-SLAM-%E5%BB%BA%E5%9B%BE%E5%B8%B8%E7%94%A8%E5%9C%B0%E5%9B%BE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%AB%E5%8F%89%E6%A0%91%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<p>无人机在进行路径规划之前要通过传感器对周围环境的感知建立空间模型，特别是在陌生的三维环境中，无人机要能够快速的进行环境信息的采集和建立合适的空间模型来提高路径规划的效率。</p>
]]></content>
      <categories>
        <category>科研分享</category>
      </categories>
      <tags>
        <tag>无人机</tag>
        <tag>SLAM</tag>
        <tag>自主导航</tag>
        <tag>八叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>How to read a paper?</title>
    <url>/c.%E7%A7%91%E7%A0%94%E5%88%86%E4%BA%AB/History/How%20to%20read%20a%20paper?/</url>
    <content><![CDATA[<p>Researchers spend a great deal of time reading research papers. However, this skill is rarely taught, leading to much wasted effort. This article outlines a practical and efficient three-pass method for reading research papers. I also describe how to use this method to do a literature survey.</p>
]]></content>
      <categories>
        <category>科研分享</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>论文</tag>
        <tag>阅读</tag>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Github Actions 自动编译、发布 LaTeX 文档</title>
    <url>/c.%E7%A7%91%E7%A0%94%E5%88%86%E4%BA%AB/History/220225-%E4%BD%BF%E7%94%A8-Github-Actions-%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E3%80%81%E5%8F%91%E5%B8%83-LaTeX-%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>Github Actions 是 Github 推出的持续化集成工具，进一步加快软件开发的编译、部署、发布流程。基于 Github 进行多人协作编辑 Latex 文档是非常先进的科研文档写作方式，如今可以利用 Github Actions 进一步完善协作流程。</p>
]]></content>
      <categories>
        <category>科研分享</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
        <tag>Github</tag>
        <tag>Github Actions</tag>
        <tag>自动化流程</tag>
      </tags>
  </entry>
  <entry>
    <title>Olimex Debugger User&#39;s Manual 翻译与总结</title>
    <url>/c.%E7%A7%91%E7%A0%94%E5%88%86%E4%BA%AB/History/Olimex%20Debugger%20User&#39;s%20Manual%20%E7%BF%BB%E8%AF%91%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p><strong>Olimex</strong> 推出的 <strong>ARM-USB-TINY-H</strong> 是一款 <strong>OPENOCD ARM JTAG DEBUGGERS</strong>，也是 Bitcraze 官方实验也是我们所使用的 JTAG Debugger，这份 <a href="https://link.zhihu.com/?target=https://www.olimex.com/Products/ARM/JTAG/_resources/ARM-USB-TINY_and_TINY_H_manual.pdf">USER’S MANUAL</a> 也是重要的参考来源。<br>以下内容基于版本 Document revision G, October 2020，是对其中值得注意的内容的翻译与再总结。</p>
</blockquote>
<h2 id="Chapter-1-Overview"><a href="#Chapter-1-Overview" class="headerlink" title="Chapter 1: Overview"></a>Chapter 1: Overview</h2><h3 id="Basic-Information"><a href="#Basic-Information" class="headerlink" title="Basic Information"></a>Basic Information</h3><ul>
<li>ARM-USB-TINY-H 与 ARM-USB-TINY 两款产品基本上没什么区别，唯一的区别是ARM-USB-TINY-H 在于其名字中的 H 代表 HighSpeed，即拥有更低的延迟，RTCK的 JTAG 时钟达到30Mhz，并且相比普通版有 3-5 倍快的编程吞吐量。</li>
<li>Programmer/Debugger 是 ARM MCU 开发不可缺少的工具， ARM-USB-TINY是一款利用 OS 上的 Openocd 来利用板子上的 JTAG 接口进行软硬件开发的产品。</li>
<li>可以为开发板供电。</li>
<li>除了 JTAG 接口，还有 SWD 接口有相同的功能。可以使用 adapter 将 JTAG 信号转换成 SWD 信号利用我们的 debugger 进行调试。</li>
</ul>
<span id="more"></span>

<h3 id="Comparison-among-4-Debuggers"><a href="#Comparison-among-4-Debuggers" class="headerlink" title="Comparison among 4 Debuggers"></a>Comparison among 4 Debuggers</h3><p><img src="pic1.jpg" alt="img"></p>
<ul>
<li>ARM-USB-TINY-H更被推荐用于家庭使用，研究与开发</li>
<li>四款产品拥有相同的 Vendor ID，以及不同的 Product ID。（USB 接口设备有一个 <a href="https://link.zhihu.com/?target=https://the-sz.com/products/usbid/">ID 数据库</a>）</li>
</ul>
<p><img src="pic2.png" alt="img"></p>
<h2 id="Chapter-2-Device-Description"><a href="#Chapter-2-Device-Description" class="headerlink" title="Chapter 2: Device Description"></a>Chapter 2: Device Description</h2><h3 id="LED"><a href="#LED" class="headerlink" title="LED"></a>LED</h3><p>Debugger 有一个红色的 LED 灯在 JTAG 接口端。通电后会亮，正在进行读写操作时会闪烁。</p>
<h3 id="Ports-and-Connectors"><a href="#Ports-and-Connectors" class="headerlink" title="Ports and Connectors"></a>Ports and Connectors</h3><blockquote>
<p>Ports 指 Debugger 自身的两个端口，USB-B 与 JTAG 20 male<br>Connectors 指将 Debugger 连接到 PC 和开发板的线。在我们的场景下，分别需要 USB A-B，JTAG 20-10 adapter 线。</p>
</blockquote>
<ul>
<li><p>Port: USB Type B</p>
</li>
<li><ul>
<li>需要一根 USB A-B 线来连接到 PC</li>
<li>USB 连接基于其中的一块 FTDI Chip，driver需要更改 VID 与 PID 使用上面提供的 Olimex 对应的 ID。</li>
</ul>
</li>
<li><p>Port: JTAG</p>
</li>
<li><ul>
<li>是一个 20 口的公线（有针的是 male，有孔的是 female）</li>
<li>2.54mm间距（IEEE 1149.1）</li>
<li>注意 JTAG 线因为形状原因无法直接分辨正反。通常会用一些手段，比如 Debugger 的 JTAG端会有一个卡槽与连接线对应。同时连接线也有标红的一根线来表明这是 1 号线。</li>
<li>JTAG 端的引脚如图</li>
</ul>
</li>
</ul>
<p><img src="pic3.jpg" alt="img"></p>
<ul>
<li><ul>
<li><ul>
<li>PIN1 和 PIN2 用于探测目标板是否已经被供电，如果没有，通过 PIN19 来供电。USB 允许有限的供电输出功率，对于更大的板子还是希望通过外部的供电方式来进行。</li>
</ul>
</li>
<li><p>JTAG 接口通常是 20PIN (2.54mm）或者是 mini 版本的 10PIN（1.27mm）。我们的 AI-deck 就是 mini 版本的，所以还需要一个 20-10 的转接器。</p>
</li>
</ul>
</li>
</ul>
<h2 id="Chapter-3-Setting-up-ARM-USB-TINY"><a href="#Chapter-3-Setting-up-ARM-USB-TINY" class="headerlink" title="Chapter 3: Setting up ARM-USB-TINY"></a>Chapter 3: Setting up ARM-USB-TINY</h2><h3 id="Hardware-Requirement"><a href="#Hardware-Requirement" class="headerlink" title="Hardware Requirement"></a>Hardware Requirement</h3><ul>
<li><p>我们得有一块开发板/MCU和一台 PC 才能完成 debug/programming 任务</p>
</li>
<li><p>ARM-USB-TINY 附带一根 20-20 pin female-female 2.54mm/0.1inch connector 线</p>
</li>
<li><p>ARM-USB-TINY 不附带 USB Type A-B 线</p>
</li>
<li><p>需要的硬件根据实际情况会有所不同，例如</p>
</li>
<li><ul>
<li>需要 JTAG 20-10 pin adapter 如果板子上的 JTAG 调试接口是 mini 接口</li>
<li>需要 JTAG-SWD adapter 如果板子只支持 SWD 信号</li>
</ul>
</li>
</ul>
<h3 id="Software-Configuration"><a href="#Software-Configuration" class="headerlink" title="Software Configuration"></a>Software Configuration</h3><h3 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h3><ul>
<li><ul>
<li>可以看出 ARM-USB-TINY 默认就是为 OpenOCD 这一软件 tool 服务的</li>
<li>不同系统有不同方式，对于 Mac 的话就是简单的brew install openocd</li>
<li>也可以选择自行 compile 的方式还实现更多自定义配置</li>
</ul>
</li>
</ul>
<h3 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h3><ul>
<li><ul>
<li>使用 USB 就需要 driver</li>
<li>有很多可用的 driver（因为最初使用的是 FTDI 的 driver，不是开源的，与 OpenOCD 的开源理念违背，所以有很多人自发编写维护了很多 driver）</li>
<li>Driver installation in Windows 在 Page 14-16</li>
<li>Driver installation in Linux 在 Page 16-17</li>
<li>Driver installation in MAC OS X 在 Page 17-18</li>
</ul>
</li>
</ul>
<h3 id="Driver-installation-in-MAC-OS-X"><a href="#Driver-installation-in-MAC-OS-X" class="headerlink" title="Driver installation in MAC OS X"></a>Driver installation in MAC OS X</h3><ul>
<li><p>MacOS 的 driver 主要在</p>
</li>
<li><ul>
<li>/System/Library/Extensions/目录下的 Kernel 插件</li>
<li>Application Bundle 中</li>
</ul>
</li>
<li><p>kextunload可以卸载 Kernal 插件</p>
</li>
<li><p>kextstat可以查看被加载的 Kernal 插件</p>
</li>
</ul>
<blockquote>
<p>验证 USB 被识别可以点击 –&gt;关于本机–&gt;系统报告–&gt;硬件–&gt;USB 查看是否有目标 USB<br>或者在命令行输入 ​lsusb​ 查看</p>
</blockquote>
<h3 id="Basic-OpenOCD-connection"><a href="#Basic-OpenOCD-connection" class="headerlink" title="Basic OpenOCD connection"></a>Basic OpenOCD connection</h3><ul>
<li><p>最容易判断 debugger 软硬件安装是否正确的方式还是建立一个到目标的连接，连接建立后</p>
</li>
<li><ul>
<li>可以本地或者远程地访问 GDB server</li>
<li>可以使用 telnet 访问 server 来执行 debug</li>
<li>可以配置一个图形界面连接到 GDB server</li>
</ul>
</li>
</ul>
<h3 id="Starting-OpenOCD-GDB-server-via-FTDI-drivers"><a href="#Starting-OpenOCD-GDB-server-via-FTDI-drivers" class="headerlink" title="Starting OpenOCD GDB server via FTDI drivers"></a>Starting OpenOCD GDB server via FTDI drivers</h3><blockquote>
<p>这是 0.8.0 及之后版本的 OpenOCD 默认使用的连接方式</p>
</blockquote>
<p>例如，使用 openocd 在 ARM-USB-TINY-H 和一个 STM32F1 开发板之间建立连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openocd-x64-0.8.0.exe -f ./interface/ftdi/olimex-arm-usb-tiny-h.cfg -f ./target/stm32f1x.cfg</span><br></pre></td></tr></table></figure>

<p>我们需要指明可执行程序的文件夹</p>
<p>典型的成功响应例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Info: JTAG tap: stm32f1x.cpu tap/device found: 0x3ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x3)</span><br><span class="line">Info: JTAG tap: stm32f1x.bs tap/device found: 0x06418041 (mfg: 0x020, part: 0x6418, ver: 0x0)</span><br><span class="line">Info: stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TAP是开发板上的组件，用于 debug 调试，有支持 JTAG 的，也有支持 SWD 的。可能不止一个。</p>
</blockquote>
<p>连接建立成功后（即 GDB Server 启动成功后）可以再开启一个终端使用 telnet 连接到默认端口 4444，使用细节可以参考 <a href="https://link.zhihu.com/?target=https://www.olimex.com/Products/ARM/JTAG/_resources/Manual_TELNET.pdf">Using OpenOCD with TELNET connection</a></p>
<h3 id="Starting-OpenOCD-GDB-server-via-LibUSB-drivers"><a href="#Starting-OpenOCD-GDB-server-via-LibUSB-drivers" class="headerlink" title="Starting OpenOCD GDB server via LibUSB drivers"></a>Starting OpenOCD GDB server via LibUSB drivers</h3><blockquote>
<p>这是 0.8.0 之前版本的 OpenOCD 默认使用的连接方式</p>
</blockquote>
<p>同样，建立连接的命令（接口配置文件地址不一样）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openocd -f interface/olimex-arm-usb-tiny-h.cfg -f target/stm32f1x.cfg</span><br></pre></td></tr></table></figure>

<p>成功后的响应结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Info : JTAG tap: stm32f1x.cpu tap/device found: 0x3ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x3)</span><br><span class="line">Info : JTAG tap: stm32f1x.bs tap/device found: 0x06418041 (mfg: 0x020, part: 0x6418, ver: 0x0)</span><br><span class="line">Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints</span><br></pre></td></tr></table></figure>

<h3 id="Starting-OpenOCD-GDB-to-a-SWD-target-connection-with-ARM-JTAG-SWD"><a href="#Starting-OpenOCD-GDB-to-a-SWD-target-connection-with-ARM-JTAG-SWD" class="headerlink" title="Starting OpenOCD GDB to a SWD target connection with ARM-JTAG-SWD"></a>Starting OpenOCD GDB to a SWD target connection with ARM-JTAG-SWD</h3><blockquote>
<p>0.9.0 及之后版本的 OpenOCD 增加了对 SWD 的支持</p>
</blockquote>
<p>建立连接的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openocd -f interface/ftdi/olimex-arm-usb-tiny-h.cfg -f interface/ftdi/olimexarm-jtag-swd.cfg -f target/stm32f1x.cfg</span><br></pre></td></tr></table></figure>

<p>成功后的响应结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Info : FTDI SWD mode enabled adapter speed: 1000 kHz adapter_nsrst_delay: 100 cortex_m reset_config sysresetreq</span><br><span class="line">Info : clock speed 1000 kHz</span><br><span class="line">Info : SWD IDCODE 0x1ba01477 Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints</span><br></pre></td></tr></table></figure>

<h3 id="Advanced-OpenOCD-practices"><a href="#Advanced-OpenOCD-practices" class="headerlink" title="Advanced OpenOCD practices"></a>Advanced OpenOCD practices</h3><h3 id="Using-multiple-ARM-USB-TINY-interfaces"><a href="#Using-multiple-ARM-USB-TINY-interfaces" class="headerlink" title="Using multiple ARM-USB-TINY interfaces"></a>Using multiple ARM-USB-TINY interfaces</h3><p>在同一台 PC 上使用多个同款 debugger 也是可以的，虽然他们的 VendorID 和 ProductID 都是相同的，但是可以根据 serial numbers（序列号）来进行区分。在 Linux 下使用lsusb -v就能看到序列号。</p>
<p>如果有多个同款 debugger 被同时使用，我们需要为每个 debugger 分别编写 cfg 接口配置文件，在文件内指定目标的序列号，例如如下两个 cfg 文件即可区分同型号的两个 debugger：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-olimex-arm-usb-tiny-h1.cfg</span><br><span class="line"></span><br><span class="line">interface ftdi</span><br><span class="line">ftdi_device_desc &quot;Olimex OpenOCD JTAG ARM-USB-TINY-H&quot; </span><br><span class="line">ftdi_vid_pid 0x15ba 0x002a </span><br><span class="line">ftdi_serial OLYMTEEY</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-olimex-arm-usb-tiny-h2.cfg</span><br><span class="line"></span><br><span class="line">interface ftdi </span><br><span class="line">ftdi_device_desc &quot;Olimex OpenOCD JTAG ARM-USB-TINY-H&quot; </span><br><span class="line">ftdi_vid_pid 0x15ba 0x002a </span><br><span class="line">ftdi_serial OLYMTGH5</span><br></pre></td></tr></table></figure>

<h3 id="Changing-the-VID-and-PID-of-the-debugger"><a href="#Changing-the-VID-and-PID-of-the-debugger" class="headerlink" title="Changing the VID and PID of the debugger"></a>Changing the VID and PID of the debugger</h3><blockquote>
<p>修改 debugger 的 VID 与 PID 对于初学者是不推荐的，因为很有可能改不回来~<br>一般的使用场景并不需要我们修改 ID，所以这是不被推荐的行为</p>
</blockquote>
<p>修改 VID 和 PID 不需要硬件工具，通过软件就可以改变。</p>
<p>一旦修改了 ID，drivers 和 script 也得跟着修改，需要一个新的 driver。</p>
<p>完成修改需要一个软件：MProg。具体细节请查看原文档 Page22-23。</p>
<h3 id="Some-graphical-tools"><a href="#Some-graphical-tools" class="headerlink" title="Some graphical tools"></a>Some graphical tools</h3><p>有几款界面工具可以帮助我们可视化地看到调试信息。</p>
<ul>
<li><p>IAR Embedded Workbench for ARM</p>
</li>
<li><ul>
<li>商业版，可免费试用一段时间</li>
</ul>
</li>
<li><p>Rowley Crossworks for ARM</p>
</li>
<li><ul>
<li>推荐配合 FTDI 驱动使用，虽然也支持 LibUSB 驱动</li>
<li>支持 ARM-JTAG-SWD 转换器</li>
</ul>
</li>
<li><p>STM32CubeIDE</p>
</li>
<li><p>CooCox IDE (discontinued)</p>
</li>
<li><ul>
<li>停止维护</li>
</ul>
</li>
<li><p>Olimex Open Development Suite (ODS) package (discontinued)</p>
</li>
<li><ul>
<li>停止维护</li>
</ul>
</li>
</ul>
<h2 id="Chapter-4-Frequently-Asked-Questions"><a href="#Chapter-4-Frequently-Asked-Questions" class="headerlink" title="Chapter 4: Frequently Asked Questions"></a>Chapter 4: Frequently Asked Questions</h2><ul>
<li><p>A: What USB cable do I need?</p>
</li>
<li><ul>
<li>我应该用什么 USB 线？</li>
</ul>
</li>
<li><p>Q: You should have a USB type A-B cable to connect to PC, all PC USB hosts have USB-A connector while ARM-USB-TINY has USB-B connector so the cable should be USB A-to-B type. Note that such a cable is not included in the package.</p>
</li>
<li><ul>
<li>您应该有一个 USB A-B 的线连接到PC。所有的 PC USB 接口都是 USB-A 接口，而 ARM-USB-TINY 则是 USB-B 接口，所以 USB 线应该是 USB A-to-B 型。请注意，包装中没有这根线。</li>
</ul>
</li>
<li><p>Q: Does your JTAG connector layout differ from the JTAG connector layout of other debuggers?</p>
</li>
<li><ul>
<li>你们的 JATG 连接器的针脚布局与其他的 debugger 有什么区别吗？</li>
</ul>
</li>
<li><p>A: No. It is the standard 20-pin ARM JTAG layout.</p>
</li>
<li><ul>
<li>不。它就是标准的 20-pin ARM JTAG 的布局。</li>
</ul>
</li>
<li><p>Q: What are the LEDs for?</p>
</li>
<li><ul>
<li>LED 灯的用途是？</li>
</ul>
</li>
<li><p>A: The LED is mainly meant to indicate programming/debugging in progress. The red LED should blink when you have an on-going operation (read, write).</p>
</li>
<li><ul>
<li>LED 的主要目的是指明是否正在进行 programming/debugging。当我们进行读写操作时红色的 LED 灯会闪烁。</li>
</ul>
</li>
<li><p>Q: I have downloaded the latest version of OpenOCD but there is no configuration for my target. Send me one please.</p>
</li>
<li><ul>
<li>我已经下载了最新版本的 OpenOCD，但是里面没有适配我的调试对象的配置文件，请发给我一个。</li>
</ul>
</li>
<li><p>A: We commit or forward everything we have done directly to the OpenOCD repositories. If you can’t find a suitable cfg there – you are out of luck. You either have write it yourself or ask politely somebody at the OpenOCD community to do it for you.</p>
</li>
<li><ul>
<li>我们将所做的一切直接提交或转发到了 OpenOCD 库。如果你在那里找不到合适的 cfg 配置文件，那你就有点不幸。你要么自己写，要么礼貌地请 OpenOCD 社区的人帮你写。</li>
</ul>
</li>
<li><p>Q: I can’t write proper makefile for my board under your Eclipse-like IDE. Can you please write it for me?</p>
</li>
<li><ul>
<li>我写不出来适合我的开发板的 Makefile 在你们的类 Eclipse IDE 环境下。可以请你们为我写一个吗？</li>
</ul>
</li>
<li><p>A: No. That’s the bad (good?) side of open software – it is a community effort – everybody has to write and commit something. You learn something in the end, however.</p>
</li>
<li><ul>
<li>不可以。这就是开源软件好或不好的一点，它需要一个社区的努力，每个人都得为社区贡献些东西。当然，你最终也会学到一些东西。</li>
</ul>
</li>
<li><p>Q: I have LPC1227 board and can’t program it with your OpenOCD debugger. What do I do wrong?</p>
</li>
<li><ul>
<li>我有一个 LPC1227 开发板但是不能用你们的 OpenOCD 调试器，我做错了什么？</li>
</ul>
</li>
<li><p>A: LPC1227 lacks JTAG according to the microcontroller’s datasheet. The board can be programmed only via SWD (Serial Wire Debug) interface. Olimex OpenOCD debuggers have JTAG by default. You would need an additional adapter – ARM-JTAG-SWD.</p>
</li>
<li><ul>
<li>根据参数表来看，LPC1227 缺少 JTAG 接口。这块开发板只能通过 SWD 接口来编程。Olimex OpenOCD 的 debugger 默认支持 JTAG。你需要一个附加的转接器——ARM-JTAG-SWD。</li>
</ul>
</li>
<li><p>Q: Howdy, guys. I can’t program my MSP430 and PIC16 boards with your robust debugger. I need help ASAP.</p>
</li>
<li><ul>
<li>你好。我用不了你们强大的 debugger 来编程我的 MSP430 和 PIC16 开发板。我需要尽快的帮忙。</li>
</ul>
</li>
<li><p>A: Technically, it is possible to program targets different than ARM using our OpenOCD debugger. Practically, almost all users use the debugger for ARM programming and only ARM targets are officially supported. There is a reason that the prefix in the name of the debugger is ‘ARM-‘.</p>
</li>
<li><ul>
<li>从技术上讲，使用我们的 OpenOCD 调试器可以编程非 ARM 架构的目标。实际上，几乎所有用户都使用调试器进行ARM编程，只有ARM目标才得到官方支持。调试器名称中的前缀是“ARM-”是有原因的。</li>
</ul>
</li>
</ul>
<h2 id="Chapter-5-Revision-History-and-Support"><a href="#Chapter-5-Revision-History-and-Support" class="headerlink" title="Chapter 5: Revision History and Support"></a>Chapter 5: Revision History and Support</h2><h3 id="Revision-History"><a href="#Revision-History" class="headerlink" title="Revision History"></a>Revision History</h3><ul>
<li>第一版始于 2014.07.16，此文对应的是 2020.10.08 出版的 Document Revision G</li>
</ul>
<h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><ul>
<li><p><a href="https://link.zhihu.com/?target=https://www.olimex.com/">Olimex 官网</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https://www.olimex.com/forum/">JTAG 官方论坛</a></p>
</li>
<li><p>WIKI</p>
</li>
<li><ul>
<li><a href="https://link.zhihu.com/?target=https://www.olimex.com/wiki/ARM-USB-TINY-H">ARM-USB-TINY-H</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.olimex.com/wiki/ARM-USB-TINY">ARM-USB-TINY</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.olimex.com/wiki/ARM-USB-OCD-H">ARM-USB-OCD-H</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.olimex.com/wiki/ARM-USB-OCD">ARM-USB-OCD</a></li>
</ul>
</li>
<li><p>官方商店购买</p>
</li>
<li><ul>
<li><a href="https://link.zhihu.com/?target=https://www.olimex.com/Products/ARM/JTAG/ARM-USB-TINY-H/">ARM-USB-TINY-H</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.olimex.com/Products/ARM/JTAG/ARM-USB-TINY/">ARM-USB-TINY</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.olimex.com/Products/ARM/JTAG/ARM-USB-OCD-H/">ARM-USB-OCD-H</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.olimex.com/Products/ARM/JTAG/ARM-USB-OCD/">ARM-USB-OCD</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.olimex.com/Products/ARM/JTAG/ARM-JTAG-20-10/">ARM-JTAG-20-10</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.olimex.com/Products/ARM/JTAG/ARM-JTAG-SWD/">ARM-JTAG-SWD</a></li>
<li><a href="https://link.zhihu.com/?target=https://www.olimex.com/Products/Components/Cables/CABLE-USB-A-B-1.8M/">CABLE-USB-A-B-1.8M</a></li>
</ul>
</li>
<li><p>经销商渠道购买</p>
</li>
<li><ul>
<li><a href="https://link.zhihu.com/?target=https://www.olimex.com/Distributors/">经销商列表</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>我们在其全球经销商，<a href="https://link.zhihu.com/?target=https://www.mouser.hk/manufacturer/olimex/">贸泽电子 MOUSER ELECTRONICS</a> 购买过，还不错。美国仓库发货，比淘宝便宜但是耗时久一些。</p>
</blockquote>
]]></content>
      <categories>
        <category>科研分享</category>
      </categories>
      <tags>
        <tag>Crazyflie</tag>
        <tag>无人机</tag>
        <tag>AI-deck</tag>
        <tag>边缘计算</tag>
      </tags>
  </entry>
  <entry>
    <title>「Crazyflie开源无人机」AI-deck - 低功耗边缘计算实战</title>
    <url>/c.%E7%A7%91%E7%A0%94%E5%88%86%E4%BA%AB/History/%E3%80%8CCrazyflie%E5%BC%80%E6%BA%90%E6%97%A0%E4%BA%BA%E6%9C%BA%E3%80%8DAI-deck%20-%20%E4%BD%8E%E5%8A%9F%E8%80%97%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>边缘计算：边缘计算（Edge Computing）指将数据的处理、应用程序的运行甚至一些功能服务的实现，由网络中心下放到网络边缘的节点上。</p>
<p>我们今天要介绍的是 <strong>低功耗</strong>的边缘计算，这允许我们在更轻量级的物联网设备上完成更复杂的计算任务，实现更灵活的功能。</p>
<p>我们选择的平台是开源的微型无人机 Crazyflie，基于 Crazyflie 背后团队最新推出的低功耗边缘计算扩展板 AI-deck 来运行我们的边缘计算实例。</p>
<span id="more"></span>

<h1 id="Crazyflie"><a href="#Crazyflie" class="headerlink" title="Crazyflie"></a>Crazyflie</h1><p>Crazyflie 是来自瑞典的 Bitcraze 公司开发并生产的重量仅有 <strong>30g</strong> 的 <strong>微型无人机</strong>，项目完全开源并且提供软硬件工具给用户来建构其生态。</p>
<img src="crazyflie_2.1.png" alt="Crazyflie 2.1" style="zoom:50%;" />

<h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>Crazyflie 微型四轴飞行器的硬件设计得非常优秀，不管是 PCB 机械层的轮廓设计、信号层上元器件的布局还是整个电路板的走线都非常合理，而且最重要的是 Bitcraze 团队将模块化的理念带入到 Crazyflie产品的设计之中，这使得 Crazyflie 微型四轴除了基本的飞行功能之外，还可以通过堆叠不同<strong>扩展板</strong>的方式来实现不同功能的扩展。</p>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>Crazyflie 微型四轴飞行器的软件开发全部基于 Linux 开发环境，并使用已有开源且强大的软件工具（比如 ARM-GCC，Make、PyQt 等）进行开发。除此之外，Crazyflie 微型四轴飞行器的软件源码还被托管在 GitHub 上，非常方便世界各地的爱好者、研究者对其进行二次开发。</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>除了以上两点有关技术层面的优势，Crazyflie 微型四轴飞行器项目还有一个非常优秀的地方——丰富的文档。作为一家不以盈利为主要目的团队任然可以将自己的开源项目文档写得如此详细，他们这种乐于分享的精神实在是值得我们学习。</p>
<h1 id="AI-deck"><a href="#AI-deck" class="headerlink" title="AI-deck"></a>AI-deck</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><ul>
<li><p>用途：边缘计算</p>
</li>
<li><p>重量：只有 30g</p>
</li>
<li><p>组成：</p>
<ul>
<li>GAP8 Ultra-low power 8+1 core RISC-V IoT Application Processor</li>
<li>Himax HM01B0 – Ultra low power 320×320 Bayer RGB camera.</li>
<li>512 Mbit HyperFlash and 64 Mbit HyperRAM</li>
<li>ESP32 for WiFi and more (NINA-W102)</li>
<li>2 x Cortex-M 10-pin JTAG for GAP8 and ESP32</li>
<li>Button connected to ESP32 for UART bootloader or other action</li>
<li>1 x green LED connected to GAP8 (A2)</li>
<li>1 x green LED connected to ESP32 (GPIO_24)</li>
<li>Can work stand alone. Power board on VCOM</li>
</ul>
</li>
</ul>
<blockquote>
<p>板子上有GAP8和NINA两块芯片，以及分别的调试接口。<br>GAP8是一款基于RISC-V的物联网处理器芯片，用于完成AI计算任务。<br>NINA是一款以ESP32芯片为核心的WiFi模组，用于完成图像传输。</p>
</blockquote>
<ul>
<li>存在的主要问题：AI-deck尚处早期研发，挑战与机遇并存</li>
</ul>
<img src="ai-deck.png" alt="Crazyflie 2.1" style="zoom:80%;" />

<h2 id="PULP-DroNet"><a href="#PULP-DroNet" class="headerlink" title="PULP-DroNet"></a>PULP-DroNet</h2><p>AI-deck 来自于一个叫 PULP-DroNet 的项目。AI-deck 基于 PULP-DroNet 项目开发的 PULP-Shield 开发板，进行了适当的改进。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>PULP-DroNet</strong> 是一个由深度学习驱动的 <strong>视觉导航引擎</strong>，帮助微型无人机在未知的环境中进行自主导航。得益于 PULP-DroNet，微型无人机可以完全自主地探索环境，避免与移动障碍物发生碰撞。<strong>无需人工操作，无需临时外部信号，也无需远程笔记本电脑！</strong>这意味着所有复杂的计算都可以直接在飞机上快速完成。</p>
<ul>
<li><p>PULP-DroNet：PULP-Shield + DroNet</p>
<ul>
<li><p>Software</p>
<ul>
<li>Based on DroNet: a shallow convolutional neural network developed by <a href="http://rpg.ifi.uzh.ch/">RPG</a></li>
</ul>
</li>
<li><p>Hardware</p>
<ul>
<li>Based on PULP (Parallel Ultra-Low-Power) GAP8 SoC (System on Chip) from <a href="https://greenwaves-technologies.com/">GreenWaves Technologies</a></li>
<li>an ultra-low power HiMax HBM01 camera</li>
<li>off-chip Flash/DRAM memory</li>
</ul>
</li>
</ul>
</li>
<li><p>缩写</p>
<ul>
<li>PULP：Parallel Ultra-Low-Power 并行超低功耗</li>
<li>GWT：GreenWaves Technologies 一家芯片公司，生产了 GAP8 这款 PULP 的 SoC</li>
</ul>
</li>
<li><p>术语</p>
<ul>
<li>PULP-Shield：与 Crazyflie 兼容的可插拔的 PCB，上面搭载 PULP GAP8 SoC 或 PULP Mr.Wolf SoC</li>
<li>PULP Virtual Platform：一个软件模拟环境，在自己的电脑上运行程序，模拟程序运行在 PULP SoC 上的效果</li>
<li>Autotiler：一个软件工具，作为lib.a发布。它会生成一些为了编译PULP-DroNet所需要的 c 文件。</li>
<li>GAPuino board：GWT Arduino 兼容的开发板，其中包括 PULP GAP8 SoC。</li>
</ul>
</li>
</ul>
<h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><p><img src="pulp-shield.png"></p>
<ul>
<li><p>PULP-DroNet 基于 ETHZürich 和博洛尼亚大学设想的 <a href="https://www.pulp-platform.org/">并行超低功耗</a>（PULP）项目。</p>
<ul>
<li>功率低至几毫瓦</li>
<li>应用在先进 IoT 节点，智能传感器，当然还有 微型无人机</li>
<li>对诸如相机之类的传感器生成的数据流进行灵活，高级的处理，而这超出了典型微控制器的能力</li>
<li>硬件基于 RISC-V 架构，可替代同为 RISC 的 ARM，开源</li>
</ul>
</li>
<li><p>第一步是开发 PULP-Shield（可以认为是 AI-Deck 早期的原型产品）</p>
<ul>
<li><p>使用的是 PULP GAP8 SoC （GAP8 是 PULP 项目的第一个商用版本）</p>
<ul>
<li><p>9 RISC-V-based cores</p>
<ul>
<li>an on-chip microcontroller (1 core, called <em>Fabric Ctrl)</em></li>
<li>a <em>cluster</em> accelerator of 8 cores</li>
</ul>
</li>
<li><p>64 kB L1 memory</p>
</li>
<li><p>512kB L2 memory</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接下来选择基于DroNet的高级人工智能算法作为自主导航引擎的算法核心</p>
<ul>
<li>因为资源受限，对 DroNet 进行了一些改进，输出碰撞概率和转向角两条信息，最后转换成 <strong>前进速度</strong> 和 <strong>转角率</strong> (angular yaw rate) 用于控制无人机。</li>
</ul>
</li>
</ul>
<p><img src="pulp-dronet.png"></p>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul>
<li><a href="https://github.com/pulp-platform/pulp-dronet">Github - PULP-DroNet</a></li>
<li><a href="https://arxiv.org/abs/1805.01831">A 64mW DNN-based Visual Navigation Engine for Autonomous Nano-Drones</a>（arxiv文章关于上面提到的如何将 DroNet 移植到功率受限的 CF 上）</li>
<li><a href="https://www.pulp-platform.org/">PULP Platform</a>，<a href="https://www.youtube.com/channel/UCpad_lwSfoMZkb6X7FdjU0g">Youtube</a></li>
</ul>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="硬件配置"><a href="#硬件配置" class="headerlink" title="硬件配置"></a>硬件配置</h2><ol>
<li><p>微型无人机：<a href="https://store.bitcraze.io/collections/kits/products/crazyflie-2-1">Crazyflie 2.1</a></p>
</li>
<li><p>边缘计算扩展板：<a href="https://store.bitcraze.io/collections/decks/products/ai-deck">AI-deck</a></p>
</li>
<li><p>与扩展板 AI-deck 进行通信/程序烧录的 Debugger：<a href="https://www.olimex.com/Products/ARM/JTAG/ARM-USB-TINY-H/">Olimex ARM-USB-TINY-H JTAG</a></p>
</li>
<li><p>用于连接 Debugger 与 AI-deck 的转接器：<a href="https://www.olimex.com/Products/ARM/JTAG/ARM-JTAG-20-10/">ARM JTAG 20 to 10 pin adapter</a></p>
</li>
<li><p>用于连接 Debugger 与 PC 的 USB 线：<a href="https://www.olimex.com/Products/Components/Cables/CABLE-USB-A-B-1.8M/">CABLE USB A-B 1.8M</a></p>
</li>
<li><p>与 Crazyflie 进行通信/程序烧录的 USB Dongle：<a href="https://store.bitcraze.io/collections/kits/products/crazyradio-pa">Crazyradio PA 2.4 GHz USB dongle</a></p>
</li>
</ol>
<blockquote>
<p>设备 3 提到的 debugger 有多种选择，但官方示例选用的是 olimex 的这款，为了避免不必要的麻烦，推荐在设备选择方面 follow 成功案例，从而专心软件开发。</p>
</blockquote>
<p><img src="cable_connection.png" alt="接线方式"></p>
<blockquote>
<p>接线方式即烧录方式有两种选择。</p>
<ul>
<li><em><strong>① Flash based on JTAG (wired)</strong></em>: 使用设备 3-5 以有线方式通过 OpenOCD 基于 JTAG 与 AI-deck 进行通信。  </li>
<li><em><strong>② Flash using Crazyradio PA (wireless)</strong></em>: 使用设备 6 以无线方式基于蓝牙与 Crazyflie 进行通信。</li>
</ul>
</blockquote>
<h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><h3 id="Virtual-Machine"><a href="#Virtual-Machine" class="headerlink" title="Virtual Machine"></a>Virtual Machine</h3><ul>
<li>AI-deck 需要用到 GAP8 SDK，该 SDK 只提供了 Ubuntu 版本</li>
<li>所以这里推荐安装 <a href="https://wiki.bitcraze.io/projects:virtualmachine:index#download">Bitcraze Virtual Machine</a></li>
<li>需要预先安装 <a href="https://www.virtualbox.org/">Oracle VirtualBox</a></li>
</ul>
<h3 id="GAP8-amp-NINA"><a href="#GAP8-amp-NINA" class="headerlink" title="GAP8 &amp; NINA"></a>GAP8 &amp; NINA</h3><blockquote>
<p>从官方商店购买的设备应该是已经烧录好了相应的firmware，但是我们从第三方购买的没有烧录，需要自行烧录。下面的实践环节会详细介绍。</p>
</blockquote>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="Step-1-下载官方示例项目"><a href="#Step-1-下载官方示例项目" class="headerlink" title="Step 1: 下载官方示例项目"></a>Step 1: 下载官方示例项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/bitcraze/AIdeck_examples.git</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/bitcraze/AIdeck_examples">AIdeck_examples</a> 项目为我们准备的几个示例程序的固件源码，以及使用 Docker 以最便捷的方式安装 AI-deck 开发所需要的两大软件依赖（NINA 芯片需要的 ESP-IDF，GAP8 芯片需要的 GAP8-SDK）</p>
<h2 id="Step-2-安装-ESP-IDF-并烧录-NINA-芯片"><a href="#Step-2-安装-ESP-IDF-并烧录-NINA-芯片" class="headerlink" title="Step 2: 安装 ESP-IDF 并烧录 NINA 芯片"></a>Step 2: 安装 ESP-IDF 并烧录 NINA 芯片</h2><ol>
<li>下载 Docker 镜像</li>
</ol>
<blockquote>
<p>工作目录：AIdeck_examples/NINA/firmware/</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build --tag espidf:3.3.1 .</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>烧录</li>
</ol>
<blockquote>
<p>工作目录：AIdeck_examples/NINA/firmware/</p>
<p>接线连接：Debugger 连上 AI-deck 上 NINA 芯片对应的 JTAG 接口</p>
</blockquote>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run --rm -it -v $PWD:/module/ --device /dev/ttyUSB0 --privileged -P espidf:3.3.1 /bin/bash -c &quot;make menuconfig; make clean; make all; /openocd-esp32/bin/openocd -f interface/ftdi/olimex-arm-usb-tiny-h.cfg -f board/esp-wroom-32.cfg -c &#x27;program_esp32 build/partitions_singleapp.bin 0x8000 verify&#x27; -c &#x27;program_esp32 build/bootloader/bootloader.bin 0x1000 verify&#x27; -c &#x27;program_esp32 build/ai-deck-jpeg-streamer-demo.bin 0x10000 verify reset exit&#x27;&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Step-3-安装-GAP8"><a href="#Step-3-安装-GAP8" class="headerlink" title="Step 3: 安装 GAP8"></a>Step 3: 安装 GAP8</h2><ol>
<li>获取 Docker</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GAP_SDK_VERSION=3.5</span><br><span class="line">echo &#x27;export GAP_SDK_VERSION=3.5&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">docker build --tag gapsdk:$&#123;GAP_SDK_VERSION&#125; --build-arg GAP_SDK_VERSION .</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装 autotiler</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -it gapsdk:$&#123;GAP_SDK_VERSION&#125; /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">in</span> the container write</span></span><br><span class="line">cd /gap_sdk</span><br><span class="line">source configs/ai_deck.sh</span><br><span class="line">make autotiler</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里会让填个邮箱，输一个 URL <a href="https://greenwaves-technologies.com/autotiler/">https://greenwaves-technologies.com/autotiler/</a></p>
</blockquote>
<ol start="3">
<li>提交修改</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GAP_SDK_VERSION=3.5</span><br><span class="line">docker commit &lt;container id&gt; gapsdk:$&#123;GAP_SDK_VERSION&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Step-4-更新-Crazyflie-自身固件"><a href="#Step-4-更新-Crazyflie-自身固件" class="headerlink" title="Step 4: 更新 Crazyflie 自身固件"></a>Step 4: 更新 Crazyflie 自身固件</h2><blockquote>
<p>以下操作在 <a href="https://github.com/bitcraze/crazyflie-firmware">crazyflie-firmware</a> 项目中完成（我们所使用的虚拟机里已经有该项目）</p>
</blockquote>
<ol>
<li>更新项目</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>激活 AI-deck</li>
</ol>
<ul>
<li>进入 <code>/firmware/tools/make/</code></li>
<li>创建新文件 config.mk</li>
<li>新增一行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CFLAGS += -DDECK_FORCE=bcAIDeck</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>无人机进入 bootloader 模式，烧录程序</li>
</ol>
<ul>
<li>按无人机启动按钮 2s 进入 bootloader 状态</li>
<li>使用 Flash using radio 烧录新固件</li>
</ul>
<img src="flash_using_radio.png" style="zoom:50%;" />

<blockquote>
<p>了解更多有关虚拟机使用以及烧录硬件的内容可以参考 <a href="https://www.bitcraze.io/documentation/tutorials/getting-started-with-development/">Programming the Crazyflie</a></p>
</blockquote>
<h2 id="Step-5-烧录人脸检测程序"><a href="#Step-5-烧录人脸检测程序" class="headerlink" title="Step 5: 烧录人脸检测程序"></a>Step 5: 烧录人脸检测程序</h2><ol>
<li><p>进入<code>AIdeck_examples/GAP8/image_processing_examples/FaceDetection/</code></p>
</li>
<li><p>编辑 Makefile，取消注释 <code>USE_STREAMER</code>，<code>USE_CAMERA</code></p>
</li>
<li><p>执行烧录命令</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run --rm -it -v $PWD:/module/data/ --device /dev/ttyUSB0 --privileged -P gapsdk:$&#123;GAP_SDK_VERSION&#125; /bin/bash -c &#x27;export GAPY_OPENOCD_CABLE=interface/ftdi/olimex-arm-usb-tiny-h.cfg; source /gap_sdk/configs/ai_deck.sh; cd /module/data/; make clean all image flash&#x27;</span><br></pre></td></tr></table></figure>

<img src="gap8_success.png" alt="Crazyflie 2.1" style="zoom:60%;" />

<h2 id="Step-6-大功告成"><a href="#Step-6-大功告成" class="headerlink" title="Step 6: 大功告成"></a>Step 6: 大功告成</h2><p>此时我们已经完成了全部的软件准备工作，可以运行查看结果啦！</p>
<ol>
<li><p>启动无人机，会有一个 WiFi 热点叫 <em>Bitcraze AI-deck example</em></p>
</li>
<li><p>PC 连接该热点</p>
</li>
<li><p>进入<code>AIdeck_examples/NINA/</code></p>
</li>
<li><p>执行 <code>python3 viewer.py</code></p>
</li>
<li><p>程序启动一个图形界面，成功看到 AI-deck 上的摄像头回传的画面</p>
</li>
</ol>
<img src="result.png" style="zoom:50%;" />

<blockquote>
<p>成功啦！会有一个黑色框框圈中人脸</p>
</blockquote>
<h1 id="有用的链接"><a href="#有用的链接" class="headerlink" title="有用的链接"></a>有用的链接</h1><ol>
<li><a href="https://github.com/bitcraze/AIdeck_examples">AIdeck_examples - Github</a>：AIdeck 项目的官方仓库，里面有更详细的 doc 来介绍每一个步骤，包括在引入 Docker 之前是如何一步步手动安装软件环境的。我也为这个项目的文档贡献了一些改进内容！嘿嘿~😜</li>
<li><a href="https://zhuanlan.zhihu.com/p/275774748">Olimex Debugger User’s Manual</a>：我的一个学习笔记，对 Debugger 官方手册内容的一个中文版的翻译与总结。</li>
<li><a href="https://store.bitcraze.io/collections/decks/products/ai-deck">AI-deck - Bitcraze Store</a>：官方商城里的 AI-deck 介绍页，更多细节可以在此找到。</li>
<li><a href="https://www.bitcraze.io/category/ai-deck/">AI-deck - Bitcraze Blog</a>：官方博客有关 AI-deck 的内容，可以了解到 AI-deck 诞生前后的故事。</li>
<li><a href="https://forum.bitcraze.io/viewforum.php?f=21&sid=0685cced2e47581fceb923f480272380">AI-deck - Bitcraze Forum</a>：官方论坛的 AI-deck 板块，<a href="https://forum.bitcraze.io/memberlist.php?mode=viewprofile&u=4094">我</a>也在这里问过不少问题。</li>
</ol>
]]></content>
      <categories>
        <category>科研分享</category>
      </categories>
      <tags>
        <tag>Crazyflie</tag>
        <tag>无人机</tag>
        <tag>AI-deck</tag>
        <tag>边缘计算</tag>
      </tags>
  </entry>
  <entry>
    <title>「Crazyflie开源无人机」基础入门</title>
    <url>/c.%E7%A7%91%E7%A0%94%E5%88%86%E4%BA%AB/History/%E3%80%8CCrazyflie%E5%BC%80%E6%BA%90%E6%97%A0%E4%BA%BA%E6%9C%BA%E3%80%8D%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Crazyflie 微型四轴飞行器的硬件设计得非常优秀，不管是 PCB 机械层的轮廓设计、信号层上元器件的布局还是整个电路板的走线都非常合理，而且最重要的是 Bitcraze 团队将模块化的理念带入到 Crazyflie产品的设计之中，这使得 Crazyflie 微型四轴除了基本的飞行功能之外，还可以通过堆叠不同扩展坞的方式来实现不同功能的扩展。</p>
]]></content>
      <categories>
        <category>科研分享</category>
      </categories>
      <tags>
        <tag>Crazyflie</tag>
        <tag>无人机</tag>
      </tags>
  </entry>
  <entry>
    <title>「本科毕业设计论文」Design and Implementation of An Intelligent Alert Management Platform for Data Center Network</title>
    <url>/c.%E7%A7%91%E7%A0%94%E5%88%86%E4%BA%AB/History/%E3%80%8C%E6%9C%AC%E7%A7%91%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E8%AE%BA%E6%96%87%E3%80%8DDesign-and-Implementation-of-An-Intelligent-Alert-Management-Platform-for-Data-Center-Network/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>科研分享</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>字节跳动</tag>
        <tag>SDN</tag>
        <tag>数据中心</tag>
        <tag>数据中心网络</tag>
      </tags>
  </entry>
  <entry>
    <title>「调研汇报」Google Network</title>
    <url>/c.%E7%A7%91%E7%A0%94%E5%88%86%E4%BA%AB/History/%E3%80%8C%E8%B0%83%E7%A0%94%E6%B1%87%E6%8A%A5%E3%80%8DGoogle%20Network/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>科研分享</category>
      </categories>
      <tags>
        <tag>数据中心网络</tag>
        <tag>Google</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>「调研汇报」Multi-Robot Active Sensing and Environmental Model Learning With Distributed Gaussian Process</title>
    <url>/c.%E7%A7%91%E7%A0%94%E5%88%86%E4%BA%AB/History/%E3%80%8C%E8%B0%83%E7%A0%94%E6%B1%87%E6%8A%A5%E3%80%8DMulti-Robot-Active-Sensing-and-Environmental-Model-Learning-With-Distributed-Gaussian-Process/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>科研分享</category>
      </categories>
      <tags>
        <tag>集群协作</tag>
        <tag>机器人</tag>
        <tag>高斯过程</tag>
      </tags>
  </entry>
  <entry>
    <title>「调研汇报」在无人机自组网中引入计算卸载技术</title>
    <url>/c.%E7%A7%91%E7%A0%94%E5%88%86%E4%BA%AB/History/%E3%80%8C%E8%B0%83%E7%A0%94%E6%B1%87%E6%8A%A5%E3%80%8D%E5%9C%A8%E6%97%A0%E4%BA%BA%E6%9C%BA%E8%87%AA%E7%BB%84%E7%BD%91%E4%B8%AD%E5%BC%95%E5%85%A5%E8%AE%A1%E7%AE%97%E5%8D%B8%E8%BD%BD%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="边缘计算与计算卸载"><a href="#边缘计算与计算卸载" class="headerlink" title="边缘计算与计算卸载"></a>边缘计算与计算卸载</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为了应对终端设备处理能力不足、资源有限等问题，业界在移动边缘计算（MEC）中引入了计算卸载概念 。边缘计算卸载即用户终端（UE）将计算任务卸载到MEC网络中，主要解决设备在资源存储、计算性能以及能效等方面的不足。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着科技的快速发展，移动设备流量急剧增长。但是由于自身资源及计算性能有限，智能移动设备在处理计算密集型和时间敏感型应用时可能面临着能力不足的情况。为此，使用网络边缘节点来处理分析数据的边缘计算模式应运而生，并与传统云计算模式形成互补。然而，边缘设备往往具有轻量化的特点，如何合理利用边缘有限的计算资源便成为边缘计算亟需解决的重要问题。</p>
<p>边缘计算针对传统云计算能力不足，在移动用户附近的无线接入网络边缘提供云计算功能，满足快速交互响应的需求，提供普遍且灵活的计算服务。为使用边缘网络提供的服务，移动设备如何将所承担的任务卸载到边缘服务器，进行高效合理的卸载决策，已经成为目前边缘计算问题的主要研究方向。</p>
<blockquote>
<p>类比到无人机集群中，我们会将普通无人机上计算机较大的计算任务卸载到无人机集群网络中具有较强计算能力的计算节点上（搭载了 AI-Deck 的无人机）。</p>
</blockquote>
<p>计算卸载是边缘计算的一个关键技术，可以为资源受限设备运行计算密集型应用提供计算资源，加快计算速度，节省能源。更详细的说，边缘计算中的计算卸载是将移动终端的计算任务卸载到边缘云环境中，解决了设备在资源存储、计算性能以及能效等方面存在的不足。</p>
]]></content>
      <categories>
        <category>科研分享</category>
      </categories>
      <tags>
        <tag>边缘计算</tag>
        <tag>无人机自组网</tag>
        <tag>计算卸载</tag>
      </tags>
  </entry>
  <entry>
    <title>「调研汇报」基于软件定义网络的智能无人机集群系统的设计与实现</title>
    <url>/c.%E7%A7%91%E7%A0%94%E5%88%86%E4%BA%AB/History/%E3%80%8C%E8%B0%83%E7%A0%94%E6%B1%87%E6%8A%A5%E3%80%8D%E5%9F%BA%E4%BA%8E%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E7%9A%84%E6%99%BA%E8%83%BD%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%9B%86%E7%BE%A4%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>科研分享</category>
      </categories>
      <tags>
        <tag>无人机</tag>
        <tag>SDN</tag>
      </tags>
  </entry>
  <entry>
    <title>三大室内技术：WIFI室内定位、蓝牙室内定位、UWB室内定位技术对比</title>
    <url>/c.%E7%A7%91%E7%A0%94%E5%88%86%E4%BA%AB/History/%E4%B8%89%E5%A4%A7%E5%AE%A4%E5%86%85%E6%8A%80%E6%9C%AF%EF%BC%9AWIFI%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D%E3%80%81%E8%93%9D%E7%89%99%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D%E3%80%81UWB%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>在万物互联的大背景下，位置信息的获取和应用在项目落地中越来越重要。相对于室外定位，室内定位的工作环境更为复杂、精细，其技术更是多种多样。<br>一般情况下，我们根据技术原理和使用信号源的不同，可以将室内定位技术分为以下这些：</p>
<ul>
<li>按定位原理划分：ID 定位、区间定位、三边定位、信号到达角定位、指纹定位、惯性推算等；</li>
<li>按定位所使用的信号源划分：Wi-Fi定位、ZigBee定位、蓝牙定位、UWB定位、RFID定位、卫星定位、低频触发定位、基站定位、声波定位、光定位、地磁定位等。<br>未来，室内定位技术将席卷我们生产、生活的方方面面，例如：智慧工厂人员及货物管理与调度、 生产安全管理、地下停车场寻车导航、智慧大楼人员/访客定位管理、 会展位置导航等。<br>下面我们就来探讨一下，目前的行业应用中比较常见的、基于无线局域网的三种室内定位技术。</li>
</ul>
]]></content>
      <categories>
        <category>科研分享</category>
      </categories>
      <tags>
        <tag>UWB</tag>
        <tag>室内定位</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机热门研究领域扫盲</title>
    <url>/c.%E7%A7%91%E7%A0%94%E5%88%86%E4%BA%AB/History/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%83%AD%E9%97%A8%E7%A0%94%E7%A9%B6%E9%A2%86%E5%9F%9F%E6%89%AB%E7%9B%B2/</url>
    <content><![CDATA[<p>最近有幸得到了东南大学预推免的机会，之前凭借自己对行业的观察和直觉选择了数据科学方向，但发现自己甚至还没有对数据科学的一些基本了解<br>借此机会对当前计算机领域各个研究方向做一个全面的基础的了解，算是一个扫盲的过程。</p>
<span id="more"></span>

<h1 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h1><h2 id="云与云计算"><a href="#云与云计算" class="headerlink" title="云与云计算"></a>云与云计算</h2><ul>
<li><a href="https://blog.csdn.net/weixin_41918841/article/details/89088987">云计算到底是怎么玩的(入门介绍)</a></li>
</ul>
<p>计算机资源不在本地，通过网络使用其他设备的计算机资源（计算资源，网络资源，存储资源等）。</p>
<blockquote>
<p>“云”实质上就是一个网络，狭义上讲，云计算就是一种提供资源的网络，使用者可以随时获取“云”上的资源，按需求量使用，并且可以看成是无限扩展的，只要按使用量付费就可以，“云”就像自来水厂一样，我们可以随时接水，并且不限量，按照自己家的用水量，付费给自来水厂就可以。<br>从广义上说，云计算是与信息技术、软件、互联网相关的一种服务，这种计算资源共享池叫做“云”，云计算把许多计算资源集合起来，通过软件实现自动化管理，只需要很少的人参与，就能让资源被快速提供。也就是说，计算能力作为一种商品，可以在互联网上流通，就像水、电、煤气一样，可以方便地取用，且价格较为低廉。<br>总之，云计算不是一种全新的网络技术，而是一种全新的网络应用概念，云计算的核心概念就是以互联网为中心，在网站上提供快速且安全的云计算服务与数据存储，让每一个使用互联网的人都可以使用网络上的庞大计算资源与数据中心。<br>云计算是继互联网、计算机后在信息时代有一种新的革新，云计算是信息时代的一个大飞跃，未来的时代可能是云计算的时代，虽然目前有关云计算的定义有很多，但总体上来说，云计算虽然有许多得含义，但概括来说，云计算的基本含义是一致的，即云计算具有很强的扩展性和需要性，可以为用户提供一种全新的体验，云计算的核心是可以将很多的计算机资源协调在一起，因此，使用户通过网络就可以获取到无限的资源，同时获取的资源不受时间和空间的限制。</p>
</blockquote>
<h2 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h2><p>目的是实现调度灵活。时间灵活性与空间灵活性。</p>
<h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><ul>
<li>Hypervisor：完成物理资源虚拟化，如VMware，KVM</li>
<li>OpenStack：KVM这样的Hypervisor软件，实际上是提供了一种虚拟化能力，模拟CPU的运行，更为底层。但是它的用户交互并不良好，不方便使用。于是，为了更好地管理虚拟机，就需要OpenStack这样的云管理平台。（这些属于IaaS）</li>
<li>容器：容器也是虚拟化，但是属于“轻量级”的虚拟化。它的目的和虚拟机一样，都是为了创造“隔离环境”。但是，它又和虚拟机有很大的不同——虚拟机是操作系统级别的资源隔离，而容器本质上是进程级的资源隔离。而大家常听说的Docker，就是创建容器的工具，是应用容器引擎。</li>
<li>K8S：除了Docker对容器进行创建之外，我们还需要一个工具，对容器进行编排。这个工具，就是K8S。K8S是一个容器集群管理系统，主要职责是容器编排（Container Orchestration）——启动容器，自动化部署、扩展和管理容器应用，还有回收容器。</li>
</ul>
<h2 id="私有云与公有云"><a href="#私有云与公有云" class="headerlink" title="私有云与公有云"></a>私有云与公有云</h2><p>公有云就是阿里云，腾讯云这些云服务商提供的服务。</p>
<p>私有云是企业或者个人自己拥有的云服务器，并且服务器不对外开放，仅供自己公司内部人使用。比如说有些大的企业数据文档需要共享，用云盘就很方便并且不用交给第三方保管，这从某种意义上来说降低了泄密的风险。另外，云服务器<strong>容错能力、抗风险能力都比较高</strong>，这是传统服务器所不能比的。<br>（私有云利用了云计算的特点，即资源不在本地，员工们随用随取）</p>
<p>另外还有混合云，主要由提供商管理的公共云与主要由客户业务管理的私有云之间的组合。这使得公司可以选择他们希望在内部保留哪些服务以及他们想要作为更通用（和通用）平台访问哪些服务，同时仍然将所有内容保留在云中。</p>
<h2 id="IaaS、PaaS-和-SaaS"><a href="#IaaS、PaaS-和-SaaS" class="headerlink" title="IaaS、PaaS 和 SaaS"></a>IaaS、PaaS 和 SaaS</h2><ul>
<li><p><a href="https://www.zhihu.com/question/20387284">怎么理解 IaaS、SaaS 和 PaaS 的区别？</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/21641778/answer/62523535">有哪些通俗易懂的例子可以解释 IaaS、PaaS、SaaS 的区别？ - 何足道的回答 - 知乎</a></p>
</li>
<li><p>IaaS：基础设施即服务</p>
</li>
<li><p>PaaS：平台即服务</p>
</li>
<li><p>SaaS：软件即服务</p>
</li>
</ul>
<p>以阿里云为例，普通的ECS云服务器属于IaaS，但例如云数据库，云存储这样的云应用属于平台级的PaaS。另外例如阿里学生机提供的「轻量应用服务器」也可以认为是PaaS。（IaaS和PaaS的界限不明显）</p>
<blockquote>
<p>如果你是一个网站站长，想要建立一个网站。不采用云服务，你所需要的投入大概是：买服务器，安装服务器软件，编写网站程序。现在你追随潮流，采用流行的云计算，如果你采用IaaS服务，那么意味着你就不用自己买服务器了，随便在哪家购买虚拟机，但是还是需要自己装服务器软件而如果你采用PaaS的服务，那么意味着你既不需要买服务器，也不需要自己装服务器软件，只需要自己开发网站程序如果你再进一步，购买某些在线论坛或者在线网店的服务,这意味着你也不用自己开发网站程序，只需要使用它们开发好的程序，而且他们会负责程序的升级、维护、增加服务器等，而你只需要专心运营即可，此即为SaaS。</p>
</blockquote>
<blockquote>
<p>Platform as a Service: 平台即服务, 是面向软件开发者的服务, 云计算平台提供硬件, OS, 编程语言, 开发库, 部署工具, 帮助软件开发者更快的开发软件服务. 比如Google的GAE.SaaS: 软件即服务, 是面向软件消费者的, 用户无需安装, 通过标准的Internet工具(比如浏览器), 即可使用云计算平台提供的软件, 比如Salesforce的CRM管理系统, Google的Gmail.还有IaaS 基础设施即服务, 这个跟PaaS的区别倒是不那么明显, 比如Amazon的IaaS服务AWS越来越像PaaS了。</p>
</blockquote>
<p><img src="https://pic3.zhimg.com/80/v2-cd6d71e4481f5ffe432c6b1255ae601b_hd.jpg"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>云计算面向用户隐藏了足够多的技术细节，我认为利用阿里云这些公有云厂商最大的好处一是弹性空间即买即用，二是省去了大量的运维工作。<br>云计算的研究应该还是侧重如何更好地进行资源调度，如何帮助用户进行资源迁移与部署。两个方面分别帮助云服务提供商和用户节省成本。</p>
<h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><ul>
<li><a href="https://www.cnblogs.com/xybaby/p/7787034.html">什么是分布式系统，如何学习分布式系统</a><br>分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。</li>
</ul>
<h2 id="以一个请求为例串起分布式系统的技术细节"><a href="#以一个请求为例串起分布式系统的技术细节" class="headerlink" title="以一个请求为例串起分布式系统的技术细节"></a>以一个请求为例串起分布式系统的技术细节</h2><p>　　用户使用Web、APP、SDK，通过HTTP、TCP连接到系统。在分布式系统中，为了高并发、高可用，一般都是多个节点提供相同的服务。那么，第一个问题就是具体选择哪个节点来提供服务，这个就是负载均衡（load balance）。负载均衡的思想很简单，但使用非常广泛，在分布式系统、大型网站的方方面面都有使用，或者说，只要涉及到多个节点提供同质的服务，就需要负载均衡。</p>
<p>　　通过负载均衡找到一个节点，接下来就是真正处理用户的请求，请求有可能简单，也有可能很复杂。简单的请求，比如读取数据，那么很可能是有缓存的，即分布式缓存，如果缓存没有命中，那么需要去数据库拉取数据。对于复杂的请求，可能会调用到系统中其他的服务。</p>
<p>　　承上，假设服务A需要调用服务B的服务，首先两个节点需要通信，网络通信都是建立在TCP/IP协议的基础上，但是，每个应用都手写socket是一件冗杂、低效的事情，因此需要应用层的封装，因此有了HTTP、FTP等各种应用层协议。当系统愈加复杂，提供大量的http接口也是一件困难的事情。因此，有了更进一步的抽象，那就是RPC（remote produce call），是的远程调用就跟本地过程调用一样方便，屏蔽了网络通信等诸多细节，增加新的接口也更加方便。</p>
<p>　　一个请求可能包含诸多操作，即在服务A上做一些操作，然后在服务B上做另一些操作。比如简化版的网络购物，在订单服务上发货，在账户服务上扣款。这两个操作需要保证原子性，要么都成功，要么都不操作。这就涉及到分布式事务的问题，分布式事务是从应用层面保证一致性：某种守恒关系。</p>
<p>　　上面说道一个请求包含多个操作，其实就是涉及到多个服务，分布式系统中有大量的服务，每个服务又是多个节点组成。那么一个服务怎么找到另一个服务（的某个节点呢）？通信是需要地址的，怎么获取这个地址，最简单的办法就是配置文件写死，或者写入到数据库，但这些方法在节点数据巨大、节点动态增删的时候都不大方便，这个时候就需要服务注册与发现：提供服务的节点向一个协调中心注册自己的地址，使用服务的节点去协调中心拉取地址。</p>
<p>　　从上可以看见，协调中心提供了中心化的服务：以一组节点提供类似单点的服务，使用非常广泛，比如命令服务、分布式锁。协调中心最出名的就是chubby，zookeeper。</p>
<p>　　回到用户请求这个点，请求操作会产生一些数据、日志，通常为信息，其他一些系统可能会对这些消息感兴趣，比如个性化推荐、监控等，这里就抽象出了两个概念，消息的生产者与消费者。那么生产者怎么讲消息发送给消费者呢，RPC并不是一个很好的选择，因为RPC肯定得指定消息发给谁，但实际的情况是生产者并不清楚、也不关心谁会消费这个消息，这个时候消息队列就出马了。简单来说，生产者只用往消息队列里面发就行了，队列会将消息按主题（topic）分发给关注这个主题的消费者。消息队列起到了异步处理、应用解耦的作用。</p>
<p>　　上面提到，用户操作会产生一些数据，这些数据忠实记录了用户的操作习惯、喜好，是各行各业最宝贵的财富。比如各种推荐、广告投放、自动识别。这就催生了分布式计算平台，比如Hadoop，Storm等，用来处理这些海量的数据。</p>
<p>　　最后，用户的操作完成之后，用户的数据需要持久化，但数据量很大，大到按个节点无法存储，那么这个时候就需要分布式存储：将数据进行划分放在不同的节点上，同时，为了防止数据的丢失，每一份数据会保存多分。传统的关系型数据库是单点存储，为了在应用层透明的情况下分库分表，会引用额外的代理层。而对于NoSql，一般天然支持分布式。</p>
<h2 id="REST与RPC"><a href="#REST与RPC" class="headerlink" title="REST与RPC"></a>REST与RPC</h2><ul>
<li><a href="https://baijiahao.baidu.com/s?id=1617168792520937104&wfr=spider&for=pc">面试问题：REST与RPC区别？</a><br>REST调用及测试都很方便，RPC就显得有点繁琐，但是RPC的效率是毋庸置疑的，所以建议在多系统之间的内部调用采用RPC。  </li>
</ul>
<p><strong>对外提供的服务，Rest更加合适。</strong></p>
<h1 id="数据科学"><a href="#数据科学" class="headerlink" title="数据科学"></a>数据科学</h1><ul>
<li><a href="https://www.zhihu.com/question/54521940/answer/489379445">数据科学 data science 是什么？</a><br>包括了：<ul>
<li>数据挖掘</li>
<li>统计推断</li>
<li>机器学习</li>
<li>数据工程</li>
<li>决策智能</li>
</ul>
</li>
</ul>
<h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/40217622">大数据学什么？</a></li>
<li><a href="https://www.zhihu.com/question/27292215/answer/133141387">如何入门大数据（数据挖掘方面）？</a></li>
</ul>
<p>看了一圈之后发现其实目前的这些热门方向可以连在一起形成一个闭环。</p>
<h2 id="ETL程序"><a href="#ETL程序" class="headerlink" title="ETL程序"></a>ETL程序</h2><p>ETL是将业务系统的数据经过抽取、清洗转换之后加载到数据仓库的过程，目的是将企业中的分散、零乱、标准不统一的数据整合到一起，为企业的决策提供分析依据。</p>
<h1 id="物联网"><a href="#物联网" class="headerlink" title="物联网"></a>物联网</h1><ul>
<li><a href="https://www.zhihu.com/question/19751763/answer/95871992">什么是物联网？其发展前景如何？</a></li>
</ul>
<h2 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/52864297">一文读懂边缘计算和边缘智能，以及它们和ARM的暧昧关系</a><br>“大智能”在云端，“小智能”在边缘，仍是长期趋势。</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>看完之后依旧头大，还没完全清楚自己感兴趣的方向。另外一个感觉就是这些名词总是在把简单问题复杂化，接下来的这些天再继续了解。  </p>
<h2 id="从招聘入手"><a href="#从招聘入手" class="headerlink" title="从招聘入手"></a>从招聘入手</h2><p>突发奇想想看看大厂们的招聘都在招什么岗位</p>
<ul>
<li><p><a href="https://campus.alibaba.com/positionList.htm?spm=a1z3e1.11770916.0.0.6c0f723anKzi6x">阿里巴巴校园招聘岗位</a></p>
</li>
<li><p>算法工程师</p>
<ul>
<li>语音对话交互：深度学习、语音识别、语音合成、自然语言处理、语音交互、人工智能</li>
<li>运筹优化：机器学习、运筹学（电商，物流和计算资源调度）</li>
<li>自然语言处理</li>
<li>计算机图形</li>
<li>计算机视觉</li>
<li>机器学习</li>
</ul>
</li>
<li><p>数据研发工程师</p>
<ul>
<li>大数据的采集、存储、处理，通过分布式大数据平台加工数据，支持业务管理决策</li>
<li>大数据体系的设计、开发、维护，通过数据仓库、元数据、质量体系有效的管理和组织几百P的数据</li>
<li>大数据产品的研发，通过对数据的理解，发挥你的商业sense，发掘数据价值，探索大数据商业化</li>
</ul>
</li>
<li><p>研发工程师</p>
<ul>
<li>基础技术（基础软件的设计、开发和维护）</li>
<li>高性能分布式技术</li>
<li>搜索技术</li>
<li>电子商务产品技术</li>
<li>海量数据处理和开发</li>
<li>客户端开发</li>
</ul>
</li>
<li><p>基础平台研发工程师（全栈）</p>
<ul>
<li>云基础设施技术</li>
<li>虚拟化技术</li>
<li>MySQL、PostgrelSQL、MongoDB、Redis、HBase等开源数据库内核的改进</li>
<li>分布式系统</li>
<li>大数据在线引擎体系</li>
</ul>
</li>
</ul>
<h2 id="SEU"><a href="#SEU" class="headerlink" title="SEU"></a>SEU</h2><p>根据SEU计算机学院的导师方向对目前计算机科学的研究领域做一个分类</p>
<ul>
<li>网络计算</li>
<li>数据科学</li>
<li>机器学习与知识工程</li>
<li>智能系统与应用</li>
<li>计算机软件与理论</li>
<li>影响科学与图像处理</li>
</ul>
<p>总体来说，交叉技术运用的越来越明显，人工智能，网络，软件理论是几个主要的研究方向。</p>
<p>最后放一张闲来无事做的SEU计算机学院导师们研究方向的词云。<br><img src="http://ww4.sinaimg.cn/large/006y8mN6ly1g67cepr7rej314v0u0x0u.jpg"></p>
]]></content>
      <categories>
        <category>科研分享</category>
      </categories>
      <tags>
        <tag>研究生</tag>
        <tag>科普</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机学科生涯漫谈</title>
    <url>/d.%E6%9D%82%E6%96%87%E9%9A%8F%E7%AC%94/History/210706-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E7%A7%91%E7%94%9F%E6%B6%AF%E6%BC%AB%E8%B0%88/</url>
    <content><![CDATA[<p>很开心实现了一直以来的一个小心愿，就是能有机会和学弟学妹们分享一下我大学期间的一些经验、心得与体会！<br>本分享进行于单老师在2021年暑期期间开设的《专业阅读与写作》课程，线上线下大概有150人左右，感谢老师给我这个机会！</p>
]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>计算机</tag>
        <tag>大学</tag>
        <tag>保研</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>还是想夸夸「东大信息化」</title>
    <url>/d.%E6%9D%82%E6%96%87%E9%9A%8F%E7%AC%94/History/220218-%E8%BF%98%E6%98%AF%E6%83%B3%E5%A4%B8%E5%A4%B8%E3%80%8C%E4%B8%9C%E5%A4%A7%E4%BF%A1%E6%81%AF%E5%8C%96%E3%80%8D/</url>
    <content><![CDATA[<p>最近因为疫情管控，很多老师都不方便进学校，东大信息化即时推出了线上电子签的功能，对于忙于硕士开题的我来说解决了很多问题。</p>
<p>可能对于很多本科生同学来说已经习惯了东大的校园信息服务，但是作为本科毕业于另一所985高校的我，在本硕的实际对比下，还是想夸夸咱们“东大信息化”！</p>
]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>SEU</tag>
        <tag>信息化</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT-Index - 使用飞书享受博客写作乐趣</title>
    <url>/d.%E6%9D%82%E6%96%87%E9%9A%8F%E7%AC%94/History/Hexo-NexT-Index-%E4%BD%BF%E7%94%A8%E9%A3%9E%E4%B9%A6%E4%BA%AB%E5%8F%97%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E4%B9%90%E8%B6%A3/</url>
    <content><![CDATA[<blockquote>
<p>📓如果你在寻找一个简单优雅的博文写作方式？如果你也和我一样懒想自建博客但又不愿为维护投入太多精力？如果你喜欢简洁追求效率？我相信，你一定会喜欢 Hexo-NexT-Index 😉<br>这也是本博客搭建的方式</p>
</blockquote>
]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>飞书</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>我在字节跳动的十个月</title>
    <url>/d.%E6%9D%82%E6%96%87%E9%9A%8F%E7%AC%94/History/%E6%88%91%E5%9C%A8%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E7%9A%84%E5%8D%81%E4%B8%AA%E6%9C%88/</url>
    <content><![CDATA[<p>很荣幸在大四得到了字节网络组的实习机会，没想到这一待就是十个月。<br>虽然赶上了新冠疫情这一黑天鹅，但还是在这段时间学到了很多东西，除了技术上的学习，对未来工作内容，对大公司运作模式，对网络开发完整流程的体验以及伴随而来的方法论也学到了很多，也在不断寻找自己的定位与目标。<br>感谢非常非常厉害的 mentor，感谢各位优秀的同事，第一次有机会和这么多优秀的人一起做有挑战的事，提出的每个想法都得到了积极的倾听与反馈并给予足够的机会与鼓励去尝试，作为网络小菜鸡真的感受到了足够的平等与尊重。<br>Last day 赶上了最后一次团建，被灌了最多的酒也愈发舍不得离开。祝愿字节在成为全球顶级科技公司的道路上永远保持活力，祝愿各位 ByteDancers 永远年轻，永远快乐。<br>即将开始研究生的新征程，期待与字节的下一次邂逅！  </p>
]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>字节跳动</tag>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title>0328-校招面试初体验&amp;这一年</title>
    <url>/d.%E6%9D%82%E6%96%87%E9%9A%8F%E7%AC%94/History/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="试试看"><a href="#试试看" class="headerlink" title="试试看"></a>试试看</h1><p>前些日子腾讯来我校开暑期实习宣讲会，现场人多到爆<del>因为腾讯有年头没来我们学校开宣讲会了，今年能来实属不易，也感谢学院老师们背后的默默付出还有在腾讯工作的学姐学长们的努力。<br>因为是要读研，所以一直也没太准备找工作方面的事情，但感觉可以试试看，看看自己有没有能力通过第一关</del>索性投了WXG微信事业群的后台开发岗位。</p>
<span id="more"></span>
<h1 id="视频面试"><a href="#视频面试" class="headerlink" title="视频面试"></a>视频面试</h1><p>昨天下午收到了视频面试的短信，忐忑不安的刷了一天基础知识，发现之前学过的很多都忘了，连哈希冲突解决方法都记不住了。<br>五点面试准时开始，面试官首先问了我简历上写的实习经历，我讲了一下在葫芦那边做的小程序和服务号。<br>另外还问了我一些是不是动态爬虫，怎么解析网页的问题。</p>
<h2 id="第一题-手写代码"><a href="#第一题-手写代码" class="headerlink" title="第一题 手写代码"></a>第一题 手写代码</h2><h3 id="最长子序列"><a href="#最长子序列" class="headerlink" title="最长子序列"></a>最长子序列</h3><p>小Q定义A(i,j)(i &lt;= j且都是数组A的合法下标)表示数组A中下标从i到j的这段子序列,即A(i,j) = {A[i],A[i+1]….A[j]}。<br>如果对于A(i, j), 能找到一个正整数v(v &gt; 1), 使得v可以整除A(i, j)中不低于一半的元素, 小Q就认为A(i, j)是一段很酷的子序列。<br>例如A(i, j) = {3, 3, 7, 9, 1, 10}, 六个元素中有三个元素可以被v = 3整除, 所以A(i, j)是酷的。<br>小Q现在给出一个数组A, 让你找出最长的酷的子序列。</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><p>输入包括两行。<br>第一行包括一个正整数n(1 &lt;= n &lt;= 50), 表示数组的长度。<br>第二行包括n个正整数A_i,(1 &lt;= A_i &lt;= 1000), 表示数组中的每个元素。</p>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>输出一个整数, 表示最长的酷的子序列的长度, 如果没有解, 输出0。</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><ul>
<li>输入<ul>
<li>5</li>
<li>8 8 5 5 4</li>
</ul>
</li>
<li>输出<ul>
<li>5</li>
</ul>
</li>
</ul>
<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>Java顶层的集合类有哪些？常用哪些？</p>
<h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>有没有写过多线程程序？讲讲多线程。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>面试官出的几个问题都很简单，不过第一题因为是第一次面试很紧张也没什么经验我以为还要运行一下程序，还在想import的语句是什么。但其实并不需要，只要逻辑ok就行。读题不仔细，有两个地方理解错了在面试官的告知下才该对。应该是凉了，不过权当一次经历吧。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从去年3月到今年3月这一年自己其实过得挺痛苦的，感觉目前的自己各方面都和目标差太远，无论是技术、学习能力还是各方面交际能力、为人处事都很一般。<br>不过这一年也算是大学两年半以来过得最充实的一段时间吧，学习方面两个学期拿到了90的均分，绩点提到了3.7；竞赛水了5个小奖，还有幸公费去了次哈尔滨；有了一段创业公司的实习经历，认识了很多与我同年级但情商智商碾压的大佬；通过大创接触到了一点点科研，虽然目前还没发出paper；陆陆续续做了自己喜欢的weNEU，寄托了自己对产品的价值理念等等~  </p>
<h2 id="痛苦着"><a href="#痛苦着" class="headerlink" title="痛苦着"></a>痛苦着</h2><p>痛苦在于这一年意识到了自己和最优秀的同学们差距实在太大，而且这种差距还在不断拉大。我觉得人生的目标是不能做一个平凡的人，如果只是一个普普通通的人，天天被割韭菜活着也没什么意义。可是这一年我意识到自己越来越普通，和很多人一样为读研挤破头，参加竞赛顶多拿小奖，学习知识要花很长时间才能学懂；<br>另外的痛苦在于对未来选择的迷茫，从读研方向来看我甚至不知道自己该报考什么方向，对人工智能不感兴趣，对云计算大数据也不是很了解，密码学网络安全有些跨专业~对于未来的就业而言我其实觉得自己比较适合产品岗位，我自认自己的一些商业嗅觉比较灵敏，对用户体验的把控也有自己的见解，在做weNEU的期间真的对产品抱有极大的热情，看到有新用户增长会开心好久。但如果决定做产品似乎也没必要读研了，而且也挺喜欢敲代码不太想天天去做PPT。<br>痛苦了一年，也磨磨唧唧讲了一年。是时候不再总去想这些事情了，认识到差距就好。</p>
<h2 id="读研"><a href="#读研" class="headerlink" title="读研"></a>读研</h2><p>目前来看我认为我读研的原因是：</p>
<ul>
<li>增加知识的深度：之前过于注重知识的广度，UI/UE、前端开发、后端开发、运维、产品运营、推广我都有或多或少的接触但并不精，读研我需要提升自己在某一方面的知识的深度，目前来看我应该会选择软件工程专硕，具体方向待定。</li>
<li>我还年轻：不想太早离开象牙塔，我认为我不适合过早就业（应该不是逃避）；细想如果我2020开始工作，未来至少30年左右都会一直在工作~很难再回到现在这样大学校园中，珍惜读书的时光</li>
<li>对学历的私心：本科只是一所末流985，研究生希望能到中九级别的学校吧，不然会很遗憾的。</li>
</ul>
<h2 id="学到的"><a href="#学到的" class="headerlink" title="学到的"></a>学到的</h2><ul>
<li>告别舒适区：少刷已经学会的算法题；少做重复性工作；少写业务代码</li>
<li>信息不对称：遇到机会要鼓起勇气，认识更多的人，获取更多的信息</li>
<li>保持善良，不忘初心：之前总觉得这些假大空的形容词很无趣，但到头来才发现这其实都是最优秀的品质</li>
</ul>
<h2 id="拒绝平凡"><a href="#拒绝平凡" class="headerlink" title="拒绝平凡"></a>拒绝平凡</h2><p>引用很喜欢的毛不易的《像我这样的人》——像我这样不甘平凡的人~句句扎心，不认为“平凡可贵”</p>
<h2 id="贵在坚持"><a href="#贵在坚持" class="headerlink" title="贵在坚持"></a>贵在坚持</h2><p>无论何时，贵在坚持都是最需要的。<br>如果我不能坚持的话，那么一切的向往，一切的为自己加油打气，一切的计划都是空谈。  </p>
]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>腾讯</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>0327-记在葫芦实习的六个月</title>
    <url>/d.%E6%9D%82%E6%96%87%E9%9A%8F%E7%AC%94/History/%E8%AE%B0%E5%9C%A8%E8%91%AB%E8%8A%A6%E5%AE%9E%E4%B9%A0%E7%9A%84%E5%85%AD%E4%B8%AA%E6%9C%88/</url>
    <content><![CDATA[<h1 id="葫芦"><a href="#葫芦" class="headerlink" title="葫芦"></a>葫芦</h1><p>和葫芦科技的第一次接触是在18年9月，当时有幸在林根大佬的带领下接触到葫芦科技。葫芦科技是一家创业公司，挂靠在东北大学东创空间旗下。<br>短短六个月来持续开发维护运营了“weNEU小程序”、“东大葫芦服务号”、“享问3.0”等有趣的应用，也参与策划了“东大锦鲤”、“东大女生节”、“元旦晚会游戏”、“年终总结”等活动~六个月来认识了很多小伙伴，才发现有这么多和我同届但早已在创业方面做出很多成果的同学。</p>
<h1 id="再见"><a href="#再见" class="headerlink" title="再见"></a>再见</h1><p>因为四月开始要忙于准备读研相关的事情，可能要暂时离开葫芦了，感谢大家一直以来的帮助，有缘再见~<br><img src="http://ws4.sinaimg.cn/large/006tKfTcly1g1ify2z9ahj31400u0qva.jpg" align=center></p>
]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>葫芦科技</tag>
      </tags>
  </entry>
  <entry>
    <title>1125-记在字节实习的第一个月</title>
    <url>/d.%E6%9D%82%E6%96%87%E9%9A%8F%E7%AC%94/History/%E8%AE%B0%E5%9C%A8%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%AE%9E%E4%B9%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%88/</url>
    <content><![CDATA[<p>至今仍然感到很幸运，对于本想轻轻松松潇潇洒洒度过大四的我，在几乎完全没准备招聘面试的情况下，竟然通过了字节跳动的面试，转眼间已经入职一个月了，也来简单写写这一个月的一些心得与感悟。<br>简简单单的流水账~  </p>
<h3 id="紧张与庆幸"><a href="#紧张与庆幸" class="headerlink" title="紧张与庆幸"></a>紧张与庆幸</h3><p>开篇提到了，我几乎完全没准备招聘面试的内容，面经刷题什么的基本上啥都没看，因为本来就是抱着随缘的心态投的简历，没想到运气这么好hh<br>可是我知道自己很菜，而且岗位还是和计算机网络深度相关的，作为软件工程专业的学生（非网络工程专业），本科就只上过“计算机网络”一门网络相关课程，感觉亚历山大，这种压力，在我收到offer通知电话那一刻就开始了，一直到入职前夜的失眠，到入驻当天的忐忑，到入驻后看着纷乱复杂的各种名词，直到现在，我依然很紧张<br>但是我也很庆幸，非常庆幸我能在大四上学期，在读研之前意识到我在计算机网络方面的知识储备很少，意识到计算机网络的体系是如此庞大，我能做的只有抓紧时间，利用字节跳动提供的这么好的机会打好计算机网络基础，为研究生的学习与科研做准备  </p>
<img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9asxzyam2j31400u04qr.jpg" align=center>

<span id="more"></span>

<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>感觉自己九月份以来的运气真的特别好，顺利地拿到了保研资格，顺利地确定了自己心心念念的计算机网络就是我最想攻读的方向，顺利的发现拿到offer的东南大学计算机恰好计算机网络是其最强的方向，顺利地被年轻有为帅气的S老师收下（老师看过我博客，先吹一下老师hhh），顺利地找到一份计算机网络相关的实习，顺利地遇到了如此优秀非常佩服的Ian担任我的mentor~<br>当然最幸运的就是上面我所说的，意识到<strong>自己还有更大的理想和目标！一定要把握好每一个机会利用好每一段时光</strong><br>还想谈谈自己为什么选择了计算机网络，原因有2吧  </p>
<ul>
<li>想避开人工智能的热潮。保研期间看到很多同学直奔人工智能那些方向，竞争激烈而且我对人工智能没有太大的兴趣，本科有几门课接触过人工智能，我觉得我还是更喜欢“计算机网络”，“操作系统”这些学完后感觉学到了知识心里踏实的课哈哈。尤其是计算机网络，在本科四门主要专业课中是我最喜欢也是分数最高的一门课~~</li>
<li>贴近产品思维。当然，计算机网络分很多分支，我最初想选择的是 物联网 或 产业互联网 这两个方向，因为在调研之后我发现这两个方向的应用落地都做的还不错，都是现在国家和大厂纷纷押宝的风口，最重要的是这些领域的研究很多都是面向用户的，面向用户的C端产品自然需要很强的产品思维，我觉得我在产品运营方面还是有一定的独到见解，因而选择了这两个细分领域。</li>
</ul>
<h3 id="在做的工作"><a href="#在做的工作" class="headerlink" title="在做的工作"></a>在做的工作</h3><p>我所在的部门是系统部的网络工程组，最初来到这里很惊讶只有大概20人左右其中主管运维建设的不足10人就能建设起公司如此巨大的网络架构。<br>目前在做的项目是网络告警平台，后来经组会讨论升级为网络数据平台，主要工作是升级目前系统内分散部分未聚合展现形式落户的告警平台，同时利用采集的数据搭建一套数据平台，为SDN等项目提供低时延高可靠的数据支撑。<br>完整的数据平台预计在十二月中旬就能初步成型，之后可能会同时参与到SDN项目的开发之中，考虑到研究生的方向，后续会尝试多接触与算法设计分析相关的工作，另外SDN的设计思想（大规模服务器集群数据中心的必然产物）和多无人机协同的管理平台也有异曲同工之处。</p>
<h3 id="最大的挑战"><a href="#最大的挑战" class="headerlink" title="最大的挑战"></a>最大的挑战</h3><p>于我而言，最大的挑战还是人际关系。我每次到一个新的环境中都比较内向<br>然而熟了之后就完全放得开了。不过实习可能是全新的一种环境，人与人之间是同事关系，而且年龄差，工作内容，知识量上的差距还是让我和大家的融入不是那么地顺利，不过我相信我会努力让大家看到我的闪光点。<br>努力哦~</p>
]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>字节跳动</tag>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title>飞书在高校先进科研协作中的实践</title>
    <url>/d.%E6%9D%82%E6%96%87%E9%9A%8F%E7%AC%94/History/%E9%A3%9E%E4%B9%A6%E5%9C%A8%E9%AB%98%E6%A0%A1%E5%85%88%E8%BF%9B%E7%A7%91%E7%A0%94%E5%8D%8F%E4%BD%9C%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>高校之中尤其是计算机学科相关的科研团队其实与互联网公司在工作内容、工作方式、组织结构上有着高度的相似性，但一个科研团队之中几乎人人都是“研发人员”，缺少了“行政、产品、运营、效率、HRBP”等各职能同学的支持。<br>但还好，我们有飞书。<br>飞书是一款理念先进、贴合用户需求的 all in one 办公套件，这些特点帮助我们在飞书上高效开展科研项目协作。</p>
]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>飞书</tag>
        <tag>效率</tag>
        <tag>协作</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算常见软件概念梳理</title>
    <url>/b.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/History/210604-%E4%BA%91%E8%AE%A1%E7%AE%97%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>IT软件技术架构进入云化时代后，新概念、新技术大量涌现。从几年前热火的Openstack、计算存储网络三大虚拟化技术、Iaas平台，到近几年更火热的容器和云原生的相关技术，在云计算这一领域新技术可谓是层出不穷。<br>我们经常会听到的这些概念，比如容器、docker、kubernetes、微服务架构、PaaS平台、服务中台、Devops、云原生等等。这些技术和概念彼此之间感觉是独立的，我们很容易从其中某一个角度学习入手并应用；但是，很多时候，我们会发现这些技术彼此之间又有密切的关联，从文章也好、技术落地应用的场景也好，它们往往又出现在同一个地方。它们之间究竟有什么联系，彼此之间有什么依赖，让人十分的困惑。<br>在本文中，从这些技术彼此之间的依赖和关系入手，讲述它们在当今软件云化和微服务化时代中的作用，希望读者从这些总结对比入手，对微服务相关的技术体系建立全局性的视野和理解。  </p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>云计算</tag>
        <tag>微服务</tag>
        <tag>云原生</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo 3 知识结构梳理</title>
    <url>/b.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/History/210916-Dubbo-3-%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<p>最近在参加阿里云举办的云原生挑战赛，其开发是基于Dubbo的。久仰Dubbo大名，知道它是一个集微服务领域众多技术于一体的大而全的框架，借此机会系统性地学习一下。<br>本篇梳理基于Dubbo3的官方文档整理。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>云原生</tag>
        <tag>Dubbo</tag>
        <tag>服务发现</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>一文总结常用排序算法及面试考点</title>
    <url>/b.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/History/220429-%E4%B8%80%E6%96%87%E6%80%BB%E7%BB%93%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%8F%8A%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9/</url>
    <content><![CDATA[<ul>
<li>排序算法经常作为CS算法课程中的入门算法来引入，因为各种各样的排序算法中包含了很多的计算机科学思想，例如：<ul>
<li>基于比较（Comparision）和不基于比较的策略；</li>
<li>迭代（Iterative）或递归（Recursive）的实现</li>
<li>分支（Divide-and-Conquer）的机制（例如归并排序与快速排序）</li>
<li>最好/最差/平均 时间复杂度分析</li>
<li>随机算法（Randomized Algorithm）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>面试</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>SDN 入门</title>
    <url>/b.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/History/SDN-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SDN</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析学习笔记</title>
    <url>/b.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/History/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本学期开设了<em><strong>数值分析</strong></em>课程。这是我本科期间最后一门数学课了。<br>认真学习之余，整理了很多解题套路。虽然直接上套路解题不好，但我认为如果能先把题解出来，我们也可以更好地反思解题的原理。<br><em>另外，想了很久还是决定用手写到白纸上，这样更容易表达我的想法。</em><br><strong>希望这学期的数值分析会有好结果！加油！</strong>  </p>
<span id="more"></span>

<h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="走进数值分析及误差"><a href="#走进数值分析及误差" class="headerlink" title="走进数值分析及误差"></a>走进数值分析及误差</h3><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_1.jpg?raw=true" align=center>

<h3 id="避免误差的5种方法"><a href="#避免误差的5种方法" class="headerlink" title="避免误差的5种方法"></a>避免误差的5种方法</h3><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_2.jpg?raw=true" align=center>

<h2 id="第二章-解线性方程组的直接方法"><a href="#第二章-解线性方程组的直接方法" class="headerlink" title="第二章 解线性方程组的直接方法"></a>第二章 解线性方程组的直接方法</h2><h3 id="3种矩阵分解的分解形式及求解方法"><a href="#3种矩阵分解的分解形式及求解方法" class="headerlink" title="3种矩阵分解的分解形式及求解方法"></a>3种矩阵分解的分解形式及求解方法</h3><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_3.jpg?raw=true" align=center>

<h3 id="范数、条件数、谱半径（评估矩阵的工具）"><a href="#范数、条件数、谱半径（评估矩阵的工具）" class="headerlink" title="范数、条件数、谱半径（评估矩阵的工具）"></a>范数、条件数、谱半径（评估矩阵的工具）</h3><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_4.jpg?raw=true" align=center>

<h2 id="第三章-解线性方程组的迭代法"><a href="#第三章-解线性方程组的迭代法" class="headerlink" title="第三章 解线性方程组的迭代法"></a>第三章 解线性方程组的迭代法</h2><h3 id="3种迭代法解题步骤"><a href="#3种迭代法解题步骤" class="headerlink" title="3种迭代法解题步骤"></a>3种迭代法解题步骤</h3><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_5.jpg?raw=true" align=center>

<h2 id="第四章-非线性方程求根"><a href="#第四章-非线性方程求根" class="headerlink" title="第四章 非线性方程求根"></a>第四章 非线性方程求根</h2><h3 id="3种迭代法"><a href="#3种迭代法" class="headerlink" title="3种迭代法"></a>3种迭代法</h3><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_6.jpg?raw=true" align=center>

<h2 id="期中复习"><a href="#期中复习" class="headerlink" title="期中复习"></a>期中复习</h2><h3 id="知识框架"><a href="#知识框架" class="headerlink" title="知识框架"></a>知识框架</h3><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_12.jpg?raw=true" align=center>

<h2 id="第六章-插值与逼近"><a href="#第六章-插值与逼近" class="headerlink" title="第六章 插值与逼近"></a>第六章 插值与逼近</h2><h3 id="3种基本插值方法"><a href="#3种基本插值方法" class="headerlink" title="3种基本插值方法"></a>3种基本插值方法</h3><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_7.jpg?raw=true" align=center>

<h2 id="第六章-插值与逼近-1"><a href="#第六章-插值与逼近-1" class="headerlink" title="第六章 插值与逼近"></a>第六章 插值与逼近</h2><h3 id="分段插值、正交多项式、拟合"><a href="#分段插值、正交多项式、拟合" class="headerlink" title="分段插值、正交多项式、拟合"></a>分段插值、正交多项式、拟合</h3><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_8.jpg?raw=true" align=center>

<h2 id="第七章-数值积分与数值微分"><a href="#第七章-数值积分与数值微分" class="headerlink" title="第七章 数值积分与数值微分"></a>第七章 数值积分与数值微分</h2><h3 id="数值积分概述"><a href="#数值积分概述" class="headerlink" title="数值积分概述"></a>数值积分概述</h3><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_9.jpg?raw=true" align=center>

<h2 id="第七章-数值积分与数值微分-1"><a href="#第七章-数值积分与数值微分-1" class="headerlink" title="第七章 数值积分与数值微分"></a>第七章 数值积分与数值微分</h2><h3 id="复化求积公式、Gauss型求积公式"><a href="#复化求积公式、Gauss型求积公式" class="headerlink" title="复化求积公式、Gauss型求积公式"></a>复化求积公式、Gauss型求积公式</h3><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_10.jpg?raw=true" align=center>

<h2 id="第八章-常微分方程数值解法"><a href="#第八章-常微分方程数值解法" class="headerlink" title="第八章 常微分方程数值解法"></a>第八章 常微分方程数值解法</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_11.jpg?raw=true" align=center>
### 必考题型
<img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_15.jpg?raw=true" align=center>

<h2 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h2><h3 id="知识框架-1"><a href="#知识框架-1" class="headerlink" title="知识框架"></a>知识框架</h3><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_13.jpg?raw=true" align=center>
### 长难公式
<img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_14.jpg?raw=true" align=center>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我校（NEU）数值分析考试历年来都是各种套路题目（然鹅我还是习惯性数学掉链子），多刷题就好，另外注意老师透露的任何信息，比如今年老师让我们<br>着重看一下MOOC上的课后题，结果真的考到了。</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><h3 id="全书知识框架（与NEU所用教材不完全一致，不够很具代表性）"><a href="#全书知识框架（与NEU所用教材不完全一致，不够很具代表性）" class="headerlink" title="全书知识框架（与NEU所用教材不完全一致，不够很具代表性）"></a>全书知识框架（与NEU所用教材不完全一致，不够很具代表性）</h3><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/mathanalysis/New%20Doc%202018-06-14_16.jpg?raw=true" align=center>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Github 使用经典问题：如何同步 fork 项目原仓库的更新</title>
    <url>/a.%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/History/200407-Github%20%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%20fork%20%E9%A1%B9%E7%9B%AE%E5%8E%9F%E4%BB%93%E5%BA%93%E7%9A%84%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>Github 我们经常会通过 fork 开源项目在自己的仓库中更新，然后提交 Pull Request (Merge Request) 为开源项目做贡献。</p>
<p>不过我们经常会遇到原仓库更新，重新 fork 显然是不优雅的，那我我们该怎么同步更新呢？</p>
<span id="more"></span>

<p><img src="pic1.jpg"></p>
<h1 id="如何在-Github-网页端同步更新？"><a href="#如何在-Github-网页端同步更新？" class="headerlink" title="如何在 Github 网页端同步更新？"></a>如何在 Github 网页端同步更新？</h1><ol>
<li>进入你自己的 fork 过来的仓库。</li>
<li>点击 “Pull requests” ，如何点击右侧绿色的 “New pull request”。</li>
<li>Github 首先会比较源仓库与你 fork 后的仓库，如果你没有做任何更改，则找不到要 PR 的内容。所以，我们需要点击 “switching the base”，会将我们的仓库作为基础版本，原仓库作为 head 版本，现在我们会看到我们的需要需要 “catch up” 的更新。</li>
<li>点击 “Create pull request”，起一个名字，然后点击 “Create pull request”。</li>
<li>点击 “Merge pull request”，然后点击 “Confirm merge”。</li>
<li>如果我们没提交什么新代码，merge 过程将自动完成。</li>
</ol>
<h1 id="如何通过本地命令行同步更新？"><a href="#如何通过本地命令行同步更新？" class="headerlink" title="如何通过本地命令行同步更新？"></a>如何通过本地命令行同步更新？</h1><ol>
<li>验证远程分支可以 fetch 或 push<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li>
<li>指明我们需要同步的仓库<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add upstream https://github.com/OriginalRepo/OriginalProject.git</span><br></pre></td></tr></table></figure></li>
<li>验证<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li>
<li>拉取更新的 branches 和 commits<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch upstream</span><br></pre></td></tr></table></figure></li>
<li>Checkout 本地分支<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure></li>
<li>合并<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge upstream/master</span><br></pre></td></tr></table></figure></li>
<li>提交<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Git</tag>
        <tag>版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之美 - 王争 - 极客时间</title>
    <url>/b.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/History/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E7%8E%8B%E4%BA%89-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>极客时间</tag>
        <tag>王争</tag>
      </tags>
  </entry>
  <entry>
    <title>使用InfluxDB和Telegraf为服务器搭建基础监控</title>
    <url>/a.%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/History/211231-%E4%BD%BF%E7%94%A8InfluxDB%E5%92%8CTelegraf%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<p>想要监控服务器性能我们自然需要采集其性能数据并存储，InfluxDB 搭配 Telegraf 是目前最主流的服务器监控方案之一<br>Telegraf 是一个插件驱动的服务端代理用于采集并发送服务器上软件系统性能 metrics。<br>InfluxDB 是一个知名的时序数据库，它和 Telegraf 都是 InfluxData 公司的产品。</p>
]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>监控</tag>
        <tag>运维</tag>
        <tag>服务器</tag>
        <tag>InfluxDB</tag>
        <tag>Telegraf</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装软件的几种方式</title>
    <url>/a.%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/History/220311-Linux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>Linux 提供了各种不同的软件包安装与管理方式，我们可以根据系统差异、实际情况以及使用需求选择不同的方式来安装。</p>
]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>环境</tag>
        <tag>包管理</tag>
        <tag>apt</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 C++ 的左值和右值</title>
    <url>/a.%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/History/220422-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-C-%E7%9A%84%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</url>
    <content><![CDATA[<p>C++ 的左值（lvalue）和右值（rvalue）的概念在 C++11 后变得越来越重要，作为一个不是很容易理解的概念，一旦我们搞清楚了他们的含义，将有助于我们进一步理解一些高级的 C++ 特性，例如 move/forward 的新语义及右值引用（rvalue references）。</p>
]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>左值引用</tag>
        <tag>右值引用</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 绑定程序到特定 CPU 上运行</title>
    <url>/a.%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/History/220506-Linux-%E7%BB%91%E5%AE%9A%E7%A8%8B%E5%BA%8F%E5%88%B0%E7%89%B9%E5%AE%9A-CPU-%E4%B8%8A%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<p>现在我们日程使用的手机、电脑、服务器使用的基本上都是多核 CPU，多核 CPU 允许我们并行地运行多个程序。我们的程序（进程/线程）跑在哪一个核心上是由操作系统内核来调度的，内核会将我们的程序调度到不同的核心上来运行，那有没有方法能让我们的程序一直在同一个 CPU 上运行呢？</p>
<p>答案当然是有的，Linux 提供了 CPU 亲和性（CPU affinity）的设置来允许我们控制程序使其在同一块 CPU 上完成。</p>
]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>技术研究</tag>
        <tag>调度</tag>
        <tag>CPU</tag>
      </tags>
  </entry>
  <entry>
    <title>多核处理器可以并行运行多个进程吗？</title>
    <url>/a.%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/History/220520-%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%B9%B6%E8%A1%8C%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CPU</tag>
        <tag>进程</tag>
        <tag>线程</tag>
        <tag>并行</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>初探数据库连接池</title>
    <url>/a.%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/History/%E5%88%9D%E6%8E%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<p>参考资料</p>
<ul>
<li><a href="https://blog.csdn.net/crankz/article/details/82874158">数据库连接池学习笔记（一）：原理介绍+常用连接池介绍</a></li>
<li><a href="https://blog.csdn.net/frightingforambition/article/details/25464129">java数据库连接池实现原理</a></li>
<li><a href="https://juejin.im/entry/58fb03220ce4630061233c98">高性能数据库连接池的内幕</a></li>
</ul>
<h1 id="为什么要使用连接池"><a href="#为什么要使用连接池" class="headerlink" title="为什么要使用连接池"></a>为什么要使用连接池</h1><p>数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。  一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的 性能低下。 数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：在一个“池”里放了好多半成品的数据库联接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。 连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。 </p>
<span id="more"></span>

<h1 id="传统的连接机制与数据库连接池的运行机制区别"><a href="#传统的连接机制与数据库连接池的运行机制区别" class="headerlink" title="传统的连接机制与数据库连接池的运行机制区别"></a>传统的连接机制与数据库连接池的运行机制区别</h1><h2 id="不使用连接池流程"><a href="#不使用连接池流程" class="headerlink" title="不使用连接池流程"></a>不使用连接池流程</h2><p>下面以访问MySQL为例，执行一个SQL命令，如果不使用连接池，需要经过哪些流程。<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g3116moxfaj30d40dgdgt.jpg" width="400px" /></p>
<ul>
<li><p>步骤</p>
<ol>
<li>TCP建立连接的三次握手（JDBC与MySQL的连接基于TCP协议）</li>
<li>MySQL认证的三次握手</li>
<li>真正的SQL执行</li>
<li>MySQL的关闭</li>
<li>TCP的四次握手关闭<br>可以看到，为了执行一条SQL，却多了非常多我们不关心的网络交互。</li>
</ol>
</li>
<li><p>优点</p>
<ul>
<li>实现简单</li>
</ul>
</li>
<li><p>缺点</p>
<ol>
<li>网络IO较多</li>
<li>数据库的负载较高</li>
<li>响应时间较长及QPS较低（每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准）</li>
<li>应用频繁的创建连接和关闭连接，导致临时对象较多，GC频繁</li>
<li>在关闭连接后，会出现大量TIME_WAIT的TCP状态（在2个MSL之后关闭，这个是TCP/IP的设计者规定的<a href="https://www.cnblogs.com/sunxucool/p/3449068.html">详情</a>）</li>
</ol>
</li>
</ul>
<h2 id="使用数据库连接池"><a href="#使用数据库连接池" class="headerlink" title="使用数据库连接池"></a>使用数据库连接池</h2><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g311fkf2cqj30f80fdtb5.jpg" width="400px" />

<ul>
<li><p>步骤</p>
<ul>
<li>第一次访问的时候，需要建立连接。 但是之后的访问，均会复用之前创建的连接，直接执行SQL语句。</li>
</ul>
</li>
<li><p>优点</p>
<ol>
<li>较少了网络开销</li>
<li>系统的性能会有一个实质的提升</li>
<li>没了麻烦的TIME_WAIT状态</li>
</ol>
</li>
</ul>
<h1 id="数据库连接池的工作原理"><a href="#数据库连接池的工作原理" class="headerlink" title="数据库连接池的工作原理"></a>数据库连接池的工作原理</h1><p>连接池的工作原理主要由三部分组成，分别为</p>
<ol>
<li>连接池的建立</li>
<li>连接池中连接的使用管理</li>
<li>连接池的关闭</li>
</ol>
<p>第一、连接池的建立。一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销。Java中提供了很多容器类可以方便的构建连接池，例如Vector、Stack等。</p>
<p>第二、连接池的管理。连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其管理策略是：<br>当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户。<br>当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务。<br>该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销。</p>
<p>第三、连接池的关闭。当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源，该过程正好与创建相反。</p>
<h1 id="连接池主要参数"><a href="#连接池主要参数" class="headerlink" title="连接池主要参数"></a>连接池主要参数</h1><p><strong>使用连接池时，要配置一下参数</strong></p>
<ol>
<li>最小连接数：是连接池一直保持的数据库连接,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费.</li>
<li>最大连接数：是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作</li>
<li>最大空闲时间</li>
<li>获取连接超时时间</li>
<li>超时重试连接次数</li>
</ol>
<h1 id="连接池需要注意的点"><a href="#连接池需要注意的点" class="headerlink" title="连接池需要注意的点"></a>连接池需要注意的点</h1><h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><p>为了使连接管理服务具有最大的通用性，必须考虑多线程环境，即并发问题。这个问题相对比较好解决，因为各个语言自身提供了对并发管理的支持像java,c#等等，使用synchronized(java)lock(C#)关键字即可确保线程是同步的。</p>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>我们知道，事务具有原子性，此时要求对数据库的操作符合“ALL-OR-NOTHING”原则,即对于一组SQL语句要么全做，要么全不做。<br>我们知道当2个线程共用一个连接Connection对象，而且各自都有自己的事务要处理时候，对于连接池是一个很头疼的问题，因为即使Connection类提供了相应的事务支持，可是我们仍然不能确定那个数据库操作是对应那个事务的，这是由于我们有２个线程都在进行事务操作而引起的。为此我们可以使用每一个事务独占一个连接来实现，虽然这种方法有点浪费连接池资源但是可以大大降低事务管理的复杂性。 </p>
<h2 id="连接池的分配与释放"><a href="#连接池的分配与释放" class="headerlink" title="连接池的分配与释放"></a>连接池的分配与释放</h2><p>连接池的分配与释放，对系统的性能有很大的影响。合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。<br>对于连接的管理可使用一个List。即把已经创建的连接都放入List中去统一管理。每当用户请求一个连接时，系统检查这个List中有没有可以分配的连接。如果有就把那个最合适的连接分配给他；如果没有就抛出一个异常给用户，List中连接是否可以被分配由一个线程来专门管理捎后我会介绍这个线程的具体实现。</p>
<h2 id="连接池的配置与维护"><a href="#连接池的配置与维护" class="headerlink" title="连接池的配置与维护"></a>连接池的配置与维护</h2><p>连接池中到底应该放置多少连接，才能使系统的性能最佳？系统可采取设置最小连接数（minConnection）和最大连接数（maxConnection）等参数来控制连接池中的连接。比方说，最小连接数是系统启动时连接池所创建的连接数。如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢。这样，可以在开发时，设置较小的最小连接数，开发起来会快，而在系统实际使用时设置较大的，因为这样对访问客户来说速度会快些。最大连接数是连接池中允许连接的最大数目，具体设置多少，要看系统的访问量，可通过软件需求上得到。 <br>如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量大于最小连接数，则补充相应数量的新连接,以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。</p>
<h1 id="数据库对比"><a href="#数据库对比" class="headerlink" title="数据库对比"></a>数据库对比</h1><h2 id="第一、二代连接池"><a href="#第一、二代连接池" class="headerlink" title="第一、二代连接池"></a>第一、二代连接池</h2><p>区分一个数据库连接池是属于第一代产品还是代二代产品有一个最重要的特征就是看它在架构和设计时采用的线程模型，因为这直接影响的是并发环境下存取数据库连接的性能。</p>
<p>一般来讲采用单线程同步的架构设计都属于第一代连接池，二采用多线程异步架构的则属于第二代。比较有代表性的就是Apache Commons DBCP，在1.x版本中，一直延续着单线程设计模式，到2.x才采用多线程模型。</p>
<p>二代产品对一代产品的超越是颠覆性的，除了一些“历史原因”，你很难再找到第二条理由说服自己不选择二代产品，但任何成功都不是偶然的，二代产品的成功很大程度上得益于前代产品们打下的基础，站在巨人的肩膀上，新一代的连接池的设计师们将这一项“工具化”的产品，推向了极致。其中，最具代表性的两款产品是：</p>
<ul>
<li>HikariCP</li>
<li>Druid</li>
</ul>
<p>下面更多介绍请参考<a href="https://blog.csdn.net/crankz/article/details/82874158">数据库连接池对比</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>时至今日，虽然每个应用（需要RDBMS的）都离不开连接池，但在实际使用的时候，连接池已经可以做到“<strong>隐形</strong>”了。也就是说在通常情况下，连接池完成项目初始化配置之后，就再不需要再做任何改动了。不论你是选择Druid或是HikariCP，甚至是DBCP，它们都足够稳定且高效！之前讨论了很多关于连接池的性能的问题，但这些性能上的差异，是相较于其他连接池而言的，对整个系统应用来说，第二代连接池在使用过程中体会到的差别是微乎其微的，基本上不存在因为连接池的自身的配饰和使用导致系统性能下降的情况，除非是在单点应用的数据库负载足够高的时候（压力测试的时候），但即便是如此，通用的优化的方式也是单点改集群，而不是在单点的连接池上死扣。</p>
]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>数据库</tag>
        <tag>连接池</tag>
        <tag>MySQL</tag>
        <tag>dbcp2</tag>
      </tags>
  </entry>
  <entry>
    <title>动手实现一个 Python 版本的 MysqlClient</title>
    <url>/a.%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/History/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%20Python%20%E7%89%88%E6%9C%AC%E7%9A%84%20MysqlClient/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在实际项目中我们会在项目的各个角落进行数据库访问操作，显然我们需要将对数据库的访问做一定的封装，在统一管理的基础上也可以做一些额外的优化。<br>所以我们打算实现一个叫做<code>MysqlClient</code>的类对数据库访问做统一管理，我们期待它的作用有：</p>
<ul>
<li>统一管理数据库访问凭证</li>
<li>对<code>query</code>和<code>execute</code>两类操作进行封装</li>
<li>预处理sql以防 SQL注入</li>
<li>引入数据库连接池</li>
<li>合适的错误检查与记录</li>
<li>以及如何正确使用</li>
</ul>
<p>在百度上随便一搜就能搜到类似的实现，不过他们大部分都是只实现了对<code>query</code>，<code>execute</code>的封装，少部分加上了预处理sql，我希望提供一个更完整的<code>MysqlClient</code>实现。</p>
<blockquote>
<p>我最初也是在百度上复制了一个封装了query、execute两个操作的MysqlClient，后来被公司安全部门提示有sql注入风险，所幸将平常遇到的对数据库访问对象的需求一次考虑清楚设计一个比较完善的实现。</p>
</blockquote>
<h1 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h1><blockquote>
<p>Python 3.7，遵循 PEP8 代码风格</p>
</blockquote>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@desc: MySQL client. Manage the access evidence, wrap the common action, improve the performance, keep the security.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"><span class="keyword">import</span> glog</span><br><span class="line"><span class="keyword">from</span> DBUtils.PooledDB <span class="keyword">import</span> PooledDB</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line"><span class="comment"># database configuration</span></span><br><span class="line">__DATABASE_HOST = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">__DATABASE_PORT = <span class="string">&quot;3306&quot;</span></span><br><span class="line">__DATABASE_USER = <span class="string">&quot;root&quot;</span></span><br><span class="line">__DATABASE_PASSWORD = <span class="string">&quot;password&quot;</span></span><br><span class="line">__DATABASE_NAME = <span class="string">&quot;demo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># database connection pool configuration</span></span><br><span class="line">__NUM_DEFAULT_CONNECTION = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mysql_connection_pool</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Database connection to the server using the connection pool.</span></span><br><span class="line"><span class="string">    :return: database connection</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    db_host = __DATABASE_HOST</span><br><span class="line">    db_port = __DATABASE_PORT</span><br><span class="line">    db_user = __DATABASE_USER</span><br><span class="line">    db_password = __DATABASE_PASSWORD</span><br><span class="line">    db_name = __DATABASE_NAME</span><br><span class="line"></span><br><span class="line">    num_connection = __NUM_DEFAULT_CONNECTION</span><br><span class="line"></span><br><span class="line">    connection_pool = PooledDB(MySQLdb, num_connection,</span><br><span class="line">                               host=db_host, port=db_port, user=db_user, passwd=db_password, db=db_name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> connection_pool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_session</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Used by ORM framework.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    db_host = __DATABASE_HOST</span><br><span class="line">    db_port = __DATABASE_PORT</span><br><span class="line">    db_user = __DATABASE_USER</span><br><span class="line">    db_password = __DATABASE_PASSWORD</span><br><span class="line">    db_name = __DATABASE_NAME</span><br><span class="line"></span><br><span class="line">    engine = create_engine(<span class="string">&#x27;mysql+mysqlconnector://&#x27;</span></span><br><span class="line">                           + db_user + <span class="string">&#x27;:&#x27;</span> + db_password + <span class="string">&#x27;@&#x27;</span> + db_host + <span class="string">&#x27;:&#x27;</span> + db_port + <span class="string">&#x27;/&#x27;</span> + db_name)</span><br><span class="line">    da_session = sessionmaker(bind=engine)</span><br><span class="line">    session = da_session()</span><br><span class="line">    <span class="keyword">return</span> session</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">watch_prepared_statement</span>(<span class="params">sql, params</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    When we use prepared sql statement, the program doesn&#x27;t the real sql neither in the python program or</span></span><br><span class="line"><span class="string">    database process. This function will parse the expected sql statement for debugging.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    expected_sql = sql % <span class="built_in">tuple</span>(params)</span><br><span class="line">    <span class="keyword">return</span> expected_sql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlClient</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Package actions about the database.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.connection_pool = get_mysql_connection_pool()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span>(<span class="params">self, sql, params=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Query action.</span></span><br><span class="line"><span class="string">        :param sql: being executed sql statement</span></span><br><span class="line"><span class="string">        :param params: sql param, to avoid the sql injection</span></span><br><span class="line"><span class="string">        :return: Query Result</span></span><br><span class="line"><span class="string">        :rtype: list</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        connection = self.connection_pool.connection()</span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> params <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            params = []</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cursor.execute(<span class="built_in">str</span>(sql), params)</span><br><span class="line">            result = cursor.fetchall()</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            expected_sql = watch_prepared_statement(sql, params)</span><br><span class="line">            glog.error(<span class="string">&quot;[&quot;</span> + <span class="built_in">str</span>(e) + <span class="string">&quot;]&quot;</span> + expected_sql)</span><br><span class="line">            result = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># release the connection to the pooled</span></span><br><span class="line">            cursor.close()</span><br><span class="line">            connection.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, sql, params=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Update action.</span></span><br><span class="line"><span class="string">        :param sql: being executed sql statement</span></span><br><span class="line"><span class="string">        :param params: sql param, to avoid the sql injection</span></span><br><span class="line"><span class="string">        :return: affected rows count and the last row id</span></span><br><span class="line"><span class="string">        :rtype: tuple</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        connection = self.connection_pool.connection()</span><br><span class="line">        cursor = connection.cursor()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> params <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            params = []</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cursor.execute(<span class="built_in">str</span>(sql), params)</span><br><span class="line">            row_count = cursor.rowcount</span><br><span class="line">            row_id = cursor.lastrowid</span><br><span class="line">            connection.commit()</span><br><span class="line">            result = row_count, row_id</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            expected_sql = watch_prepared_statement(sql, params)</span><br><span class="line">            glog.error(<span class="string">&quot;[&quot;</span> + <span class="built_in">str</span>(e) + <span class="string">&quot;]&quot;</span> + expected_sql)</span><br><span class="line">            result = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># release the connection to the pooled</span></span><br><span class="line">            cursor.close()</span><br><span class="line">            connection.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_connection</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Other actions. Return the connection to finish other operations, such as executemany and so on.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.connection_pool.connection()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__mysql_client = MysqlClient()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mysql_client</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Initialize the singleton object.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> __mysql_client</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>外部访问时通过调用<code>get_mysql_client()</code>函数来获得单例的 MysqlClient。</p>
<blockquote>
<p>实现单例模式最简单的方法：在模块内定义变量，模块被import时被初始化</p>
</blockquote>
</li>
<li><p><code>watch_prepared_statement()</code>函数用于观察预处理后的sql语句</p>
<blockquote>
<p>通俗地说，预处理就是把 <strong>%</strong> 变为 <strong>,</strong></p>
</blockquote>
</li>
<li><p><code>get_session()</code>是相对独立的一部分，在使用如 SQLAlchemy 这样的ORM框架时会用到。</p>
</li>
<li><p>提供了<code>get_connection()</code>用于完成不常用的数据库操作，当然如果在项目层面常用也可以增加额外的封装方法。</p>
</li>
<li><p>数据库连接池部分还可以对cache，连接数做额外的配置，这个可以根据项目实际需求做改动。</p>
</li>
<li><p>对配置信息部分，还可以引入<code>ConfigParser</code>对其进行统一管理在配置文件。 </p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库连接池</tag>
        <tag>代码风格</tag>
        <tag>安全</tag>
        <tag>SQL注入</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>常用字符编码整理</title>
    <url>/a.%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/History/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这两天在预习人工智能课要用的的python语言，循着廖雪峰老师的博客在学习。<br>发现教程里再次提到了关于各种编码的事情，我想有必要单独写一篇文章也算是一种总结。</p>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。</p>
<span id="more"></span>   
<h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>American Standard Code for Information Interchange，美国信息交换标准代码<br>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。<br>最后一次更新是在1986年，至今为止共定义了128个子元。主要用于显示英语。</p>
<h2 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h2><p>ANSI编码是一种对ASCII码的拓展：ANSI编码用0x00<del>0x7f 范围的1 个字节来表示 1 个英文字符，超出一个字节的 0x80</del>0xFFFF 范围来表示其他语言的其他字符。也就是说，ANSI码仅在前126个与ASCII码相同，之后的字符全是某个国家语言的所有字符。值得注意的是，两个字节最多可以存储的字符数目是2的16次方，即65536个字符，这对于一个语言的字符来说，绝对够了。还有ANSI编码其实包括很多编码：中国制定了GB2312编码，用来把中文编进去另外，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准。受制于当时的条件，不同语言之间的ANSI码之间不能互相转换，这就会导致在多语言混合的文本中会有乱码。  </p>
<blockquote>
<p>其实ANSI并不是某一种特定的字符编码，而是在不同的系统中，ANSI表示不同的编码。（也可以说是ANSI包含许多种编码，都是对ASCII的扩展）你的美国同事Bob的系统中ANSI编码其实是ASCII编码（ASCII编码不能表示汉字，所以汉字为乱码），而你的系统中（“汉字”正常显示）ANSI编码其实是GBK编码，而韩文系统中（“한국어”正常显示）ANSI编码其实是EUC-KR编码。  </p>
<p>话说计算机是由美国佬搞出来的嘛，他们觉得一个字节（可以表示256个编码）表示英语世界里所有的字母、数字和常用特殊符号已经绰绰有余了（其实ASCII只用了前127个编码）。后来欧洲人不干了，法国人说：我需要在小写字母加上变音符号（如：é），德国人说：我也要加几个字母（Ä ä、Ö ö、Ü ü、ß）。于是，欧洲人就将ASCII没用完的编码（128-255）为自己特有的符号编码（后来称之为“扩展字符集”）。等到我们中国人开始使用计算机的时候，尼玛，256个编码哪够？我泱泱大中华，汉字起码也得N多万吧，就连小学生都得要求掌握两三千字。国标局最后拍板：一个字节不够，那我们就用多个字节来为汉字编码吧，但是，国情那么穷，字节那么贵，三个字节伤不起，那就用俩字节吧，先给常用的几千汉字编个码，等以后国家强盛了人民富裕了，咱再扩展呗—于是GB2312就产生了。台湾同胞一看，尼玛，全是简体字，还让不让我们写繁体字的活了，于是台湾同胞也自己弄了个繁体字编码—大五码（Big-5）。同时，其它国家也在为自己的文字编码。最后，微软苦逼了：顾客就是上帝啊，你们的编码我都得满足啊，这样吧，卖给美国国内的系统默认就用ASCII编码吧，卖给中国人的系统默认就用GBK编码吧，卖给韩国人的系统默认就用EUC-KR编码，…但是为了避免你们误会我卖给你们的系统功能有差异，我就统一把你们的默认编码都显示成ANSI吧。—本故事纯属虚构，但“ANSI编码”确实只存在于Windows系统。</p>
</blockquote>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>为了解决不同国家ANSI编码的冲突问题，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。<br>Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。<br>但是问题在于，原本可以用一个字节存储的英文字母在Unicode里面必须存两个字节（规则就是在原来英文字母对应ASCII码前面补0），这就产生了浪费。那么有没有一种既能消除乱码，又能避免浪费的编码方式呢？答案就是UTF-8！ </p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：<br>UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p>
<blockquote>
<p>这是一种变长的编码方式：它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，如此一来UTF-8编码也可以是为视为一种对ASCII码的拓展。值得注意的是unicode编码中一个中文字符占2个字节，而UTF-8一个中文字符占3个字节。从unicode到uft-8并不是直接的对应，而是要过一些算法和规则来转换。   </p>
</blockquote>
<p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。<br>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001387245992536e2ba28125cf04f5c8985dbc94a02245e000/0"><br>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：<br><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001387245979827634fd6204f9346a1ae6358d9ed051666000/0"><br>所以你看到很多网页的源码上会有类似<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的UTF-8编码。</p>
<h2 id="变长解码与UTF-16"><a href="#变长解码与UTF-16" class="headerlink" title="变长解码与UTF-16"></a>变长解码与UTF-16</h2><p>我们可能会想到，UTF-8这种不定数目字节表示一个字符的编码方式如何去解码呢。<br>实际上，UTF-8编码的每个编码开头会有一些符号位用来表示当前是以几个字节表示一个字符的。这就导致UTF-8要花费额外的比特。  </p>
<blockquote>
<p>UTF-16比较好理解,就是任何字符对应的数字都用两个字节来保存.我们通常对Unicode的误解就是把Unicode与UTF-16等同了.但是很显然如果都是英文字母这做有点浪费.明明用一个字节能表示一个字符为啥整两个啊.<br>于是又有个UTF-8,这里的8非常容易误导人,8不是指一个字节,难道一个字节表示一个字符?实际上不是.当用UTF-8时表示一个字符是可变的,有可能是用一个字节表示一个字符,也可能是两个,三个..反正是根据字符对应的数字大小来确定.<br>于是UTF-8和UTF-16的优劣很容易就看出来了.如果全部英文或英文与其他文字混合,但英文占绝大部分,用UTF-8就比UTF-16节省了很多空间.而如果全部是中文这样类似的字符或者混合字符中中文占绝大多数.UTF-16就占优势了,可以节省很多空间.另外还有个容错问题.</p>
<h3 id="用UTF-16表示”汉”"><a href="#用UTF-16表示”汉”" class="headerlink" title="用UTF-16表示”汉”"></a>用UTF-16表示”汉”</h3><p>假如用UTF-16表示的话就是01101100   01001001(共16 bit,两个字节).程序解析的时候知道是UTF-16就把两个字节当成一个单元来解析.这个很简单.</p>
<h3 id="用UTF-8表示”汉”"><a href="#用UTF-8表示”汉”" class="headerlink" title="用UTF-8表示”汉”"></a>用UTF-8表示”汉”</h3><p>用UTF-8就有复杂点.因为此时程序是把一个字节一个字节的来读取,然后再根据字节中开头的bit标志来识别是该把1个还是两个或三个字节做为一个单元来处理.<br>0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.就跟ASCII完全一样.<br>110xxxxx 10xxxxxx.如果是这样的格式,则把两个字节当一个单元<br>1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元.<br>这是约定的规则.你用UTF-8来表示时必须遵守这样的规则.我们知道UTF-16不需要用啥字符来做标志,所以两字节也就是2的16次能表示65536个字符.<br>而UTF-8由于里面有额外的标志信息,所有一个字节只能表示2的7次方128个字符,两个字节只能表示2的11次方2048个字符.而三个字节能表示2的16次方,65536个字符.</p>
</blockquote>
<p>由上面我们可以看出UTF-8在局部的字节错误（丢失、增加、改变）不会导致连锁性的错误，因为 UTF-8 的字符边界很容易检测出来，所以容错性较高。</p>
<h2 id="编码选择"><a href="#编码选择" class="headerlink" title="编码选择"></a>编码选择</h2><p>因为无论是 UTF-8 和 UTF-16/32 都各有优缺点，因此选择的时候应当立足于实际的应用场景。例如在我的习惯中，存储在磁盘上或进行网络交换时都会采用 UTF-8，而在程序内部进行处理时则转换为 UTF-16/32。对于大多数简单的程序来说，这样做既可以保证信息交换时容易实现相互兼容，同时在内部处理时会比较简单，性能也还算不错。</p>
<blockquote>
<p>（基本上只要你的程序不是 I/O 密集型的都可以这么干，当然这只是我粗浅的认识范围内的经验，很可能会被无情的反驳）</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/malecrab/p/5300486.html">ANSI是什么编码？</a><br><a href="https://blog.csdn.net/xiangxianghehe/article/details/77574965">字符编码ANSI和ASCII区别、Unicode和UTF-8区别</a><br><a href="https://www.cnblogs.com/fnlingnzb-learner/p/6163205.html">Unicode(UTF-8, UTF-16)令人混淆的概念</a></p>
]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>编码</tag>
        <tag>UTF-8</tag>
        <tag>GBK</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写好技术博客？</title>
    <url>/e.%E8%A7%82%E5%AF%9F%E6%80%9D%E8%80%83/History/220415-%E5%A6%82%E4%BD%95%E5%9D%9A%E6%8C%81%E5%86%99%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%EF%BC%9F/</url>
    <content><![CDATA[<p>写技术博客是大部分程序员都很想坚持却又总是断断续续的一件事。大家愿意写技术博客是因为有很多好处，例如写博客有助于整理平常的思考、梳理一个复杂难懂的技术细节；同时也可以满足分享与传播的欲望，幸运的话还能提升自己的 impact。</p>
]]></content>
      <categories>
        <category>观察思考</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>博客</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>通用的产品与运营思维</title>
    <url>/e.%E8%A7%82%E5%AF%9F%E6%80%9D%E8%80%83/History/%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%A7%E5%93%81%E4%B8%8E%E8%BF%90%E8%90%A5%E6%80%9D%E7%BB%B4/</url>
    <content><![CDATA[<p>现代互联网企业尤其是国内互联网企业除了开发外还有 产品 和 运营 两个所谓的“文职岗位”，即开放给不想写代码的计算机专业学生和想转互联网行业的其他专业学生的岗位。<br>不过我认为产品和运营两个领域的能力对于像我这样技术一般般的同学来说还是很重要的，用产品思维去设计软件或服务，哪怕是一个对外的 API 接口；用运营能力去在合适的位置推广软件或服务，获得持续的反馈。</p>
]]></content>
      <categories>
        <category>观察思考</category>
      </categories>
      <tags>
        <tag>方法论</tag>
        <tag>运营</tag>
        <tag>产品</tag>
        <tag>管理</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工具收藏</title>
    <url>/f.%E6%94%B6%E8%97%8F%E6%95%B4%E7%90%86/History/200720-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E6%94%B6%E8%97%8F/</url>
    <content><![CDATA[<blockquote>
<p>之前做过一些前端开发工作，收藏了一些不错的框架和工具，对于内部平台/性能要求不高的展示页面，使用现成的框架删删改改是足够的。<br>尤其是在一个研发大佬云集的项目组/实验室，会一点前端技能会带给你意想不到的收获。（别误会，大佬们只是不想浪费时间在这种杂活上hh）</p>
</blockquote>
<span id="more"></span>
<h2 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h2><ul>
<li><a href="https://cn.vuejs.org/">Vue.js</a><ul>
<li>最容易上手</li>
</ul>
</li>
<li><a href="https://react.docschina.org/">React</a> <ul>
<li>Facebook出品</li>
</ul>
</li>
<li><a href="https://angular.cn/">Angular</a><ul>
<li>Google出品</li>
</ul>
</li>
</ul>
<h2 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h2><ul>
<li><a href="https://ant.design/index-cn">Ant Design React</a>, <a href="https://www.antdv.com/docs/vue/introduce-cn/">Ant Design Vue</a><ul>
<li>蚂蚁金服出品，一直在推陈出新，设计，视觉都非常优秀！</li>
</ul>
</li>
<li><a href="https://element.eleme.io/#/">Element UI</a><ul>
<li>饿了么出品（基于Vue，非常成熟，非常稳定，但是一直不更新视觉上不fashion了）</li>
</ul>
</li>
<li><a href="https://www.bootcss.com/">Bootstrap</a><ul>
<li>Twitter出品（基于jQuery，曾经的入门框架，现在用得少）</li>
</ul>
</li>
<li><a href="https://material.io/design/">Material Design</a>, <a href="https://vuematerial.io/">Vue Material</a><ul>
<li>Google出品，Google网站的风格</li>
</ul>
</li>
</ul>
<h2 id="开箱即用的中后台前端解决方案"><a href="#开箱即用的中后台前端解决方案" class="headerlink" title="开箱即用的中后台前端解决方案"></a>开箱即用的中后台前端解决方案</h2><blockquote>
<p>上手容易，推荐使用</p>
</blockquote>
<ul>
<li><a href="https://panjiachen.github.io/vue-element-admin-site/zh/">vue-element-admin</a><ul>
<li>原net_platform_fe项目使用的框架，非常成熟</li>
</ul>
</li>
<li><a href="https://pro.ant.design/index-cn">Ant Design Pro</a><ul>
<li>好看，Antd官方团队出品，企业级中后台前端/设计解决方案</li>
</ul>
</li>
</ul>
<h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><ul>
<li><a href="https://github.com/weilanwl/ColorUI">ColorUI</a><ul>
<li>鲜亮的高饱和色彩，专注视觉的小程序组件库。</li>
</ul>
</li>
<li><a href="https://github.com/youzan/vant-weapp">Vant</a><ul>
<li>最成熟的小程序 UI 组件库。</li>
</ul>
</li>
</ul>
<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><h3 id="图标资源"><a href="#图标资源" class="headerlink" title="图标资源"></a>图标资源</h3><ul>
<li><a href="https://www.iconfont.cn/">Iconfont</a><ul>
<li>阿里巴巴出品，国内最流行！</li>
</ul>
</li>
<li><a href="https://fontawesome.com/v4.7.0/icons/">Font Awesome Icons</a><ul>
<li>经典系列~</li>
</ul>
</li>
<li><a href="https://www.flaticon.com/">flaticon</a><ul>
<li>彩色矢量图~</li>
</ul>
</li>
</ul>
<h3 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h3><ul>
<li><a href="https://undraw.co/illustrations">unDraw</a><ul>
<li>2.5D插画风格</li>
</ul>
</li>
</ul>
<h3 id="绘图工具"><a href="#绘图工具" class="headerlink" title="绘图工具"></a>绘图工具</h3><ul>
<li><a href="https://echarts.apache.org/zh/index.html">ECharts</a><ul>
<li>百度出品，全球最主流</li>
</ul>
</li>
<li><a href="https://chartjs.bootcss.com/">Chart.js</a><ul>
<li>更简单</li>
</ul>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><a href="https://docschina.org/">印记中文</a><ul>
<li>前端文档库</li>
</ul>
</li>
<li><a href="https://landing.ant.design/index-cn">Antd Landing</a><ul>
<li>无需代码为项目创建一个专属首页</li>
</ul>
</li>
<li><a href="https://coverr.co/">coverr</a><ul>
<li>为前端界面使用视频作为背景图</li>
</ul>
</li>
<li><a href="https://www.sketch.com/">Sketch</a><ul>
<li>轻量级的矢量图片处理工具（轻量级的Photoshop）</li>
</ul>
</li>
<li><a href="https://hoppscotch.io/">hoppscotch</a><ul>
<li>前 Postwoman，免费快速的 Web 端 API 请求构造器</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>收藏整理</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>前端</tag>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title>东南大学止于至善学术风 PPT 模板（中文）</title>
    <url>/f.%E6%94%B6%E8%97%8F%E6%95%B4%E7%90%86/History/%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%AD%A2%E4%BA%8E%E8%87%B3%E5%96%84%E5%AD%A6%E6%9C%AF%E9%A3%8E-PPT-%E6%A8%A1%E6%9D%BF%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>收藏整理</category>
      </categories>
      <tags>
        <tag>PPT</tag>
        <tag>模板</tag>
        <tag>东南大学</tag>
      </tags>
  </entry>
  <entry>
    <title>东南大学止于至善学术风 PPT 模板（英文）</title>
    <url>/f.%E6%94%B6%E8%97%8F%E6%95%B4%E7%90%86/History/%E4%B8%9C%E5%8D%97%E5%A4%A7%E5%AD%A6%E6%AD%A2%E4%BA%8E%E8%87%B3%E5%96%84%E5%AD%A6%E6%9C%AF%E9%A3%8E-PPT-%E6%A8%A1%E6%9D%BF%EF%BC%88%E8%8B%B1%E6%96%87%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>收藏整理</category>
      </categories>
      <tags>
        <tag>PPT</tag>
        <tag>模板</tag>
        <tag>东南大学</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式开发常用通信协议</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/210528-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>在嵌入式系统中，板上通信接口是指用于将各种集成电路与其他外围设备交互连接的通信通路或总线。<br>以下内容为常用板上通信接口：包括 I2C、SPI、UART、1-Wire。</p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title>科学上网原理</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/210611-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>科学上网本质上是对从本机到目的服务器间的网络通信方式进行加密，使流量不能被防火墙检测到，进而绕开访问限制。</p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>ssh</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言中，取余和取模的区别是什么？</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/211210-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%EF%BC%8C%E5%8F%96%E4%BD%99%E5%92%8C%E5%8F%96%E6%A8%A1%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>最近在复习C++的知识，观察到了在某些情况下，即便程序没有按预期执行出现了较大偏差，但也不会报错，会变成一个奇怪的很大的值，这其实是C++对超出变量取值范围的值的处理，即对其取余。  </p>
<p>取模倒是很常见，那取余又是什么呢？</p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>取模</tag>
        <tag>取余</tag>
      </tags>
  </entry>
  <entry>
    <title>修改motd，使用字符画生成工具，配置一个实用有趣的服务器登录脚本</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/211224-%E4%BF%AE%E6%94%B9motd%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E7%94%BB%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%EF%BC%8C%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%94%A8%E6%9C%89%E8%B6%A3%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%99%BB%E5%BD%95%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>使用终端登录远程服务器时会有欢迎信息，那如何对这个欢迎信息进行修改并做一定的个性化呢？一起来看看吧。</p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>服务器</tag>
        <tag>Linux</tag>
        <tag>motd</tag>
      </tags>
  </entry>
  <entry>
    <title>程序调试必须使用调试工具吗？</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/220107-%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<p>一直以来，我都更习惯于通过直接 print 内容来调试，只有在 print 无法满足需求或过于繁琐的时候才会不情不愿地去用 gdb 或 IDE 提供的调试工具来打断点等等。。。</p>
<p>之所以我会这样我想主要有两个因素，一是我一直没有认真学习过 gdb 工具的使用，二是很多场景直接 print 很方便，不需要太动脑思考断点位置等等。</p>
<p>实际上，程序调试也并非必须用调试工具，针对不同场景选择合适的方法我认为是最合理的。下面摘录几位知乎答主在问题 输出语句，例如print，cout ，是最好的调试方法吗? - 知乎 下的回答作为参考。</p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>调试</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Ctrl-C，Ctrl-Z，Ctrl-D 的区别</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/220204-Ctrl-C%EF%BC%8CCtrl-Z%EF%BC%8CCtrl-D-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
        <tag>信号量</tag>
      </tags>
  </entry>
  <entry>
    <title>浅试一下 pytest</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/220211-%E6%B5%85%E8%AF%95%E4%B8%80%E4%B8%8B%20pytest/</url>
    <content><![CDATA[<p>Python 自带的默认测试框架是 unittest，但是目前更主流被使用的第三方单元测试框架是 pytest，它提供了更易使用的测试接口，可以很好地与各种第三方自动化流程工具配套使用。</p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>单元测试</tag>
        <tag>pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC 中 gcc 和 g++ 的区别</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/220304-GCC-%E4%B8%AD-gcc-%E5%92%8C-g-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>之前写的 C++ 大部分都是来自在 LeetCode 上的算法题，很久没亲自动手编译 C++ 程序，今天写了一段 C++ 想编译一下，习惯性地使用了gcc，其中用到了vector，但是编译器报了错。</p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编译</tag>
        <tag>gcc</tag>
        <tag>g++</tag>
      </tags>
  </entry>
  <entry>
    <title>Git commit message 规范</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/220318-Git-commit-message-%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>Git commit 的 message 是 git 提交关键的描述信息，很多人出于习惯或是想尽快 git push 然后合上电脑休息往往忽略了 message 的重要性，一份好的 message 可以展现出你良好的开发习惯。</p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>风格</tag>
        <tag>规范化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 性能分析入门 —— cProfile与可视化</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/220325-Python-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8-%E2%80%94%E2%80%94-cProfile%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p>最近在使用 Python 的 matplotlib 绘图库来进行三维空间地图的可视化，但是发现实际绘制速度特别慢，画图大概需要 90s 左右。之前有听说 matplotlib 因为绘图质量很高达到了出版级别所以速度上不是很快，但是直觉告诉我，也该也不至于这么慢……，猜测是在代码逻辑上应该有提升空间。</p>
<p>最开始想着简单打印一下程序时间，自己计算看看在哪里耗时比较长，但是感觉不太优雅，于是去搜寻有没有很好用的性能分析工具。</p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>cProfile</tag>
        <tag>性能分析</tag>
        <tag>matplotlib</tag>
        <tag>SnakeViz</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Docker 容器搭建 Docker 服务监控</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/220401-%E4%BD%BF%E7%94%A8-docker-%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA-docker-%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<ul>
<li>在之前的文章<a href="https://raven.feishu.cn/docs/doccnT7U46wPIOuHxf7vHI4Nspz">使用InfluxDB和Telegraf为服务器搭建基础监控</a>中介绍过使用 InfluxDB 和 Telegraf 技术栈来为服务器搭建基本监控，其中，InfluxDB 和 Telegraf 都是运行在 Docker 容器中的，通过共享容器网络进行通信。</li>
<li>在这篇文章中，将要介绍如何使用 docker 容器为 docker 本身进行监控。</li>
</ul>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>监控</tag>
        <tag>InfluxDB</tag>
        <tag>Telegraf</tag>
      </tags>
  </entry>
  <entry>
    <title>记忆化搜索到底是不是动态规划？</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/220408-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9F/</url>
    <content><![CDATA[<p>有一个问题一直困扰着我，就是使用备忘录进行记忆化搜索的方式到底算不算动态规划？有此疑惑是因为我常常发现，在 LeetCode 上使用记忆化搜索求解往往效率很差，时间复杂度排在后 20%，而使用 DP table 进行递推的效率则好很多；以及看到很多题解中将动态规划与记忆化搜索（备忘录）并列介绍。</p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内核空间和用户空间</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/220513-Linux-%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>Linux 为了提高操作系统的稳定性和可用性将内存地址空间划分为内核空间（kernel space）和用户空间（user space），本文以 32 位系统为例介绍 Linux 系统的内核空间和用户空间。</p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>操作系统</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+github pages搭建个人博客</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/Hexo+github%20pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><strong>尊重原创，请先阅读这一篇教程：</strong><a href="http://www.cnblogs.com/dantefung/p/d8c48ba8030bcab7cfc364d423186fee.html" title="尊重原创">Hexo+github搭建个人博客</a></p>
<p>本文的目的：上面链接的教程已经足够详细，作者按照此教程已成功搭建blog。另，此教程相比其他教程更简洁，避免了本地关联github repository key value的步骤。</p>
<p>但上述教程写作时间稍早，GitHub有一些更新，本文对更新部分进行补充并附加了一个作者在配置时遇到的bug</p>
<span id="more"></span>
<h2 id="针对最新版GitHub网页的补充"><a href="#针对最新版GitHub网页的补充" class="headerlink" title="针对最新版GitHub网页的补充"></a>针对最新版GitHub网页的补充</h2><h3 id="git地址不在"><a href="#git地址不在" class="headerlink" title="git地址不在"></a>git地址不在</h3><p><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/current.png?raw=true" alt="原文让我们复制的git地址"></p>
<p>现在的GitHub不在repository主页显示git地址</p>
<p><img src="http://img.blog.csdn.net/20180203000843921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzc2ODcxNzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="现在的"></p>
<p>所以原文让我们复制的地址就是repository的地址加上.git</p>
<p>例如<a href="https://github.com/Raven98/Raven98.github.io.git">https://github.com/Raven98/Raven98.github.io.git</a></p>
<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><h3 id="No-1"><a href="#No-1" class="headerlink" title="No.1"></a>No.1</h3><p>原文让我们修改_config.yml文件的内容</p>
<p><img src="https://github.com/Raven98/Raven98.github.io/blob/master/uploads/config.png?raw=true" alt="修改_config.yml"><br><strong>注意！！这里都是有空格的！！！</strong>改了好久才发现！气死！</p>
<p><img src="http://img.blog.csdn.net/20180203001242638?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzc2ODcxNzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="有空格这里"></p>
<p><em>吐槽：感觉编程界常常因为空格给人带来困扰啊！！！</em></p>
<h3 id="No-2"><a href="#No-2" class="headerlink" title="No.2"></a>No.2</h3><p>刚刚更改了样式部署到github上后发现~~怎么就404了？？<br>我是因为本地没有CNAME文件，导致部署后github认为我删除了CNAME文件从而删除了远程库里的CNAME文件。</p>
<p>暂时解决方法：github pages设置里的domain设置成跳转的域名</p>
<p>永久解决办法：在本地source文件夹里新建CNAME文件，写上你的域名即可</p>
<p>同理，每次更新后README.md文件都会消失也是同理</p>
<p>有其他问题可以留言一起讨论哦！</p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo处理{{}}报错</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/Hexo%E5%A4%84%E7%90%86%7B%7B%7D%7D%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>今天在更新博客时有关于Vue动态绑定的内容，动态绑定<code>v-model</code>属性是配合双括号<code>这里报错</code>来实现的</p>
<img src="http://ww1.sinaimg.cn/large/006tNc79ly1g37z4w7r1cj30vk01gjrr.jpg" />   

<p>但是如果像上面图片里写这句话是会报错的呦，节选报错信息开头部分如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Template render error: (unknown path) [Line 1, Column 64]</span><br><span class="line">  unexpected token: &#125;&#125;</span><br><span class="line">    at Object._prettifyError (/Users/raven/workspace/blog/node_modules/nunjucks/src/lib.js:36:11)</span><br><span class="line">    at Template.render (/Users/raven/workspace/blog/node_modules/nunjucks/src/environment.js:524:21)</span><br></pre></td></tr></table></figure>

<p>在一点点试错后发现正是两对紧密相连的<code>&#123;&#125;</code>使其报错，猜测应该是这种写法恰好和hexo内部的解析器有冲突吧</p>
<p>在双括号内加入一些文字即不报错<code>&#123;&#123;message&#125;&#125;</code>，但是无法正常显示哦，就比如这一行的那个代码块，里面的message就没显示  </p>
<img src="http://ww3.sinaimg.cn/large/006tNc79ly1g37zgjx4g2j312y00ydgb.jpg" />   

<p><em>注意：在双括号内加入空格还是会报错哦</em>  </p>
<p>目测应该还会有其他写法使hexo的转义发生错误，有时间看一下hexo源码找到错误位置再更新一下本文</p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java后端开发的点点滴滴</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/Java%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近做了一些服务器上运行Java程序提供接口的工作，在相关工作进行时搜集到了一些服务器搭建的插件问题，整理如下：</p>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><ol>
<li><a href="https://blog.csdn.net/u011630097/article/details/51897718">java打包jar后，使之一直在linux上运行，不随终端退出而关闭</a>  <blockquote>
<p>把java程序打成jar包后，放到linux上通过putty或其它终端执行的时候，如果按照：java -jar xxxx.jar执行，当我们退出putty或终端的时候，xxxx.jar这个程序也会停止。<br> 为了保证程序能够一直运行，应该改为这样运行：nohup java -jar xxx.jar&amp;命令，则程序会在后台一直运行。<br> 值得注意的是，此时程序控制台输出会被转移到nohup.out文件中，<br> 这个nohup.out文件的位置就在jar包的当前文件夹内。</p>
</blockquote>
</li>
<li><a href="https://www.cnblogs.com/CEO-H/p/7794306.html">Linux查看端口占用情况</a><blockquote>
<p>lsof -i 用以显示符合条件的进程情况<br> lsof -i:端口号，用于查看某一端口的占用情况，比如查看22号端口使用情况，lsof -i:22<br> netstat -tunlp用于显示tcp，udp的端口和进程等相关情况<br> netstat -tunlp|grep 端口号，用于查看指定端口号的进程情况，如查看22端口的情况，netstat -tunlp|grep 22  </p>
</blockquote>
</li>
</ol>
<p>通常情况下，我们还会用到<code>kill</code>命令，<code>kill + PID</code>即可杀死对应进程。</p>
<ol start="3">
<li><a href="https://zhidao.baidu.com/question/564483452.html">Linux打开名字里带括号的文件</a>  <blockquote>
<p>括号要用转义<code>\(xxx\)</code>,有空格什么的同理</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL简单优化</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/MySQL%20varchar%E9%95%BF%E5%BA%A6%E6%8E%A2%E6%9E%90/</url>
    <content><![CDATA[<p>记录一下一些简单的在设计表结构方面对MySQL的简单优化。</p>
<ul>
<li><a href="https://www.cnblogs.com/duanxz/p/3724120.html">MySQL中的两种临时表</a></li>
<li><a href="https://www.jianshu.com/p/7fe85454a4f4">varchar类型的长度怎么确定？有什么样的原则，和Text和LongText的区别是什么？</a></li>
<li><a href="https://blog.csdn.net/github_26672553/article/details/82942313">mysql中int(1)中int后面的数字（简单介绍）</a></li>
<li><a href="http://www.zhimengzhe.com/shujuku/MySQL/83409.html">mysql int(11)字段左边自动补零了</a></li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g3c79vgsn0j30cm0b8my0.jpg"></p>
<p>如上图，int所谓的长度不是他真的长度，设置为int就占4个字节，设置为tinyint就占一个字节</p>
<ul>
<li><p><a href="https://www.cnblogs.com/lhj588/p/4245719.html">Mysql 如何设置字段自动获取当前时间</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/xiaozhang2014/p/7750562.html">前后端分离，如何防止接口被其他人调用或恶意重发</a></p>
</li>
</ul>
<h2 id="常量表设计"><a href="#常量表设计" class="headerlink" title="常量表设计"></a>常量表设计</h2><p>对于一些明显有类型的字符串数据，有两种技术方案</p>
<ul>
<li>对于需要做到下拉列表里的数据，存储到常量表里</li>
<li>对于每次都随实体出现的，直接以字符串存到表里，即便用数字id更节省空间，但是我们更注重效率，减少连表查询次数，提高性能。</li>
</ul>
<h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><p><a href="https://www.jianshu.com/p/41e134657902">谈谈ali与Google的Java开发规范</a></p>
<p><a href="https://www.cnblogs.com/xiaozhang2014/p/7750562.html">前后端分离，如何防止接口被其他人调用或恶意重发</a></p>
<p><a href="https://blog.csdn.net/u011870547/article/details/81077153">PO,BO,VO和POJO的区别</a></p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是模型？</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9E%8B%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="什么是模型？"><a href="#什么是模型？" class="headerlink" title="什么是模型？"></a>什么是模型？</h1><p>最近在上人工智能课程，总看到模型model一词。加之一月份又要参加2019年的数学建模美赛，所以对「模型」这个概念感到很好奇。和『大佬』这些词一样，都是上大学后才了解到的。<br>关于模型，摘抄原文如下：</p>
<blockquote>
<p>A model can come in many shapes, sizes, and styles. It is important to emphasize that a model is not the real world but merely a human construct to help us better understand real world systems. In general all models have an information input, an information processor, and an output of expected results. Modeling Methodology for Physics Teachers (more info) (1998) provides an outline of generic model structure that is useful for geoscience instruction. In “Modeling the Environment” Andrew Ford gives a philosophical discussion of what models are and why they are useful. The first few paragraphs of Chapter 1 of Ford’s book are worth a look.<br>Key features in common with the development of any model is that:  </p>
<ul>
<li>simplifying assumptions must be made;</li>
<li>boundary conditions or initial conditions must be identified;</li>
<li>the range of applicability of the model should be understood.</li>
</ul>
</blockquote>
<p>概括地来说，模型首先不局限于形式，有很多表达方式。它用来抽象现实世界的某一个方面。<br>模型有输入，处理机制和输出。我们要优化我们的处理机制以便让由输入得到的输出符合我们的期待。<br>有接触到的比如数模里的函数，AI课学习的「决策树」『minimax』等，模型有很多不同的表达形式。或许使用最多的还是函数。  </p>
<span id="more"></span>

<h1 id="模型类型举例"><a href="#模型类型举例" class="headerlink" title="模型类型举例"></a>模型类型举例</h1><h2 id="Conceptual-Models"><a href="#Conceptual-Models" class="headerlink" title="Conceptual Models"></a>Conceptual Models</h2><p>Conceptual Models are qualitative models that help highlight important connections in real world systems and processes. They are used as a first step in the development of more complex models.<br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxy8bi0p27j304604djr8.jpg"></p>
<h2 id="Interactive-Lecture-Demonstrations"><a href="#Interactive-Lecture-Demonstrations" class="headerlink" title="Interactive Lecture Demonstrations"></a>Interactive Lecture Demonstrations</h2><p>Interactive Lecture Demonstrations Interactive demonstrations are physical models of systems that can be easily observed and manipulated and which have characteristics similar to key features of more complex systems in the real world. These models can help bridge the gap between conceptual models and models of more complex real world systems.<br><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fxy8bskxjdj3046050web.jpg"></p>
<h2 id="Mathematical-and-Statistical-Models"><a href="#Mathematical-and-Statistical-Models" class="headerlink" title="Mathematical and Statistical Models"></a>Mathematical and Statistical Models</h2><p>Mathematical and Statistical Models involve solving relevant equation(s) of a system or characterizing a system based upon its statisical parameters such as mean, mode, variance or regression coefficients. Mathematical models include Analytical models and Numerical Models. Statistical models are useful in helping identify patterns and underlying relationships between data sets.<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxy8c0gmcsj304g04ojra.jpg"><br><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fxy8c862s3j305n03rt8k.jpg"></p>
<h2 id="Teaching-with-Visualizations"><a href="#Teaching-with-Visualizations" class="headerlink" title="Teaching with Visualizations"></a>Teaching with Visualizations</h2><p>Teaching with Visualizations By this we mean anything that can help one visualize how a system works. A visualization model can be a direct link between data and some graphic or image output or can be linked in series with some other type of model so to convert its output into a visually useful format. Examples include 1-, 2-, and 3-D graphics packages, map overlays, animations, image manipulation and image analysis.<br><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fxy8cesqgej304002odfo.jpg"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>抽象或许是建模的第一要素</li>
<li>模型概念很广</li>
<li>AI所说的“我们训练了一个很好的模型”指的就是利用我们的模型，输入所给的输入，得到的输出很符合我们的期望。比如给机器人一张视觉的影像，他知道该怎么移动怎么操作，知道拿起苹果放到指定位置，这符合我们对输出的期望（输出就是机器人所做出的动作）。这就是好的模型。</li>
</ul>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>人工智能</tag>
        <tag>模型</tag>
      </tags>
  </entry>
  <entry>
    <title>台湾大学郭彥甫-MATLAB系列课程</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/%E5%8F%B0%E6%B9%BE%E5%A4%A7%E5%AD%A6%E9%83%AD%E5%BD%A5%E7%94%AB-MATLAB%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B/</url>
    <content><![CDATA[<p>最近在准备2018美赛，为了重温我的MATLAB并学习MATLAB机器学习相关课程，找来了很有名的郭彥甫老师的MATLAB系列课程。<br>这套课程对有语言基础的同学来说很有帮助，不仅仅学习了MATLAB还能从MATLAB这门语言的设计思路上收获很多新的感想。</p>
<h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><p><a href="https://www.youtube.com/watch?v=KHFZLkm9qs0&list=PLVHBjRDK0kALcQMwAFbR5q2driYZCHNIx&index=1">Youtube-MATLAB教學</a><br><a href="https://www.bilibili.com/video/av14503445/?from=search&seid=799523035367515629">Bilibili-【搬运】MATLAB教程系列-台大（共14课）</a><br><em>建议以1.5倍速观看</em></p>
<h2 id="我的评价"><a href="#我的评价" class="headerlink" title="我的评价"></a>我的评价</h2><p>我认为是我能在YouTube和B站上找到的最好的中文MATLAB学习视频。  </p>
<h2 id="我的笔记（含01-07节笔记及部分MATLAB官方文档学习笔记）"><a href="#我的笔记（含01-07节笔记及部分MATLAB官方文档学习笔记）" class="headerlink" title="我的笔记（含01-07节笔记及部分MATLAB官方文档学习笔记）"></a>我的笔记（含01-07节笔记及部分MATLAB官方文档学习笔记）</h2><p>我用OneNote记录的笔记，虽然记得很烂但兴许对您有点帮助。</p>
<p><a href="https://drive.google.com/open?id=1ne77x3GdcmCpg7ge4Vdbfz1vF_9c2n45">PDF</a>   </p>
<p><a href="https://1drv.ms/f/s!AilVfMoUA-GMhTs_-PMDXXXEhaJB">OneNote</a></p>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>制作中…</p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>基于VMware的CentOS7下NAT模式网络配置</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/%E5%9F%BA%E4%BA%8EVMware%E7%9A%84CentOS7%E4%B8%8BNAT%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>Hadoop学习第一篇。<br>如何在VMware下配置CentOS7系统的NAT网络模式  </p>
<h2 id="NAT网络模式"><a href="#NAT网络模式" class="headerlink" title="NAT网络模式"></a>NAT网络模式</h2><p>一共有三种网络模式，分别是  </p>
<ol>
<li> 桥接模式（VMnet0）</li>
</ol>
<ul>
<li><p>什么是桥接模式呢？形象点说，就是在真实的物理网卡与虚拟网卡VMnet0搭一条通道，这样好似把物理网卡和虚拟网卡VMnet0合二为一了，变成了一个新的网卡；假如，我们把这个网卡叫做bridge0，无论是物理机还是VMware虚拟机访问外网，都通过bridge0这个网卡来进行。</p>
</li>
<li><p>另外的说法是，当做了网卡的桥接，VMware里的虚拟机和物理机都处于同一个网段，由同一个交换机连接起来一样；当然，这个交换机也是虚拟的。  </p>
<img src = "https://img-blog.csdn.net/20161209145026402?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl5aWJvMzcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" align=center width=300></li>
</ul>
<ol start="2">
<li>NAT模式（VMnet8）</li>
</ol>
<ul>
<li>NAT就是“网络地址转换”，它的功能的实现需要路由器。它的作用就是把私网的ip地址转化为公网的ip地址来访问因特网。<img src = "https://img-blog.csdn.net/20161209145317797?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl5aWJvMzcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" align=center width=300></li>
</ul>
<ol start="3">
<li>host-only模式（VMnet1）</li>
</ol>
<ul>
<li>最后，就是仅主机模式了，这个模式其实很简单，虚拟机和物理机只要处于同一个网段，就可以通信，但是不能连接因特网。虚拟机ip属于哪个网段，要参考VMnet1这个网卡的网段。</li>
</ul>
<ol start="4">
<li>一点总结<br>桥接模式是再造一个虚拟“交换机”  ，原主机和虚拟机网卡合并，处于平等地位<br>NAT模式是再造一个虚拟路由器，原主机是路由器，虚拟机网卡连接到路由器下<br>因为NAT模式相对来说更常用一些（它可以将虚拟机隐藏在主机下），所以本文只介绍NAT模式的配置</li>
</ol>
<span id="more"></span>

<h2 id="NAT模式配置"><a href="#NAT模式配置" class="headerlink" title="NAT模式配置"></a>NAT模式配置</h2><ol>
<li>原主机部分</li>
</ol>
<ul>
<li>打开控制面板-网络和共享中心-选择左侧的“更改适配器设置”<img src = "https://github.com/Raven98/Raven98.github.io/blob/master/uploads/CentOS_NAT/1.1.png?raw=true" align=center width=300></li>
<li>右键点击你正在使用的网络，比如我正在用WLAN，选择属性<img src = "https://github.com/Raven98/Raven98.github.io/blob/master/uploads/CentOS_NAT/1.2.png?raw=true" align=center width=300></li>
<li>选择“分享”选项卡，在下拉框中选择你要分享的，也就是我们的“VMware Network Adapter VMnet8”<img src = "https://github.com/Raven98/Raven98.github.io/blob/master/uploads/CentOS_NAT/1.3.png?raw=true" align=center width=300></li>
<li>别忘了在VMware里选择NAT模式<img src = "https://github.com/Raven98/Raven98.github.io/blob/master/uploads/CentOS_NAT/1.4.png?raw=true" align=center width=300></li>
</ul>
<ol start="2">
<li>虚拟机部分</li>
</ol>
<ul>
<li>进入设置界面的“Network”，点击右下角的设置<img src = "https://github.com/Raven98/Raven98.github.io/blob/master/uploads/CentOS_NAT/2.1.png?raw=true" align=center width=300></li>
<li>DNS一定要和主机填一样的DNS地址（获取主机DNS的方式：CMD中输入<strong>ipconfig/all</strong>命令就可以看到<img src = "https://github.com/Raven98/Raven98.github.io/blob/master/uploads/CentOS_NAT/2.2.png?raw=true" align=center width=300></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/liyibo373/article/details/53538702">VMware workstations 里的虚拟机如何上网（NAT模式）</a></p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>NAT</tag>
      </tags>
  </entry>
  <entry>
    <title>用VSCode对云服务器文件进行在线编辑</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/%E7%94%A8VSCode%E5%AF%B9%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%BE%91/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前两天用上了macOS后发现Mac下没有很好用的SCP应用（也有可能是我还没发现）。用推荐比较多的FileZilla后发现也不如Windows下强大的WinSCP。<br>说起WinSCP，最让我怀念它的倒不是极其方便的上传文件功能，毕竟scp命令也没多长，不用工具也可以解决，而是它可以右键服务器上的文件进行在线编辑，感觉比较方便。（对于vim掌握不熟练的我来说）</p>
<img src="https://pic3.zhimg.com/80/v2-a2cdccc20eae8c05d8b1f646b6d8438d_hd.jpg" align=center width=300 alt="WinSCP~SCP for Windows"/>

<p>突发奇想，想看看我们越来越流行，越来越强大的VSCode有没有好的解决方案，还真的搜到了~~~在美国简书Medium上找到了一篇（原文作者和我有很相似的历程hh）：</p>
<p><a href="https://medium.com/@prtdomingo/editing-files-in-your-linux-virtual-machine-made-a-lot-easier-with-remote-vscode-6bb98d0639a4">Editing files in your Linux Virtual Machine made a lot easier with Remote VSCode</a></p>
<span id="more"></span>

<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>本地：macOS+VSCode</li>
<li>服务器：CentOs 7.3</li>
</ul>
<hr>
<h2 id="Remote-VSCode"><a href="#Remote-VSCode" class="headerlink" title="Remote VSCode"></a>Remote VSCode</h2><ol>
<li>打开VSCode<a href="https://code.visualstudio.com/">VSCode下载</a></li>
<li>进入插件页，搜索“Remote VSCode”</li>
</ol>
<img src="https://pic4.zhimg.com/80/v2-bb9144276dc49e0002df242d251f8f7d_hd.jpg" align=center width=300 alt="VSCode plugin store"/>

<ol>
<li><p>安装插件并重启VSCode</p>
</li>
<li><p>打开服务器，并执行以下命令<br> $ sudo wget -O /usr/local/bin/rmate <a href="https://raw.github.com/aurora/rmate/master/rmate">https://raw.github.com/aurora/rmate/master/rmate</a><br> $ sudo chmod a+x /usr/local/bin/rmate</p>
</li>
<li><p>回到VSCode打开命令窗（Command + Shift + P）并执行 <strong>&gt;Remote: Start Server</strong></p>
<blockquote>
<p>（这一步是开启macOS的52698端口，保持TCP连接，等待请求）</p>
</blockquote>
</li>
<li><p>OK之后，在VSCode内打开一个新的终端输入以下命令连接到你的Linux服务器：<br> $ ssh -R 52698:localhost:52698 VIRTUAL_MACHINE_IP_ADDRESS</p>
<blockquote>
<p>（VIRTUAL_MACHINE_IP_ADDRESS 就是你的服务器IP地址）</p>
</blockquote>
</li>
<li><p>在你的VSCode终端内，执行rmate命令来编辑你想编辑的文件。会看到服务器上的文件内容会在VSCode里面自动就显示出来啦<del>这时你再保存也是同步保存到服务器上的。你也同样可以在VSCode的终端里执行命令比如 python test.py 之类。也就是说只需要一个VSCode就可以完成连接、编辑、保存、执行操作。（就差一个SFTP上传了</del>，SFTP上传插件也找到了，这个暂时没需求，下次再试一下嘿嘿）</p>
</li>
</ol>
<img src="https://pic4.zhimg.com/80/v2-d4846bbc6dd2888bb2419a4ddd74a1f1_hd.jpg" align=center width=300 alt="VSCode plugin store"/>

<blockquote>
<p>为什么是52698?<br>52698是Remote VSCode插件的默认端口，你可以在“User Preference”页面内搜索”Remote VSCode configuration”来改变它。</p>
</blockquote>
<img src="https://pic3.zhimg.com/80/v2-d4af7178bb1b3d6a1b46dc59152e4743_hd.jpg" align=center width=300 alt="VSCode plugin store"/>]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
        <tag>Remote VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>自动驾驶技术简介</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<blockquote>
<p>本文写于19年4月智能驾驶技术课程<br>参考书籍</p>
<ul>
<li>第一本无人驾驶技术书, 2017</li>
<li>Creating Autonomous Vehicle Systems, 2018</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>NEU</tag>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络学习预备知识</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>这周开始了计算机网络的学习，taken by英国阿伯丁大学的Sean Sturley教授。</p>
<p>对于软件工程专业的学生，如果之前的课程都是集中在C，Java这种编程语言的话，初入计算机网络可能有很多知识还不曾了解，本文包含了我在学习计网过程中所搜集到的很多优秀的计网基础知识内容讲解。<br><em>Ctrl+F开启搜索</em></p>
<span id="more"></span>

<ol>
<li><p><a href="http://www.cnblogs.com/maybe2030/p/4781555.html">计算机网络基础知识总结</a></p>
</li>
<li><p><a href="https://jingyan.baidu.com/article/2c8c281df0afd00008252aa7.html">什么是域名？什么网站名？什么是URL？</a></p>
</li>
<li><p><a href="http://blog.csdn.net/holandstone/article/details/47026213">wireshark基本操作</a></p>
</li>
<li><p><a href="https://jingyan.baidu.com/article/22a299b5c4c5ae9e18376a6c.html?st=2&net_type=&bd_page_type=1&os=0&rst=&word=%E6%9F%A5%E5%B7%A5%E5%95%86%E5%8F%B7">端口查看</a></p>
</li>
<li><p><a href="http://www.yunsec.net/a/school/wlcs/agreement/2012/0317/10262.html">TCP的几个状态</a></p>
</li>
<li><p><a href="http://blog.csdn.net/faithc/article/details/52832617?locationNum=1&fps=1">常见的TCP Info</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/sbaicl/archive/2012/11/09/2762814.html">OSI七层模型概述及常用协议</a></p>
</li>
</ol>
<p><em>（其实在应用、表示和会话这三层之间的协议可共用（由于实际的网络协议将它们归了一类所致）正所谓TCP/IP将OSI的三个上层合为应用层）</em></p>
<ol start="8">
<li><p><a href="http://blog.csdn.net/lqrensn/article/details/5134408">IP Header 解析</a></p>
</li>
<li><p><a href="http://blog.csdn.net/qq_29277155/article/details/52077239">设置捕捉过滤器</a></p>
</li>
<li><p>设置显示过滤器</p>
<p>在显示页面点击“表达式”进行操作</p>
</li>
<li><p><a href="http://blog.sina.com.cn/s/blog_15b5e88870102wi4w.html">5类IP地址分类详解</a></p>
</li>
<li><p><a href="http://blog.csdn.net/xy2204/article/details/50522075">快速进制转换方法</a></p>
</li>
<li><p><a href="http://blog.csdn.net/u013630349/article/details/48756813">计算机网络 之 常见网络协议相关总结</a></p>
</li>
<li><p><a href="http://blog.csdn.net/jiary5201314/article/details/41213561">IP头部协议字段表1</a></p>
<p><a href="http://blog.163.com/yibei_kukafei/blog/static/3002102120125994657725/">IP头部协议字段表2</a></p>
</li>
</ol>
<ol start="15">
<li><p>更改CMD语言 </p>
<ul>
<li>chcp 437将界面语言设置为<font color=green><strong>美式英语</strong></font> </li>
<li>chcp 936将界面语言设置为<font color=red><strong>中文</strong></font></li>
</ul>
</li>
<li><p>Key </p>
</li>
</ol>
<ul>
<li><p>a.【最贴近生活的面向连接与无连接服务】 </p>
<p>  语言/视频通话–&gt;少传一点不影响我们听声音/看人–&gt;UDP（无连接）</p>
<p>  传文件–&gt;少传一点可能整个文件都是乱码–&gt;TCP（面向连接）</p>
</li>
<li><p>b.【模拟信号与数字信号】<br>所谓模拟信号，就是利用如温度、湿度、压力、长度、电流、电压等等的变化来对应形成0，1字符以传递信息。</p>
</li>
<li><p>c.【常用CMD命令】 </p>
<p>  ipconfig 查看本机IP </p>
<p>  ipconfig /all 查看本机IP，MAC等等全部网络相关信息 </p>
<p>  netstat -ano 查看所有占用端口</p>
</li>
<li><p>d.【特殊的IP地址】 </p>
<p>  举例：<br>  <strong>IP：172.28.110.36</strong> </p>
<p>  子网掩码：255.255.0.0 </p>
<p>  默认网关：172.28.255.254. </p>
<p>  广播地址：172.28.255.255 </p>
<p>  网络地址：172.28.0.0 </p>
<p>  <em>网络地址最后一位通常为1或254，因而在设置本机IP时，最后一字节尽量避开1和254</em></p>
<p>  非常规掩码：<em><strong>172.28.110.36 /17</strong></em><br>  表明前17位是子网掩码，这样增大了网络地址的易用性，因为之前的设置方法每个等级会有8位的差距，浪费了很多不必要的空间。 </p>
<p>  注意区分：<em>IP地址</em>、<em>网络地址</em>、<em>网络ID</em>、<em>子网ID</em>、<em>主机ID</em>、<em>主机地址</em> 之间的区别和联系。</p>
</li>
</ul>
<img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1517642449819&di=14fb9fb5975d2c8240c073e94bd75d0e&imgtype=0&src=http%3A%2F%2Fimg.25pp.com%2Fuploadfile%2Fapp%2Ficon%2F20160621%2F1466477619931774.jpg" width = "100" height = "100" alt="CSDN" align=center />]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>NEU</tag>
      </tags>
  </entry>
  <entry>
    <title>认真搞清楚static, final, final static</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/%E8%AE%A4%E7%9C%9F%E6%90%9E%E6%B8%85%E6%A5%9Astatic,%20final,%20final%20static/</url>
    <content><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p><em>为什么要用static?</em><br>有一些频繁使用的东西，如果你每次使用都重新new一下，那么这个开销可能会很高，如果使用static，一直放在内存中，那么想用就直接用，而不需要重新new一块空间初始化数据。那么static就是为了实现一个系统的缓存作用的，其生命周期直到应用程序退出结束。<br>这说明，static修饰的类成员，在程序运行过程中，只需要初始化一次即可，不会进行多次的初始化。static可以修饰：方法，属性，代码段，内部类（静态内部类或嵌套内部类）<br>主要有四种用法：</p>
<h2 id="static成员变量"><a href="#static成员变量" class="headerlink" title="static成员变量"></a>static成员变量</h2><p><strong>用来修饰成员变量，将其变为类的成员，从而实现所有对象对于该成员的共享</strong><br>静态变量和非静态变量的区别是：  </p>
<ul>
<li>静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。</li>
<li>非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。<br>static不允许用来修饰局部变量，只能修饰成员变量。</li>
</ul>
<h2 id="static方法"><a href="#static方法" class="headerlink" title="static方法"></a>static方法</h2><p><strong>用来修饰成员方法，将其变为类方法，可以直接使用“类名.方法名”的方式调用，常用于工具类</strong>  </p>
<ul>
<li>首先，在静态方法中不能访问类的非静态成员变量和非静态成员方法。<br>原因：非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。在一个类的静态成员中去访问其非静态成员之所以会出错是因为在类的非静态成员不存在的时候类的静态成员就已经存在了，访问一个内存中不存在的东西当然会出错。  </li>
<li>其次，即使没有显示地声明为static，类的构造器实际上也是静态方法。</li>
</ul>
<h2 id="static代码块"><a href="#static代码块" class="headerlink" title="static代码块"></a>static代码块</h2><p><strong>静态块用法，将多个类成员放在一起初始化，使得程序更加规整，其中理解对象的初始化过程非常关键</strong><br>static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。<br>很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p>
<blockquote>
<p>一个Java文件从编码完成到最终执行，一般主要包括两个过程</p>
<ul>
<li>编译</li>
<li>运行<br>编译，即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件。<br>运行，则是把编译声称的.class文件交给Java虚拟机(JVM)执行。<br>而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。<br>举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。  </li>
</ul>
<p><strong>由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且只加载一次。</strong>  </p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>静态代码块先于main函数执行，这是必然的，因为静态代码块是随着类的加载而执行。</p>
</blockquote>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticDemo</span></span>&#123;</span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态代码块 </span></span><br><span class="line">    &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;父类非静态代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    StaticDemo() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造方法被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> <span class="keyword">extends</span> <span class="title">StaticDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 静态代码块的特点：</span></span><br><span class="line"><span class="comment">    * 随着类的加载而执行，而且只执行一次</span></span><br><span class="line"><span class="comment">    * 静态代码块额执行顺序优先于main函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类非静态代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    StaticTest() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造方法被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] hq)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main函数&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> StaticTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父类静态代码块被执行</span><br><span class="line">子类静态代码块被执行</span><br><span class="line">main函数</span><br><span class="line">父类非静态代码块被执行</span><br><span class="line">父类构造方法被执行</span><br><span class="line">子类非静态代码块被执行</span><br><span class="line">子类构造方法被执行</span><br></pre></td></tr></table></figure>

<h2 id="static内部类"><a href="#static内部类" class="headerlink" title="static内部类"></a>static内部类</h2><p><strong>静态导包用法，将类的方法直接导入到当前类中，从而直接使用“方法名”即可调用类方法，更加方便</strong><br>static内部类与非static内部类的区别：</p>
<ul>
<li>首先，在非静态内部类中不可以声明静态成员。</li>
<li>其次，静态内部类不能访问其外部类的非静态成员变量和方法。</li>
<li>最后在创建静态类内部对象时，不需要其外部类的对象。<br>java在实现LinkedList时使用了如下内部类：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">       <span class="title">extendsAbstractSequentialList</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;,<span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">   </span>&#123; </span><br><span class="line">   ........ </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> classEntry&lt;E&gt; &#123; </span><br><span class="line">               E element; </span><br><span class="line">               Entry&lt;E&gt; next; </span><br><span class="line">               Entry&lt;E&gt; previous; </span><br><span class="line"></span><br><span class="line">               Entry(E element,Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.element =element; </span><br><span class="line">                       <span class="keyword">this</span>.next = next;</span><br><span class="line">                       <span class="keyword">this</span>.previous =previous; </span><br><span class="line">               &#125; </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Entry&lt;E&gt; <span class="title">addBefore</span><span class="params">(E e,Entry&lt;E&gt; entry)</span> </span>&#123;</span><br><span class="line">               Entry&lt;E&gt; newEntry =<span class="keyword">new</span> Entry&lt;E&gt;(e, entry, entry.previous);</span><br><span class="line">               newEntry.previous.next = newEntry;</span><br><span class="line">               newEntry.next.previous =newEntry; </span><br><span class="line">               size++; </span><br><span class="line">               modCount++; </span><br><span class="line">               <span class="keyword">return</span> newEntry; </span><br><span class="line">   &#125; </span><br><span class="line">   ........ </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这里即静态内部类的典型用法</p>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>在java的关键字中，static和final是两个我们必须掌握的关键字。不同于其他关键字，他们都有多种用法，而且在一定环境下使用，可以提高程序的运行性能，优化程序的结构。<br>在java中，final的含义在不同的场景下有细微的差别，但总体上来说，它指的是“这是不可变的”。下面，我们来讲final的四种主要用法。</p>
<h2 id="修饰数据"><a href="#修饰数据" class="headerlink" title="修饰数据"></a>修饰数据</h2><p>在编写程序时，我们经常需要说明一个数据是不可变的，我们成为常量。在java中，用final关键字修饰的变量，只能进行一次赋值操作，并且在生存期内不可以改变它的值。更重要的是，final会告诉编译器，这个数据是不会修改的，那么编译器就可能会在编译时期就对该数据进行替换甚至执行计算，这样可以对我们的程序起到一点优化。不过在针对基本类型和引用类型时，final关键字的效果存在细微差别。我们来看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> f2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        f2 = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> value1 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// value1 = 4;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> value2;</span><br><span class="line">        value2 = <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">final</span> Value value3 = <span class="keyword">new</span> Value(<span class="number">1</span>);</span><br><span class="line">        value3.v = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们先来看一下main方法中的几个final修饰的数据，在给value1赋初始值之后，我们无法再对value1的值进行修改，final关键字起到了常量的作用。从value2我们可以看到，final修饰的变量可以不在声明时赋值，即可以先声明，后赋值。value3时一个引用变量，这里我们可以看到final修饰引用变量时，只是限定了引用变量的引用不可改变，即不能将value3再次引用另一个Value对象，但是引用的对象的值是可以改变的，从内存模型中我们看的更加清晰：</p>
<img src="http://ws3.sinaimg.cn/large/006tNc79ly1g2ywdvorkcj30dd05ot90.jpg" width="500rpx"/>

<p>上图中，final修饰的值用粗线条的边框表示它的值是不可改变的，我们知道引用变量的值实际上是它所引用的对象的地址，也就是说该地址的值是不可改变的，从而说明了为什么引用变量不可以改变引用对象。而实际引用的对象实际上是不受final关键字的影响的，所以它的值是可以改变的。</p>
<p>另一方面，我们看到了用final修饰成员变量时的细微差别，因为final修饰的数据的值是不可改变的，所以我们必须确保在使用前就已经对成员变量赋值了。因此对于final修饰的成员变量，我们有且只有两个地方可以给它赋值，一个是声明该成员时赋值，另一个是在构造方法中赋值，在这两个地方我们必须给它们赋初始值。</p>
<p>最后我们需要注意的一点是，同时使用static和final修饰的成员在内存中只占据一段不能改变的存储空间。</p>
<h2 id="修饰方法参数"><a href="#修饰方法参数" class="headerlink" title="修饰方法参数"></a>修饰方法参数</h2><p>前面我们可以看到，如果变量是我们自己创建的，那么使用final修饰表示我们只会给它赋值一次且不会改变变量的值。那么如果变量是作为参数传入的，我们怎么保证它的值不会改变呢？这就用到了final的第二种用法，即在我们编写方法时，可以在参数前面添加final关键字，它表示在整个方法中，我们不会（实际上是不能）改变参数的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalFunc</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i, <span class="keyword">final</span> Value value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// i = 5; 不能改变i的值</span></span><br><span class="line">        <span class="comment">// value = new Value(); 不能改变v的值</span></span><br><span class="line">        value.v = <span class="number">5</span>; <span class="comment">// 可以改变引用对象的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h2><p>第三种方式，即用final关键字修饰方法，它表示该方法不能被覆盖。这种使用方式主要是从设计的角度考虑，即明确告诉其他可能会继承该类的程序员，不希望他们去覆盖这个方法。这种方式我们很容易理解，然而，关于private和final关键字还有一点联系，这就是类中所有的private方法都隐式地指定为是final的，由于无法在类外使用private方法，所以也就无法覆盖它。</p>
<h2 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h2><p>了解了final关键字的其他用法，我们很容易可以想到使用final关键字修饰类的作用，那就是用final修饰的类是无法被继承的。</p>
<p>上面我们讲解了final的四种用法，然而，对于第三种和第四种用法，我们却甚少使用，这不是没有道理的。<br>从final的设计来讲，这两种用法甚至可以说是鸡肋，因为对于开发人员来讲，如果我们写的类被继承的越多，就说明我们写的类越有价值，越成功。即使是从设计的角度来讲，也没有必要将一个类设计为不可继承的。Java标准库就是一个很好的反例，特别是Java 1.0/1.1中Vector类被如此广泛的运用，如果所有的方法均未被指定为final的话，它可能会更加有用。如此有用的类，我们很容易想到去继承和重写他们，然而，由于final的作用，导致我们对Vector类的扩展受到了一些阻碍，导致了Vector并没有完全发挥它应有的全部价值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>final关键字是我们经常使用的关键字之一，它的用法有很多，但是并不是每一种用法都值得我们去广泛使用。它的主要用法有以下四种：</p>
<ul>
<li>用来修饰数据，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变。对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值；</li>
<li>用来修饰方法参数，表示在变量的生存期中它的值不能被改变；</li>
<li>修饰方法，表示该方法无法被重写；</li>
<li>修饰类，表示该类无法被继承。  </li>
</ul>
<p>上面的四种方法中，第三种和第四种方法需要谨慎使用，因为在大多数情况下，如果是仅仅为了一点设计上的考虑，我们并不需要使用final来修饰方法和类。</p>
<h1 id="static-final"><a href="#static-final" class="headerlink" title="static final"></a>static final</h1><p>static final == final static<br>同时使用static和final修饰的成员在内存中只占据一段不能改变的存储空间。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/zhangyanli0414/article/details/79008681">Java中如何理解Static，Final，Static Final</a></li>
<li><a href="https://www.cnblogs.com/dotgua/p/6357951.html">java final关键字的几种用法</a></li>
</ul>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>领域特定语言DSL与正则表达式</title>
    <url>/g.%E7%9F%A5%E8%AF%86%E8%A7%92%E8%90%BD/History/%E9%A2%86%E5%9F%9F%E7%89%B9%E5%AE%9A%E8%AF%AD%E8%A8%80DSL%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近无意间了解到了DSL领域特定语言这个概念，觉得这个概念还很有趣呢。<br>其实我对于DSL的理解是，是大家先不约而同的做了<em>DSL所定义的事情</em>，而后才由世界级软件开发大师和软件开发“教父”Martin Fowler总结出了DSL这个概念。<br>最近总遇到正则表达式的问题，不仅仅是编程，有时候即便是处理一些日常任务，正则表达式的使用也能让我buff加满，就和Linux的shell编程一样哈哈。<br>这篇文章集中于对DSL的简单介绍和DSL的应用领域之一——正则表达式。其中，正则表达式的部分会在过几日完成。</p>
<span id="more"></span>
<h2 id="DSL-领域特定语言"><a href="#DSL-领域特定语言" class="headerlink" title="DSL 领域特定语言"></a>DSL 领域特定语言</h2><p>DSL的全称是domain-specific language，它在wiki上的定义如下：<br>    A domain-specific language (DSL) is a computer language specialized to a particular application domain.<br>与之相对的是GPL(general-purpose language)。<br>DSL指的是针对特定应用领域而设计使用的计算机语言，而GPL指的是针对跨应用领域而设计使用的计算机语言。<br>常见的DSL有：HTML,Shell,make语言,ant语言,maven语言，rpm语言，dpkg语言，awk语言，正则表达式，dc计算机语言等，有些DSL语言又被称为微型语言<br>常见的GPL有：Java,C等<br>以Fowler的观点，DSL首先是一种帮助用户从一个系统中抽象出某些部分的工具。所以“当你意识到你需要一个组件，或者当你已经有了一个组件而你希望简化操作它的方式的时候”，DSL是有用的。使用DSL确实提供了某些益处。DSL不仅提高了代码的易读性，让开发者可以和领域专家更好的交流，而且是改变执行上下文的一种手段，例如：把逻辑从编译时切换到运行时，或者当命令式编程不是很合适的时候转用声明式计算模型。<br>哎，感觉自己还没有完全理解。先占个坑~<br>[See more](如何从业务代码中提升技术：使用领域特定语言消除重复代码 - phodal的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/38532183">https://zhuanlan.zhihu.com/p/38532183</a>)</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/dslztx/article/details/46682889">什么是DSL</a></p>
]]></content>
      <categories>
        <category>知识角落</category>
      </categories>
      <tags>
        <tag>领域特定语言</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>准大学生，如何预习计算机专业？</title>
    <url>/d.%E6%9D%82%E6%96%87%E9%9A%8F%E7%AC%94/History/%E5%87%86%E5%A4%A7%E5%AD%A6%E7%94%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E9%A2%84%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>本文来自于我在知乎问题“准大学生，如何预习计算机专业？”下的回答，截至 2020-11-30，回答已经获赞超过 3400。<br><a href="https://www.zhihu.com/question/24188466/answer/755613327">原回答链接</a></p>
</blockquote>
<h1 id="一、为什么要提前学习？"><a href="#一、为什么要提前学习？" class="headerlink" title="一、为什么要提前学习？"></a>一、为什么要提前学习？</h1><p>强烈建议提前学习了解计算机学科知识！</p>
<ul>
<li>计算机不同于传统学科（如理化生政史地等），这些学科大家都有一定的基础，先发优势不明显；</li>
<li>也不同于高精尖学科（如医学冶金材料环境等），这些学科大家基本都没有基础，完全同一起跑线。</li>
</ul>
<p>随着我国经济社会的不断发展，越来越多的计算机专业大学生在步入大学校园前就接触到了计算机，答主在步入大学后也发现身边很多在大学前有一定基础甚至有一定开发经验的同学都学习的很顺利，积极参与各类工程项目，科研项目。有很多大一的学弟都比我这样即将步入大四的学长动手能力强。（自闭、爆哭）</p>
<p>甚至「少儿编程」都成为了最近的一个风口。三十年前小平爷爷一句「计算机普及要从娃娃抓起」在现如今的浮躁社会变成了现实。</p>
<ul>
<li><a href="https://baijiahao.baidu.com/s?id=1631551960752430210&wfr=spider&for=pc">人民日报：少儿编程热需要冷思考</a></li>
</ul>
<p>现在距离开学还有两个月，虽然时间不多但还是建议充分利用，不寻求学到太多知识只是力求对计算机学科的轮廓有一个大概的掌握，面对入学后接踵而来的各种概念能有自己的思考。</p>
<blockquote>
<p>另外如果你是大一入学了或者大一都快结束了才看到本文也不用太担心，因为目前大学本科第一年基本都是基础学科的学习，大二后才深入学习专业知识，所以建议大家在大一期间一定保持自己对计算机学科的热爱，充分利用课余时间。你会发现一旦你比别人走得快，那么将走得越来越快。<br>即便你是大二才看到本文也不要担心，我差不多也算是大二下学期才慢慢学会自己去摸索~虽然很晚了但是只要能尽早找到感兴趣的方向做一些感兴趣的项目就会很棒。</p>
</blockquote>
<span id="more"></span>

<h1 id="二、学什么？怎么学？从哪学？"><a href="#二、学什么？怎么学？从哪学？" class="headerlink" title="二、学什么？怎么学？从哪学？"></a>二、学什么？怎么学？从哪学？</h1><p>关于这个假期学什么，我的建议是：</p>
<ol>
<li>编程语言（中级语言C、高级语言 Python 或 Java）</li>
<li>计算机基础知识（计算机专业导论）</li>
<li>web技术栈</li>
<li>常用开发工具</li>
<li>关注计算机行业</li>
</ol>
<blockquote>
<ul>
<li>先学习编程语言并熟悉对应的开发工具，同时观看计算机专业导论MOOC视频                 </li>
<li>学习web技术栈，边学边进行实践项目</li>
<li>关注计算机行业则是作为一项长期的爱好来培养</li>
</ul>
</blockquote>
<h2 id="1-编程语言"><a href="#1-编程语言" class="headerlink" title="1. 编程语言"></a>1. 编程语言</h2><p>国内计算机本科第一门专业课一定是一门编程语言，目前来看大部分学校还是先学C语言，少部分学校会先学习Python，我建议先学习C语言的基础知识，而后再学习Python。<br>这样安排的想法是：各种编程语言都有通用的一部分知识，如：</p>
<ul>
<li>数据类型</li>
<li>变量</li>
<li>常量</li>
<li>运算符</li>
<li>判断</li>
<li>循环</li>
<li>字符串</li>
<li>数组</li>
<li>函数</li>
</ul>
<p>而C语言的这部分通用知识上手快易学习，也能为你入学后的学习打好基础。<br>学完了基础知识不建议继续学习C语言高级知识，因为如果缺少计算机基础知识的学习对那些高级的编程语言知识掌握也不到位（不能理解为什么编程语言是这样设计的）；另外一个问题是学习了编程语言迟迟没有产出，不知道除了输出命令行还能干什么。你需要一些可视化的开发让你真真切切地感受到了自己开发的产物。<br>这个时候建议学习Python，各大Python教程都有很大实际应用的例子，你能很快做出一些小应用，这对激发学习兴趣，保持学习动力是有极大帮助的。</p>
<ul>
<li><a href="https://www.runoob.com/cprogramming/c-tutorial.html">C 语言教程 | 菜鸟教程</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">Python教程</a></li>
</ul>
<blockquote>
<p>第二门语言如果不喜欢Python的话，Java也是一个非常棒的选择！这个也可以提前看一下你们学校的培养计划，如果是有Java必修课的话也可以学习Java。</p>
</blockquote>
<h2 id="2-计算机基础知识"><a href="#2-计算机基础知识" class="headerlink" title="2. 计算机基础知识"></a>2. 计算机基础知识</h2><p>计算机基础知识的学习建议学习<strong>《计算机专业导论》</strong>  </p>
<ul>
<li><a href="https://www.icourse163.org/course/HIT-437006">计算机专业导论_哈尔滨工业大学_中国大学MOOC(慕课)</a></li>
</ul>
<p>计算机专业导论可以帮助你对即将学习的学科有一个大致的了解，知识注重广度而非深度。<br>软件工程专业的同学也可以去看《软件工程导论》  </p>
<ul>
<li><a href="https://www.icourse163.org/course/HIT-298007">软件工程专业导论</a></li>
</ul>
<h2 id="3-web技术栈"><a href="#3-web技术栈" class="headerlink" title="3. web技术栈"></a>3. web技术栈</h2><p>web技术栈是最容易上手的计算机工程技术，如果能在开学前完成一个简单web应用的开发，相信这将予以你足够的学习信心。记住，这部分一定要多动手实践，学习以开发一个小网站结束（数据库的使用为可选项）<br>另外，然后你不想做PC端的网页而想做手机移动端的应用的话，微信小程序是一个很好的选择！<br>你需要学习  </p>
<ul>
<li>基于python的web后端框架flask: <a href="https://www.w3cschool.cn/flask/">Flask 教程_w3cschool</a></li>
<li>前端基础技术（HTML/CSS/JavaScript）: <a href="http://www.w3school.com.cn/">w3school 在线教程</a></li>
<li>另外推荐一些你会遇到的知识学习教程<ul>
<li>web技术边学边练（Github star最多的项目）: <a href="https://www.freecodecamp.cn/">Learn to Code and Help Nonprofits</a></li>
<li>Linux基础知识（用于做web服务器）: <a href="http://linux.vbird.org/">鳥哥的 Linux 私房菜 – 鳥哥的 Linux 私房菜 首頁</a></li>
<li>云服务器入门: <a href="https://ravenxu.top/2018/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%A5%E9%97%A8/">云服务器入门</a></li>
<li>Git版本控制工具: <a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程</a></li>
<li>Vue.js（最容易上手的前端框架）: <a href="https://cn.vuejs.org/v2/guide/">介绍 — Vue.js</a></li>
<li>RESTful API: <a href="https://crifan.github.io/http_restful_api/website/restful_rule/rule.html">通用设计规则 · HTTP后台端：RESTful API接口设计</a></li>
</ul>
</li>
</ul>
<h2 id="4-常用开发工具"><a href="#4-常用开发工具" class="headerlink" title="4. 常用开发工具"></a>4. 常用开发工具</h2><ul>
<li>C：CLion （学习C语言时用到）</li>
<li>Python: PyCharm、Anaconda （学习Python语言时用到）</li>
<li>Java：Intellij IDEA、Maven （学习Java语言时用到）</li>
<li>web: VSCode、Git、Postman、Chrome webtool （开发web项目时用到）</li>
</ul>
<blockquote>
<p>上面提到的 CLion、PyCharm、Intellij IDEA都是 JetBrains 公司的 IDE 产品，该公司的产品是收费的，不过面向学生群体是免费的。<br><a href="https://sales.jetbrains.com/hc/zh-cn/articles/207154369-%E5%AD%A6%E7%94%9F%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F">学生授权申请方式</a><br>此文教大家如何申请学生授权</p>
</blockquote>
<h2 id="5-关注计算机行业"><a href="#5-关注计算机行业" class="headerlink" title="5. 关注计算机行业"></a>5. 关注计算机行业</h2><p>计算机本科生应该对本行业动态有足够的了解，建议阅读以下内容</p>
<ul>
<li>虎嗅网/虎嗅APP（侧重互联网等科技行业动态）: <a href="https://www.huxiu.com/">虎嗅网</a></li>
<li>36氪网/36氪APP（与虎嗅同类型的产品（两个平台上的文章绝非今日头条上的那种营销号爽文，是有很高阅读价值的））: <a href="https://36kr.com/">36氪_让一部分人先看到未来</a></li>
<li>v2ex（一个有趣的程序猿论坛）: <a href="https://www.v2ex.com/">V2EX</a></li>
<li>掘金（看看大神们在做什么）: <a href="https://juejin.im/">掘金 - juejin.im - 一个帮助开发者成长的社区</a></li>
<li>知乎（对于我这种五线城市男青年，不失为一个开阔眼界的好选择）: <a href="https://www.zhihu.com/hot">知乎 - 有问题，上知乎</a></li>
<li>阮一峰的网络日志（中文技术入门知识博客写的最好的人，对所有领域未知事物充满好奇心的终身学习者，阮一峰老师的博文可以把复杂难懂的知识点讲得很易懂，之后再深入学习就更容易上手；另外阮老师的《科技爱好者周刊》也是很值得一看）: <a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a></li>
</ul>
<hr>
<h2 id="6-关于怎么学？"><a href="#6-关于怎么学？" class="headerlink" title="6. 关于怎么学？"></a>6. 关于怎么学？</h2><ul>
<li>学习过程要多思考，多总结，建议多写博客，博客内容可以是『学习记录+知识点总结+进一步思考』</li>
<li>另外要有探索精神，无论是学习还是开发，总会有很多IDEA突然闪现在脑海，不要犹豫，可以去尽情搜索</li>
</ul>
<h2 id="7-时间线"><a href="#7-时间线" class="headerlink" title="7. 时间线"></a>7. 时间线</h2><p>上面有提到大一很少涉及专业课知识，更多地在学高数、线性代数、大学英语等公共课知识，所以我们姑且把从高考志愿出炉的七月末到大一下学期开学前都认为是在预习计算机专业。  </p>
<p>以上推荐的学习内容，学得越快越好，因为在学习过程中你能不断地发现新问题，知道自己应该去学什么新知识。  </p>
<ul>
<li>在开学前完成 编程语言入门 + 计算机基础知识</li>
<li>大一上学期完成 web技术栈 + 认真读一本某编程语言的书籍（外国译作最好）</li>
<li>大一下开学前的寒假完成 独立开发的一个项目 + 自己主动想学的知识</li>
<li>大一下学期开学后可以试着联系学校实验室老师。实验室项目有偏科研和偏工程两种，早些加入可以两种项目都有尝试也有利于尽早确定自己未来的目标（读研or工作）</li>
</ul>
<p>另外如果想先人一步在大二开始上专业课前对计算机四大基础学科有所基础，也可以暂缓加入实验室的计划（大二上再申请），而是在大一下学期去深入学习计算机底层知识（四大学科）</p>
<ul>
<li>计算机组成原理（比较抽象的一门课，相关的动手项目也比较少且抽象，建议多参考学习优秀的MOOC资源）</li>
<li>计算机网络（动手实现一个爬虫，可以做本校教务系统的爬虫，配合你的web知识做第三方教务查询系统）</li>
<li>操作系统（深入学习Linux相关知识，参照各种优秀的博客资源动手实现简单的Linux内核）</li>
<li>数据结构与算法（可以买一本考研王道数据结构书，通读一遍后到一些算法题网站去做做题（下面给出了链接））</li>
</ul>
<p>另外记住这一阶段不要再满足于百度搜到的各种教程，教程只能解一时之渴，要有计划地阅读计算机专业书籍，系统地深入地学习知识！</p>
<h2 id="8-为什么选择web作为入门领域？"><a href="#8-为什么选择web作为入门领域？" class="headerlink" title="8. 为什么选择web作为入门领域？"></a>8. 为什么选择web作为入门领域？</h2><p>长远来看，大家总会在某一个领域深入学习，这个领域可能是web开发，可能是后端架构，可能是算法工程师；当然也可能是计算机视觉，可能是NLP，可能是网络空间安全，可能是数据挖掘。只有在某一个领域学精才有可能有好的工作，有持续的科研产出。</p>
<blockquote>
<p>各行各业都是高端人才供不应求，中端人才供需平衡，初级人才供大于求的</p>
</blockquote>
<p>我们的职业发展目标就是成为<strong>领域专家</strong>，领域专家是创造者而非搬砖的码农，要不然你和培训班的同学又有什么区别呢？<br>web算是门槛很低很容易上手的一个领域，选择该领域作为对计算机软件行业的探索可以短时间内看到效果，且该过程涉及的计算机知识较广，有助于提高未来学习的信心。而后我们再去挑战难度更大更适合自己的领域！</p>
<h1 id="三、题外话"><a href="#三、题外话" class="headerlink" title="三、题外话"></a>三、题外话</h1><h2 id="1-英语及数学"><a href="#1-英语及数学" class="headerlink" title="1. 英语及数学"></a>1. 英语及数学</h2><p>怎么学都不过分，对于目标比较远大的同学来说（我就不是这种），虽然我不是大佬，但是还是可以根据自己的一些经验提些建议。  </p>
<ul>
<li>大一通过四六级是基本要求（不过有些学校可能不允许大一参加，没关系，尽快通过就行）</li>
<li>建议每天背单词（墨墨背单词 + 对应的单词书（根据自己的未来规划选择对应的单词书，托福/雅思，四六级，考研等等））</li>
<li>数学科目一定要拿高分（下面也有提到，数学科目学分高比重大，对四年总成绩影响极大（我就是因为考了好多门70多分的数学课导致目前处于保研边缘）。不过我觉得我认为我没考好其实不是没努力而是没找到正确的学习方法，或者说没能跟上老师的讲课思路（所以后面有建议去看考研数学视频，课程有趣不枯燥，老师总结的知识点比较凝练））</li>
<li>千万要重视 <strong>数学</strong> 和 <strong>英语</strong> 在计算机专业的重要性！即便你曾经数学或英语不好，但现在一切都来得及，找到正确的学习方法，遇到问题及时向老师同学或网络求助。</li>
</ul>
<h2 id="2-计算机软件专业推荐参加的竞赛"><a href="#2-计算机软件专业推荐参加的竞赛" class="headerlink" title="2. 计算机软件专业推荐参加的竞赛"></a>2. 计算机软件专业推荐参加的竞赛</h2><ul>
<li>专业类<ul>
<li>ICPC国际大学生程序设计竞赛（ACM）</li>
<li>“挑战杯”全国大学生课外学术科技作品竞赛/“创青春”全国大学生创业计划大赛</li>
<li>“互联网+”中国大学生创新创业大赛</li>
<li>中国大学生计算机设计大赛</li>
<li>“英特尔杯”全国大学生软件创新大赛</li>
<li>RoboMaster机器人大赛</li>
<li>全国大学生智能汽车竞赛</li>
<li>全国大学生信息安全竞赛</li>
<li>“蓝桥杯”全国软件和信息技术专业人才大赛</li>
<li>CCCC 中国高校微信小程序开发大赛</li>
<li>华为软件精英挑战赛</li>
</ul>
</li>
<li>数学类<ul>
<li>全国大学生数学建模竞赛</li>
<li>国际大学生数学建模竞赛（美赛）</li>
<li>全国大学生数学竞赛</li>
</ul>
</li>
<li>英语类<ul>
<li>“外研社杯”全国大学生英语辩论赛/全国大学生英语演讲比赛</li>
<li>全国大学生英语竞赛</li>
</ul>
</li>
</ul>
<h2 id="3-信息检索能力的重要性"><a href="#3-信息检索能力的重要性" class="headerlink" title="3. 信息检索能力的重要性"></a>3. 信息检索能力的重要性</h2><p>大学很多事情都是靠自己来争取来得到的，信息检索能力尤为关键，分享几个我探索出来的比较好用的方法：<br>（1）QQ寻人：有时候我们经常想联系一下某位学长学姐咨询一些事情，这个时候如果你平常加了很多QQ群就很有帮助，你可以直接在QQ搜索栏搜索学长学姐的名字，相信你和TA一定会至少有一个共用的群。这个方法我几乎百试百灵，每次都能加到很nice的学长学姐。<br>（2）百度高级搜索<br>我们经常想搜索一下学校历年发布的某项通知，这个时候可以利用百度的站内搜索来完成。<br>如下图所示，在搜索内容后加上  site:网站地址 就可以实现站内搜索，当然你也可以点击百度搜索那里的搜索工具来完成此操作。<br>迅速搜索到大量有价值的信息。</p>
<p><img src="pic1.jpg" alt="百度站内搜索我校2015级推免（保研）名单"></p>
<p>（3）整理好你的收藏夹<br>下面提到过我的Chrome收藏夹（这里建议大家平常就用Chrome浏览器吧，甚至选课还有速度加成）存了五百多个网站链接，我自觉还是挺有用的，我分别按照以下几类进行了存储：  </p>
<ul>
<li>编程<ul>
<li>论坛</li>
<li>博客</li>
<li>技术</li>
<li>工具</li>
<li>教程</li>
<li>其他</li>
</ul>
</li>
<li>学习<ul>
<li>竞赛</li>
<li>课程</li>
<li>美赛</li>
<li>论文</li>
<li>英语</li>
</ul>
</li>
<li>校内<ul>
<li>常用校内网站</li>
<li>信息量巨大的通知</li>
</ul>
</li>
<li>生活<ul>
<li>娱乐</li>
<li>办公</li>
</ul>
</li>
</ul>
<p>我私以为收藏夹还是很有帮助的。</p>
<p>（4）学会科学上网</p>
<blockquote>
<p>此处省略500字…</p>
</blockquote>
<h2 id="4-转专业"><a href="#4-转专业" class="headerlink" title="4. 转专业"></a>4. 转专业</h2><p>很多同学都在评论区里询问有关转专业的事情，首先我认为对于想转入计算机专业的同学，大一一定要努力学习拿到转专业资格，另外也不用太担心关于大一学年少学了计算机知识课程的问题，很多学校大一学年基本上都在学公共课程，专业课涉及的很少。<br>另外我还想放出一张比较有代表性的表格，我统计了我们学校今年刚刚完成的2018级的转专业结果，大家可以一窥整个转专业的趋势，热门专业都是用脚投票投出来的。  </p>
<p><img src="pic2.jpg" alt="我校2019年部分学院转专业情况一览"></p>
<p>大部分转专业的学霸选择了我校最强的自动化以及计算机、软件、机器人这样的热门专业，这些信息学科的热门程度在我校已经超过了另一热门领域（经济工商管理等）。<br>而像冶金、资土、机械、材料这些我校实力也很强的学院在转专业季节或许有些尴尬。<br>这种情况还是非常普遍的，再来让我们一窥清华的转专业情况。  </p>
<ul>
<li><a href="https://www.zhihu.com/question/320762145/answer/661155254">如何评价清华大学2019年转专业结果？</a></li>
</ul>
<blockquote>
<p>清华2019年转专业报名人数大于计划接收人数的专业有：<br>计算机科学与技术、计算机科学与技术（姚班）、信息管理与信息系统、软件工程、车辆工程（机械航空动力方向）、工业工程、建筑学；经济学、经济与金融、会计学、政治学经济学与哲学（新雅书院）、法学、心理学、汉语言文学、社会学。<br>看专业名盲猜我们也知道当今的热门就是「信息技术 + 经济管理」</p>
</blockquote>
<h2 id="5-人工智能"><a href="#5-人工智能" class="headerlink" title="5. 人工智能"></a>5. 人工智能</h2><p>人工智能绝对是目前计算机行业最最热门的方向，不过对于学习方法我了解不多，可以移步至下面问题的回答：</p>
<ul>
<li><a href="https://www.zhihu.com/question/21277368">如何自学人工智能？</a></li>
</ul>
<p>另外不得不说地是人工智能里的某些方向，例如计算机视觉已经内卷到过于夸张，如果 2020 年才开始读大一，我倒是觉得可以考虑下一个风口了~</p>
<h2 id="6-Macbook-Pro-值得入手吗？"><a href="#6-Macbook-Pro-值得入手吗？" class="headerlink" title="6. Macbook Pro 值得入手吗？"></a>6. Macbook Pro 值得入手吗？</h2><p>对于计算机相关专业的你，<strong>绝对值得</strong>。<br>我是大三转投 macOS 阵营的，真的是用上后就再也回不去了。</p>
<h2 id="7-ACM"><a href="#7-ACM" class="headerlink" title="7. ACM"></a>7. ACM</h2><p>有做过一些入门题后来就放弃了，我对ACM的看法是有些人比如我应该就是智商不适合吧，如果觉得自己能力不够的话就不要浪费时间了，下面这个博文是当初一位学长分享给我们的，干货满满。</p>
<ul>
<li><a href="https://blog.csdn.net/code4101/article/details/40748663">我对ACM初学者想说的话</a></li>
</ul>
<h2 id="8-实习与工作"><a href="#8-实习与工作" class="headerlink" title="8. 实习与工作"></a>8. 实习与工作</h2><p>答主在大四十月份申请到了某大厂的实习，还顺道在此完成了毕业设计，对于读研的同学来说，因为研究生实验室很有可能不让实习，所以利用大四去实习是很好的选择。  </p>
<p>实习信息可以直接关注各大厂招聘官网以及牛客网、BOSS直聘等渠道，在内推泛滥的年代，在牛客网上随便找找都能找到各家的内推码。  </p>
<p>如果想直接就业的话当然是越早出来实习越好，最早的话可以在大三上学期就开始了，如果这个时候就能找到一份很不错的实习，证明你的实力和潜力是绝对很不错的！  </p>
<p>如果很明确想本科毕业之后就工作，可以早早地就为面试做准备，下面这篇经典博文讲的很好：</p>
<ul>
<li><a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">怎样花两年时间去面试一个人 - 刘未鹏</a></li>
</ul>
<p>结合文中所列，我也整理出一份必读书单（有些书真的不适合初学者阅读，不必硬啃，可以先选择容易上手的书）</p>
<ul>
<li>操作系统<ul>
<li>鸟哥的LINUX私房菜</li>
<li>UNIX 环境高级编程</li>
<li>Unix 编程艺术</li>
<li>Linux内核设计与实现</li>
<li>现代操作系统</li>
</ul>
</li>
<li>计算机网络<ul>
<li>网络是怎样连接的</li>
<li>图解TCP/IP</li>
<li>TCP/IP 详解</li>
<li>计算机网络自顶向下方法</li>
<li>Unix 网络编程</li>
</ul>
</li>
<li>计算机体系结构<ul>
<li>深入理解计算机系统</li>
<li>计算机体系结构精髓</li>
</ul>
</li>
<li>数据结构与算法<ul>
<li>剑指Offer</li>
<li>编程之美</li>
<li>计算机程序设计艺术</li>
<li>算法导论</li>
<li>算法</li>
</ul>
</li>
<li>设计模式<ul>
<li>程序员修炼之道</li>
<li>代码大全</li>
<li>Head First 设计模式</li>
<li>编程珠玑</li>
</ul>
</li>
<li>软件工程<ul>
<li>人件</li>
<li>你的灯亮着吗</li>
<li>人月神话</li>
</ul>
</li>
<li>编译原理<ul>
<li>计算机程序的构造和解释</li>
<li>编译原理</li>
</ul>
</li>
<li>数据库<ul>
<li>数据库系统概念</li>
<li>高性能 MySQL</li>
</ul>
</li>
</ul>
<h2 id="9-高质量代码"><a href="#9-高质量代码" class="headerlink" title="9. 高质量代码"></a>9. 高质量代码</h2><ul>
<li>原则<ul>
<li>提前设计（想好了再写，不要急于开始）</li>
<li>精简为上（能用一行绝对不用两行。当然也要把握好“度”，有时候适当的冗余也会让语义更清晰）</li>
<li>积累经验（写得少肯定不行）</li>
<li>学习他人（多看看优秀项目的源码。FreeRTOS，Nginx，Redis, Git）</li>
</ul>
</li>
<li>实践<ul>
<li>利用版本控制工具，自动化部署与监控等工具管理项目</li>
<li>注重代码风格，遵守一定的规范</li>
<li>配置风格检查，单元测试，测试覆盖率等工具对项目质量做出硬性管理</li>
</ul>
</li>
<li>可以参考 Google 的 code style<ul>
<li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/contents/">内容目录 - Google 开源项目风格指南</a></li>
</ul>
</li>
</ul>
<h2 id="10-保研"><a href="#10-保研" class="headerlink" title="10. 保研"></a>10. 保研</h2><p>相比考研，保研还是非常香的，很大概率去到更好的学校，优先选择更喜欢的老师，拿更高的新生奖学金。<br>有关如何保研简要概括就是  </p>
<ul>
<li>大一就得卷起来~成绩在前列；</li>
<li>大二开始找老师做做研究；</li>
<li>暑假及大三上收割论文专利和竞赛；</li>
<li>大三下联系老师参加夏令营预推免；</li>
<li>大四上爽玩半年，岁月静好，人生值得；</li>
<li>大四下提前进组做做毕设或者出去实习。</li>
</ul>
<h2 id="11-转载"><a href="#11-转载" class="headerlink" title="11. 转载"></a>11. 转载</h2><p>我在知乎简单搜索后发现至少有50多条与本问题相似的问题，看来的确计算机相关专业的同学都很有竞争意识，也知道热门行业也更大。当然从中我也发现了不少其他答主的优秀回答，列一下让我产生一定共鸣且认同的回答：</p>
<ul>
<li><a href="https://www.zhihu.com/question/283204710/answer/438417871">准大一 选择了计算机科学与技术专业 打算将来读研 暑假该怎么预习？</a></li>
<li><a href="https://www.zhihu.com/question/334168870/answer/747905904">准大学生开学学计算机科学与技术，为了更好地适应，现在应该预习什么？</a></li>
<li><a href="https://www.zhihu.com/question/21226658/answer/17881066">未来报考计算机科学与技术，买什么书来预习？</a></li>
<li><a href="https://www.zhihu.com/question/24188466/answer/774631139">准大学生，如何预习计算机专业？</a></li>
</ul>
<blockquote>
<p>最后一个链接是一位华科学长从就业角度对我的答案的评价。<br>随着本回答的赞数越来越多我也感到很惶恐，生怕误导大家。总之我认为学长说的很对，经验教程永远都是光鲜亮丽的，可是人与人的执行力不同，我就是执行力很低的人也因此错过了很多机会。千万不要只是收藏了本文然后就没有然后了，希望大家能真正通过本文知道我所想传达的核心理念：</p>
<ul>
<li>培养兴趣，学会用电脑</li>
<li>关注行业，你所处的行业是一个无与伦比的潜能在不断释放的行业</li>
<li>多与前辈交流，找到引路的学长学姐，少走弯路</li>
<li>提高自己的执行力，越早出发你会有更多试错成本，一旦步入正轨你将跑得越来越快（而本文第一点所列出的预习方案就是为大家在本专业的探索做一个初步指引，未来的路还需各自努力）</li>
</ul>
</blockquote>
<h1 id="四、网站推荐"><a href="#四、网站推荐" class="headerlink" title="四、网站推荐"></a>四、网站推荐</h1><p>我的Chrome收藏夹大概收藏了500多个网站链接，我选出我认为比较好的且比较通用的网站如下</p>
<h2 id="1-程序员必备"><a href="#1-程序员必备" class="headerlink" title="1. 程序员必备"></a>1. 程序员必备</h2><ul>
<li><a href="https://github.com/">Github</a></li>
<li><a href="https://hexo.io/zh-cn/">hexo博客（为自己搭建一个博客）</a></li>
<li><a href="http://stackoverflow.com/">Stackoverflow（在线技术问答）</a></li>
<li><a href="https://segmentfault.com/">segmentfault （同上，国内的）</a></li>
<li><a href="https://www.google.com.hk/">Google</a></li>
</ul>
<blockquote>
<p>曾经一度以为别人鼓吹 Google 和 Stack Overflow 是在装B，不过在两者帮助我解决了一个又一个 bug 后才发现是自己太年轻。</p>
</blockquote>
<h2 id="2-MOOC"><a href="#2-MOOC" class="headerlink" title="2. MOOC"></a>2. MOOC</h2><ul>
<li><a href="https://study.163.com/curricula/cs.htm">网易云课堂（这个链接打开后是一个顶尖中文大学计算机专业课程体系）</a></li>
<li><a href="https://www.icourse163.org/">中国大学MOOC</a></li>
<li><a href="http://www.xuetangx.com/">学堂在线（清华出品的MOOC）</a></li>
<li><a href="https://www.coursera.org/">Coursera（英文MOOC学习资源）</a></li>
<li><a href="http://yun.itheima.com/course">传智播客黑马程序员免费视频库（培训班风格的技术视频）</a></li>
<li><a href="https://time.geekbang.org/">极客时间（强烈安利《数据结构与算法之美 - 王争》）</a></li>
<li><a href="https://www.bilibili.com/">B站（收录了很多优秀资源，当遇到问题且看不太懂文字教程而是希望有视频的讲解形式时到B站搜搜总有意想不到的惊喜）</a></li>
<li><a href="https://www.youtube.com/?gl=HK">YouTube（与B站类似，很多中英文免费教程，配合着Google实时翻译字幕还是可以食用的）</a></li>
</ul>
<blockquote>
<p>另外在油管或多或少地会接触一些『皿煮滋油』的视频，我只能说三年来在油管上的所见所闻加上去认真检索很多历史资料、与身边同学交流等等，这些都没有让我羡慕西方那套理论，而更加发觉我们的社会，国家，政党的优越性。</p>
</blockquote>
<ul>
<li><a href="http://www.iqihang.com/">爱启航（考研视频）</a><blockquote>
<p>对爱启航等考研视频做一个补充。大学期间数学科目的成绩对你的总体成绩影响很大，可以说高数线代概率论离散数学等数学科目的学习决定了你大学的成败（成绩排名、能否进入实验室，能否保研）。所以一定要万分重视数学科目的学习！<br>而恰巧我发现考研数学的这些视频讲解得极其精炼，例如张宇的视频，如果你的高数老师讲课讲得云里雾里，完全可以同步利用这些视频来学习！！！</p>
</blockquote>
</li>
</ul>
<h2 id="3-在线编程练习（主要是算法题）"><a href="#3-在线编程练习（主要是算法题）" class="headerlink" title="3. 在线编程练习（主要是算法题）"></a>3. 在线编程练习（主要是算法题）</h2><ul>
<li><a href="https://www.nowcoder.com/">牛客网</a></li>
<li><a href="https://leetcode-cn.com/">leetcode</a></li>
<li><a href="http://poj.org/problemlist">POJ</a></li>
<li><a href="https://www.shiyanlou.com/">实验楼</a></li>
</ul>
<h2 id="4-小工具（总有一天这些工具会有用武之地）"><a href="#4-小工具（总有一天这些工具会有用武之地）" class="headerlink" title="4. 小工具（总有一天这些工具会有用武之地）"></a>4. 小工具（总有一天这些工具会有用武之地）</h2><ul>
<li><a href="http://paste.ubuntu.com/">代码分享（避免在QQ中直接发给别人代码可读性太差）</a></li>
<li><a href="http://tool.oschina.net/">在线工具</a></li>
<li><a href="https://www.foxebook.net/">免费电子书</a></li>
<li><a href="https://processon.com/">ProcessOn（在线作图）</a></li>
<li><a href="http://pygments.org/">word代码高亮（用于使word报告更好看）</a></li>
<li><a href="https://www.ilovepdf.com/">PDF工具</a></li>
<li><a href="http://www.officeplus.cn/Template/Home.shtml">微软官方office模板</a></li>
<li><a href="https://docs.qq.com/">腾讯文档（越来越好用的协作软件）</a></li>
<li><a href="https://www.tutorialspoint.com/unix_terminal_online.php">在线Linux虚拟机</a></li>
<li><a href="https://www.iconfont.cn/">iconfont（免费图标站，用在自己的前端项目或者PPT等doc里）</a></li>
<li><a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/">Vue-element-admin（非常好用的后台前端解决方案，实验课再也不愁了）</a></li>
</ul>
<h2 id="5-学术论文"><a href="#5-学术论文" class="headerlink" title="5. 学术论文"></a>5. 学术论文</h2><ul>
<li><a href="http://www.cnki.net/">知网</a></li>
<li><a href="https://link.springer.com/">Springer</a></li>
<li><a href="http://xueshu.baidu.com/">百度学术</a></li>
<li><a href="https://scholar.google.com.hk/">Google学术</a></li>
<li><a href="https://www.ccf.org.cn/">中国计算机学会</a></li>
<li><a href="https://cn.overleaf.com/">Overleaf（在线LaTeX）</a></li>
<li><a href="http://muchong.com/bbs/">小木虫</a></li>
<li><a href="https://dblp.uni-trier.de/db/">dblp</a></li>
<li><a href="https://www.aminer.cn/">Aminer（学术知识图谱）</a></li>
<li><a href="https://www.researchgate.net/">ResearchGate（科研人员社交平台）</a></li>
</ul>
<h2 id="6-大学生活"><a href="#6-大学生活" class="headerlink" title="6. 大学生活"></a>6. 大学生活</h2><ul>
<li><a href="https://www.saikr.com/">赛氪（竞赛活动信息大全）</a></li>
<li><a href="https://mobile.alipay.com/index.htm">支付宝大学生优惠（完成学生认证后享受海底捞6.9折等）</a></li>
</ul>
<h2 id="7-影音文学"><a href="#7-影音文学" class="headerlink" title="7. 影音文学"></a>7. 影音文学</h2><p>毕竟是假期，还是高考结束后的悠长暑假，休息好才能更好地迎接开学~</p>
<ul>
<li>影视<ul>
<li><a href="http://v.qq.com/detail/i/ijilh0frmu96sbf.html?ptag=baidu.aladdin.tv">《硅谷》（爱到不行的美剧，HBO出品）</a></li>
<li><a href="https://v.youku.com/v_show/id_XMzA3OTYzMzc2.html?refer=seo_operation.liuxiao.liux_00003303_3000_Qzu6ve_19042900">《社交网络》（非官方的Facebook诞生历史，很好地刻画了小扎阴阳人的一面）</a></li>
<li><a href="http://v.qq.com/detail/m/mtkp03xoh95iijk.html?ptag=10520">《我是谁 没有绝对安全的系统》</a></li>
<li><a href="http://compaign.tudou.com/v/XMjEzODYwNjk1Ng==">《代码的奔腾》</a></li>
<li><a href="https://www.zhihu.com/question/20852787/answer/73312148">冬阳的知乎回答</a></li>
</ul>
</li>
<li>图书<ul>
<li><a href="https://book.douban.com/subject/6798611/">《乔布斯传》</a></li>
<li><a href="https://book.douban.com/subject/6709783/">《浪潮之巅》</a></li>
<li><a href="https://www.zhihu.com/question/22965065/answer/568712193">黄小斜的知乎回答</a></li>
</ul>
</li>
</ul>
<hr>
<p>总而言之，我选择计算机专业是因为我认为它是最有可能实现我「改变世界」梦想的专业，至少未来能有不错的薪资~<br>祝愿各位能在这个暑假，乃至整个大一期间培养起自己对计算机的兴趣，利用课余时间自己做一些很酷的项目，尽快为自己的未来发展做以规划。<br><strong>相信我，未来的四年一定会很美好！有缘再见~</strong></p>
]]></content>
      <categories>
        <category>杂文随笔</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器入门</title>
    <url>/a.%E6%8A%80%E6%9C%AF%E6%8E%A2%E7%A9%B6/History/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="（一）我的第一台服务器"><a href="#（一）我的第一台服务器" class="headerlink" title="（一）我的第一台服务器"></a>（一）我的第一台服务器</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>本学期选修了“Linux操作系统”课程。课上老师教大家利用传统的VMware + OS镜像方式在本机上体验Linux系统，但为了获得更优体验我选用了云服务器来学习Linux。</p>
<p>使用云服务器对这门课的学习也有几点好处：</p>
<ul>
<li><p>最终的大作业可以搭建在线的服务器，真正投入生产环境</p>
</li>
<li><p>再也不用开虚拟机了，拯救电脑那点可怜的内存</p>
</li>
</ul>
<span id="more"></span>

<h2 id="2-什么是云服务器？"><a href="#2-什么是云服务器？" class="headerlink" title="2. 什么是云服务器？"></a>2. 什么是云服务器？</h2><blockquote>
<p>云服务器 Elastic Compute Service（ECS）是云服务器提供商提供的一种基础云计算服务。使用云服务器 ECS 就像使用水、电、煤气等资源一样便捷、高效。我们无需提前采购硬件设备，而是根据业务需要，随时创建所需数量的云服务器实例，并在使用过程中，随着业务的扩展，对云服务器进行扩容磁盘、增加带宽。如果不再需要云服务器，也可以方便的释放资源，节省费用。       </p>
</blockquote>
<blockquote>
<p>云服务器 ECS 实例是一个虚拟的计算环境，包含了 CPU、内存、操作系统、磁盘、带宽等最基础的服务器组件，是 ECS 提供给每个用户的操作实体。一个实例就等同于一台虚拟机，您对所创建的实例拥有管理员权限，可以随时登录进行使用和管理。您可以在实例上进行基本操作，如挂载磁盘、创建快照、创建镜像、部署环境等。  </p>
</blockquote>
<blockquote>
<p>正如马云所言，未来的云服务器就是社会的基础设施，就像我们打开水龙头就可以用水一样，我们也可以随时根据我们的需求使用我们的服务器。</p>
</blockquote>
<h2 id="3-云服务器的选择"><a href="#3-云服务器的选择" class="headerlink" title="3. 云服务器的选择"></a>3. 云服务器的选择</h2><p>前几日，一篇<a href="https://zhuanlan.zhihu.com/p/46884081">《阿里云的这群疯子》</a>迅速在网络上传播开来，这篇文章有血有肉，有真实历史中的困难，也有克服困难后的信心重建。是近年来非常出色的一篇关于阿里云发展的报道。阿里云是目前国内最大的云服务器提供商，市场份额近50%，同时也是全球第三大云服务器提供商，仅次于亚马逊和微软。那么我们就选择比较让我们国内的程序员感到自豪的阿里云吧！</p>
<h2 id="4-云服务器的购买"><a href="#4-云服务器的购买" class="headerlink" title="4. 云服务器的购买"></a>4. 云服务器的购买</h2><p>阿里云、腾讯云等国内大公司都提供了学生优惠的价格。  </p>
<p><a href="https://promotion.aliyun.com/ntms/act/campus2018.html?utm_content=se_1000442290">点击进入阿里云“云翼计划”学生优惠界面</a>  </p>
<p>过程还比较简单啦，前三步是进行验证，第四部步进入如下所示的界面，终于要开始买我们的服务器啦！  </p>
<img src="https://s1.ax1x.com/2018/10/19/iwOPWn.jpg" align=center width=500 alt="https://s1.ax1x.com/2018/10/19/iwOPWn.jpg"/>

<p>在这一页我们有几个选择，我用标号标记出来了。  </p>
<ol>
<li><p>我们选择<strong>云服务器ECS</strong>。“轻量应用服务器”预装了一些工具，比如搭建博客的WordPress，写PHP的LAMP套件组合等等。我们想要一个全新的服务器，所以选择云服务器ECS就好，我们自己来安装。</p>
</li>
<li><p>选择比较主流的CentOS啦~用Ubuntu的同学也不用担心，云服务器一般就只有命令行啦，是没有图形界面的，选择CentOS没有什么过渡，可能默认下载工具命令会有所不同。</p>
</li>
<li><p>我们是东北，看起来华北和华东离我们都比较近，随便选一个吧，选华北。</p>
</li>
<li><p>先买一个月的吧。只要9.5哎！真的是很便宜的价格了。阿里云有学生认证可以买多次，腾讯云则是有次数限制的。</p>
</li>
<li><p>点击立即购买去付款就好啦~</p>
</li>
</ol>
<h2 id="5-云上初体验"><a href="#5-云上初体验" class="headerlink" title="5. 云上初体验"></a>5. 云上初体验</h2><p>购买成功后我们进入控制台页面，如下图</p>
<p><img src="https://s1.ax1x.com/2018/10/19/iwO0SI.png" alt="阿里云控制台"></p>
<p>我们主要关注的就是我用箭头标注出来的那个公网IP，接下来，我们就要远程登录到这个IP地址啦！</p>
<h1 id="（二）Windows用户上云"><a href="#（二）Windows用户上云" class="headerlink" title="（二）Windows用户上云"></a>（二）Windows用户上云</h1><h2 id="1-背景-1"><a href="#1-背景-1" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>恭喜你已经成功购买了阿里云服务器！</p>
<p>众所周知，Windows的命令行功能不多和Unix完全不一样，这也就决定了我们Windows用户不能直接通过CMD来SSH远程连接到云服务器。在此向使用Windows的同学推荐Windows下的上云利器“putty+winscp”的组合方案。   </p>
<p>另外，VSCode也有大量的辅助我们与云服务器交互的插件，感兴趣的同学也可以看一下「云服务器入门（三）Mac用户上云」，里面所提到的VSCode插件在Windows下也可以使用！</p>
<h2 id="2-putty"><a href="#2-putty" class="headerlink" title="2. putty"></a>2. putty</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><blockquote>
<p>PuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件。较早的版本仅支持Windows平台，在最近的版本中开始支持各类Unix平台，并打算移植至Mac OS X上。除了官方版本外，有许多第三方的团体或个人将PuTTY移植到其他平台上，像是以Symbian为基础的移动电话。PuTTY为一开放源代码软件，主要由Simon Tatham维护，使用MIT licence授权。随着Linux在服务器端应用的普及，Linux系统管理越来越依赖于远程。在各种远程登录工具中，Putty是出色的工具之一。Putty是一个免费的、Windows x86平台下的Telnet、SSH和rlogin客户端，但是功能丝毫不逊色于商业的Telnet类工具。 ——《百度百科》  </p>
</blockquote>
<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><blockquote>
<p><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">putty下载链接</a>  </p>
</blockquote>
<blockquote>
<p>根据电脑实际选择32/64位下载就ok啦~</p>
</blockquote>
<blockquote>
<p><img src="https://s1.ax1x.com/2018/10/19/iwOqk4.png" alt="putty下载界面"></p>
</blockquote>
<blockquote>
<p>安装过程不赘述。</p>
</blockquote>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>见「云服务器入门（四）」</p>
<h2 id="3-WinSCP"><a href="#3-WinSCP" class="headerlink" title="3. WinSCP"></a>3. WinSCP</h2><blockquote>
<p>WinSCP是一个Windows环境下使用SSH的开源图形化SFTP客户端。同时支持SCP协议。它的主要功能就是在本地与远程计算机间安全的复制文件。winscp也可以链接其他系统,比如linux系统。WinSCP可以执行所有基本的文件操作，例如下载和上传。同时允许为文件和目录重命名、改变属性、建立符号链接和快捷方式。甚至还可以在线编辑文件内容。</p>
</blockquote>
<h3 id="下载安装-1"><a href="#下载安装-1" class="headerlink" title="下载安装"></a>下载安装</h3><blockquote>
<p><a href="https://winscp.net/eng/download.php">WinSCP下载链接</a>  </p>
</blockquote>
<blockquote>
<p>这个进去后直接下载就行。</p>
</blockquote>
<blockquote>
<p><img src="https://s1.ax1x.com/2018/10/19/iwXUBT.png" alt="WinSCP下载界面"></p>
</blockquote>
<blockquote>
<p>安装过程不赘述。</p>
</blockquote>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li><p>打开WinSCP</p>
</li>
<li><p>输入主机名(IP)和用户名及密码，WinSCP会帮你记住，下次就可以直接登录啦。   <img src="https://s1.ax1x.com/2018/10/19/i0ZeiR.png" alt="WinSCP配置"></p>
</li>
<li><p>进入操作界面。界面分为两部分，左侧是Windows的文件资源管理器，右侧是服务器的目录。<br><img src="https://s1.ax1x.com/2018/10/19/i0Zuz6.png" alt="WinSCP界面"></p>
</li>
</ol>
<p>这样我们就可以愉快地拖拽文件上传到服务器啦~当然也可以从服务器上下载文件；</p>
<p>另外，我们还可以直接右键点击服务器上的文件选择编辑，对于vim使用不熟练的我来说可以这样编辑文件真是太爽了~~</p>
<h1 id="（三）Mac用户上云"><a href="#（三）Mac用户上云" class="headerlink" title="（三）Mac用户上云"></a>（三）Mac用户上云</h1><h2 id="1-背景-2"><a href="#1-背景-2" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>恭喜你已经成功购买了阿里云服务器！  </p>
<p>众所周知，macOS是基于Unix开发的，所以mac自带的命令行已经能满足我们大部分的使用需求啦。今天我们来探讨一下如何更优雅的在Mac上连接远程服务器。</p>
<p>macOS系统下普遍吐槽没有很好用的SCP应用（也有可能是我还没发现）。用推荐比较多的FileZilla后发现也不如Windows下强大的WinSCP。  </p>
<p>说起WinSCP，最让我怀念它的倒不是极其方便的上传文件功能，毕竟scp命令也没多长，不用工具也可以解决，而是它可以右键服务器上的文件进行在线编辑，感觉比较方便。（对于vim掌握不熟练的我来说）</p>
<p><img src="https://s1.ax1x.com/2018/11/12/iLQWDO.png" alt="image-20181021165826871"></p>
<p>突发奇想，想看看我们越来越流行，越来越强大的VSCode有没有好的解决方案，还真的搜到了~~~在美国简书Medium上找到了一篇（原文作者和我有很相似的历程hh）：</p>
<p><a href="https://medium.com/@prtdomingo/editing-files-in-your-linux-virtual-machine-made-a-lot-easier-with-remote-vscode-6bb98d0639a4">Editing files in your Linux Virtual Machine made a lot easier with Remote VSCode</a></p>
<h2 id="2-Remote-VSCode"><a href="#2-Remote-VSCode" class="headerlink" title="2. Remote VSCode"></a>2. Remote VSCode</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li><p>本地：macOS+VSCode</p>
</li>
<li><p>服务器：CentOS 7.3</p>
</li>
</ul>
<h3 id="VSCode内安装插件"><a href="#VSCode内安装插件" class="headerlink" title="VSCode内安装插件"></a>VSCode内安装插件</h3><ol>
<li><p>打开VSCode<a href="https://code.visualstudio.com/">VSCode下载</a></p>
</li>
<li><p>进入插件页，搜索“Remote VSCode”  </p>
</li>
</ol>
<p><img src="https://s1.ax1x.com/2018/11/12/iLQRKK.png" alt="image-20181021165629137"></p>
<ol start="3">
<li>安装插件并重启VSCode</li>
</ol>
<h3 id="服务器上安装rmate组件"><a href="#服务器上安装rmate组件" class="headerlink" title="服务器上安装rmate组件"></a>服务器上安装rmate组件</h3><ol>
<li><p>打开服务器，并执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo wget -O /usr/<span class="built_in">local</span>/bin/rmate https://raw.github.com/aurora/rmate/master/rmate</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chmod a+x /usr/<span class="built_in">local</span>/bin/rmate</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="VSCode内使用这一插件"><a href="#VSCode内使用这一插件" class="headerlink" title="VSCode内使用这一插件"></a>VSCode内使用这一插件</h3><ol>
<li>回到VSCode打开命令窗<code>Command + Shift + P</code>并执行 <code>Remote: Start Server</code></li>
</ol>
<blockquote>
<p>（这一步是开启macOS的52698端口，保持TCP连接，等待请求）</p>
</blockquote>
<ol start="2">
<li><p>OK之后，在VSCode内打开一个新的终端输入以下命令连接到你的Linux服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -R 52698:localhost:52698 VIRTUAL_MACHINE_IP_ADDRESS</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> （VIRTUAL_MACHINE_IP_ADDRESS 就是你的服务器IP地址）</span></span><br></pre></td></tr></table></figure></li>
<li><p>在你的VSCode终端内，执行rmate命令来编辑你想编辑的文件。会看到服务器上的文件内容会在VSCode里面自动就显示出来啦<del>这时你再保存也是同步保存到服务器上的。你也同样可以在VSCode的终端里执行命令比如 python test.py 之类。也就是说只需要一个VSCode就可以完成连接、编辑、保存、执行操作。（就差一个SFTP上传了</del>，SFTP上传插件也找到了，这个暂时没需求，下次再试一下嘿嘿）<br><img src="https://s1.ax1x.com/2018/11/12/iLQcgx.png" alt="image-20181021170337024"></p>
</li>
</ol>
<h3 id="为什么是52698"><a href="#为什么是52698" class="headerlink" title="为什么是52698?"></a>为什么是52698?</h3><p>52698是Remote VSCode插件的默认端口，你可以在“User Preference”页面内搜索”Remote VSCode configuration”来改变它。</p>
<p><img src="https://s1.ax1x.com/2018/11/12/iLQ681.png" alt="image-20181021170055557"></p>
<h2 id="3-iTerm2"><a href="#3-iTerm2" class="headerlink" title="3. iTerm2"></a>3. iTerm2</h2><p>另外再推荐一款命令行软件“<strong>iTerm2</strong>”。iTerm甚至可以说是Mac下开发的必备软件~</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>iTerm2 is a replacement for Terminal and the successor to iTerm. It works on Macs with macOS 10.10 or newer. iTerm2 brings the terminal into the modern age with features you never knew you always wanted.</p>
</blockquote>
<blockquote>
<p>iTerm 2 有很多能够提升效率的实用功能。比如说窗口分割、热键窗口、智能搜索、自动完成、快速复制等等。</p>
</blockquote>
<h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><h4 id="下载安装-2"><a href="#下载安装-2" class="headerlink" title="下载安装"></a>下载安装</h4><p><a href="https://www.iterm2.com/">iTerm2下载链接</a></p>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>推荐最多的一款主题叫Solarized。这款主题有它自己的官网，同时支持主流的editor和IDE。主题配置步骤如下： </p>
<ol>
<li><p>官网下载主题压缩包，<a href="http://ethanschoonover.com/solarized/files/solarized.zip">下载链接</a>。 </p>
</li>
<li><p>下载后解压，然后按 <code>⌘，</code>，打开iTerm2的Preferences，接着<code>Profiles -&gt; Colors -&gt; Color Presets -&gt; Import</code>，选择刚解压的文件夹<code>solarized/iterm2-colors-solarized</code>下的<code>Solarized Dark.itermcolors</code>文件。 </p>
</li>
<li><p>在Color Presets 下拉菜单中选中 Solarized Dark 主题，大功告成。 </p>
</li>
<li><p>配置截图如下：<br><img src="https://s1.ax1x.com/2018/10/19/iwvlSs.png" alt="配置截图"></p>
</li>
<li><p>成功后是这样的：<br><img src="https://s1.ax1x.com/2018/10/19/iwvMWj.png" alt="最终效果"></p>
</li>
<li><p>当然啦，现在的字体还不够美观。我们在GitHub或者Google上能搜到无数其他的外观配置方案，就留给大家去探索啦~</p>
</li>
</ol>
<h4 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h4><ol>
<li><p><code>⌘+T</code> 打开一个新的标签页</p>
</li>
<li><p><code>⌘+;</code> 弹出自动补齐窗口</p>
</li>
<li><p><code>⌘+Shift+;</code> 弹出历史命令记录窗口</p>
</li>
<li><p><code>⌘+Shift+H</code> 弹出历史粘贴记录窗口</p>
</li>
<li><p><code>⌘+←</code>、<code>⌘+→</code>、 <code>⌘+&#123;, ⌘+&#125;</code>、<code>⌘+&lt;number&gt;</code> 切换标签页</p>
</li>
<li><p><code>⌘+F</code> 智能查找，支持正则查找</p>
</li>
<li><p><code>⌘+[</code>、<code>⌘+]</code>、<code>⌘+Option+方向键</code> 切换 pane</p>
</li>
<li><p><code>⌘+D</code> 水平切分屏幕，<code>⌘+Shift+D</code> 垂直切分屏幕</p>
</li>
<li><p><code>⌘+Enter</code> 进入与返回全屏模式</p>
</li>
</ol>
<h1 id="（四）云服务器基本使用"><a href="#（四）云服务器基本使用" class="headerlink" title="（四）云服务器基本使用"></a>（四）云服务器基本使用</h1><h2 id="1-背景-3"><a href="#1-背景-3" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>先总结一下（二）和（三）的目的：</p>
<blockquote>
<p>因为我们要远程访问我们的服务器，所以我们需要一些工具(shell)去和它进行交互。</p>
<p>Windows下因为Windows的CMD或者说powershell不支持Unix/Linux系统的那些bash命令，所以我们需要一款支持这些命令的软件“putty”去帮助我们。  </p>
</blockquote>
<blockquote>
<p>同时，因为我们经常会有向服务器上传/下载文件的需求，所以我们用WinSCP这款工具去帮助我们。  </p>
</blockquote>
<blockquote>
<p>对于Mac用户来讲呢，因为macOS就是基于Unix开发的，所以在Mac自带的终端内直接ssh就可以连接到云服务器啦。但是自带的终端略丑且功能称不上强大，所以我们用最流行的Mac下的终端软件“iTerm”去帮助我们获得更好的体验。  </p>
</blockquote>
<blockquote>
<p>同时对于喜爱VSCode的同学，我们还介绍了一款插件去让我们所有的工作全部在VSCode完成。</p>
</blockquote>
<h2 id="2-登录"><a href="#2-登录" class="headerlink" title="2. 登录"></a>2. 登录</h2><ol>
<li><p>开启终端（iTerm2/putty，本文使用的是iTerm2）<br>​    <img src="https://s1.ax1x.com/2018/10/19/iwxaHf.png" alt="终端界面"></p>
</li>
<li><p>SSH远程连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh Your_Server_IP_Address</span><br></pre></td></tr></table></figure></li>
<li><p>输入用户名和密码</p>
</li>
<li><p>成功登陆啦！看到了阿里云的欢迎语。<br><img src="https://s1.ax1x.com/2018/10/19/i0Sj9e.png" alt="阿里云登录界面"></p>
</li>
</ol>
<h2 id="3-随便干点什么"><a href="#3-随便干点什么" class="headerlink" title="3. 随便干点什么"></a>3. 随便干点什么</h2><p>大家可以看到，这和我们之前使用的虚拟机是完全一样的~<br>​    <img src="https://s1.ax1x.com/2018/10/19/i0SMfe.png"></p>
<p>大家应该想到一点了，就是我们也可以用 <strong>putty/WinSCP/iTerm</strong> 这些工具去访问我们的虚拟机。</p>
<p>在虚拟机内通过<code>ifconfig</code>命令就可以看到虚拟机的IP地址啦~</p>
<h2 id="4-退出"><a href="#4-退出" class="headerlink" title="4. 退出"></a>4. 退出</h2><p>断开与服务器的连接也是一门学问。可能很多同学会直接点击窗口的红叉就关掉了，不过有时候如果我们保持了长连接，访问可能没被关闭。所以最正确的方法当然是在命令行里关闭：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2018/10/19/i0pwE6.png" alt="阿里云退出界面"></p>
<h2 id="5-保持连接"><a href="#5-保持连接" class="headerlink" title="5. 保持连接"></a>5. 保持连接</h2><p>刚开始使用这些远程shell都会遇到一个问题就是如果隔一段时间没有输入新的命令，连接就会被自动断开。这是因为我们没有保持连接，下面介绍一下保持连接的办法。  </p>
<p>两款软件保持连接的原理基本一致，都是每隔一段时间自动向服务器发送一条指令帮助我们保持连接。</p>
<h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h3><blockquote>
<p>Preferences -&gt; Profile -&gt; Session -&gt; When idle, send ASCII code…</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2018/10/19/i09Ea6.png" alt="保持连接1"></p>
<h3 id="putty"><a href="#putty" class="headerlink" title="putty"></a>putty</h3><blockquote>
<p>Putty Configuration -&gt; Connection -&gt; Seconds between keepalives (0 to turn off), 默认为0, 改为30(介于30至150就ok)。  </p>
</blockquote>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g40ui3p81vj30cx0cfwfy.jpg" alt="保持连接2"></p>
<h1 id="（五）C-S实战"><a href="#（五）C-S实战" class="headerlink" title="（五）C/S实战"></a>（五）C/S实战</h1><h2 id="1-背景-4"><a href="#1-背景-4" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>这是云服务器入门系列的最后一节啦~很开心你能看到这里。五节内容都是我对云服务器日常使用的一些拙见，如有错误，还请包含！  </p>
<p>我个人一直在用阿里云，本着“每台服务器只做一件事”的思想，用起来真的很爽！阿里云对学生的优惠真的蛮大的，我一直用￥9.5的学生机作为我开发的一款小程序的后端。￥9.5的配置还是能满足比较初级的需求的，我的后端大概每天有5000次左右的请求，服务器的负荷在高峰时(100次请求/s)也不过30%。  </p>
<p>希望你能喜欢！</p>
<p>最后一节我们来进行一个简单的实战，我们借助Linux下很好用的网络调试探测工具netcat(nc)来进行一个简单的服务器与客户端的连接。</p>
<h2 id="2-安装nc"><a href="#2-安装nc" class="headerlink" title="2. 安装nc"></a>2. 安装nc</h2><p>服务器和本地虚拟机上都要安装一下nc客户端哦。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install nc # for centos</span><br><span class="line">sudo apt install netcat # for ubuntu</span><br></pre></td></tr></table></figure>

<h2 id="3-开启服务器端监听"><a href="#3-开启服务器端监听" class="headerlink" title="3. 开启服务器端监听"></a>3. 开启服务器端监听</h2><p>服务器在某个端口上侦听，使用<code>nc -l 主机ip地址 端口号</code>。</p>
<p>我们可以加上-v来显示这个过程，如果不指定ip地址的话就默认是0.0.0.0，相当于INADDR_ANY。</p>
<p>在我们的云服务器上执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -l -v 12345</span><br></pre></td></tr></table></figure>

<p>显示如下：</p>
<p><img src="https://s1.ax1x.com/2018/11/12/iLQyCR.png" alt="image-20181021204156047"></p>
<h2 id="4-客户端发送请求"><a href="#4-客户端发送请求" class="headerlink" title="4. 客户端发送请求"></a>4. 客户端发送请求</h2><p>客户端通过 <code>nc 主机ip地址 端口号</code> 连接服务器，连接成功后，可以在任何一终端来相互发送数据了。</p>
<p>在我们的本地虚拟机上执行如下指令（注意，<strong>YOUR_SERVER_IP_ADDRESS</strong>是你的服务器的数字地址哦）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -v YOUR_SERVER_IP_ADDRESS </span><br></pre></td></tr></table></figure>

<p>连接成功后，客户端输入任意字符都会自动发送到服务器上啦。</p>
<p><img src="https://s1.ax1x.com/2018/11/12/iLQgv6.png" alt="image-20181021212256452"></p>
<p>下面我们可以在服务器上运行我们自己的server代码啦。比如实验四提供给我们的web server代码，我们在服务器上开启它后就可以通过客户端访问了。</p>
<h2 id="5-在服务器上部署Java项目"><a href="#5-在服务器上部署Java项目" class="headerlink" title="5. 在服务器上部署Java项目"></a>5. 在服务器上部署Java项目</h2><p>执行如下步骤</p>
<ol>
<li>将Java项目打包成jar包/war包等压缩包</li>
<li>利用WinSCP/FileZilla等FTP工具将压缩包上传至服务器（记住上传位置）</li>
<li>利用命令行工具登录到服务器进入压缩包所在位置</li>
<li>运行<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -jar yourprojectname.jar &amp; </span><br></pre></td></tr></table></figure>
<ul>
<li>nohup: 进程后台运行，将日志输出到文件</li>
<li>&amp;: 回到命令行</li>
</ul>
</li>
<li>部署成功，如果是前后端分离项目就可以用postman访问服务器地址测试啦<br>另外为了部署方便推荐使用jenkins，一键即可从github仓库拉取代码、maven打包、执行shell命令完成部署</li>
</ol>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>以上五篇就是我所整理的一些「云服务器」从购买选择到初步使用的入门知识啦。感谢你能看到这里，如有错误还请包含。<br><a href="https://zhuanlan.zhihu.com/p/47181746">留言板</a></p>
]]></content>
      <categories>
        <category>技术探究</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>云服务器</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>东软睿道实训杂记</title>
    <url>/b.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/History/%E4%B8%9C%E8%BD%AF%E7%9D%BF%E9%81%93%E5%AE%9E%E8%AE%AD%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<img src="http://ws1.sinaimg.cn/large/006tNc79ly1g30xqf7vbvj3080037aa7.jpg" width="200px"/>   

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul>
<li>内容：Java互联网架构基础知识  </li>
<li>时间：2019.05-07 - 2019.07.05  </li>
<li>背景：软件学院大三下学期9学分<a href="http://sc.neu.edu.cn/2019/0328/c99a90425/page.htm">企业项目实训</a></li>
</ul>
<h2 id="1-Contents"><a href="#1-Contents" class="headerlink" title="1. Contents"></a>1. Contents</h2><ul>
<li><a href="#day-1---day-3-mybatis">Day 1 - Day 3: MyBatis</a></li>
<li><a href="#day-4---day-5-spring-ioc">Day 4 - Day 5: Spring IoC</a></li>
<li><a href="#day-6---day-7-spring-aop">Day 6 - Day 7: Spring AOP</a> </li>
<li><a href="#day-8---day-x-spring-mvc">Day 8 - Day 12: Spring MVC</a></li>
<li><a href="#day-13---day-13-springboot">Day 13 - Day 13: Springboot</a></li>
<li><a href="#day-14---day-x-team-project-first-part">Day 14 - Day X: Team Project (First Part)</a></li>
<li>Working…</li>
</ul>
<h2 id="2-Warning"><a href="#2-Warning" class="headerlink" title="2. Warning"></a>2. Warning</h2><p>⚠️<strong>受本人学识所限，本笔记项目的学习意义不大，更多地可作为同期课程同学对课堂知识的一个回顾即课程讲义。如果对您有帮助的话，烦请为我点一个Star😋</strong>  </p>
<h2 id="3-Contribution"><a href="#3-Contribution" class="headerlink" title="3. Contribution"></a>3. Contribution</h2><p><strong>欢迎各位大佬在<a href="https://github.com/Raven98/Neuedu">本项目</a>发起<a href="https://github.com/Raven98/Neuedu/pulls">PR</a>或在<a href="https://github.com/Raven98/Neuedu/issues">Issues</a>里留言邀请您成为协作者，共同完善本文档</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Raven98/Neuedu.git</span><br></pre></td></tr></table></figure>
<hr>
<p>为了获得更优阅读体验，您可移步至我的博客：<br><a href="https://ravenxu.top/%E4%B8%9C%E8%BD%AF%E7%9D%BF%E9%81%93%E5%AE%9E%E8%AE%AD%E6%9D%82%E8%AE%B0/">东软睿道实训杂记</a></p>
<hr>
<h1 id="Day-1-Day-3-MyBatis"><a href="#Day-1-Day-3-MyBatis" class="headerlink" title="Day 1 - Day 3: MyBatis"></a>Day 1 - Day 3: MyBatis</h1><ul>
<li><a href="https://github.com/Raven98/Neuedu/tree/master/TestMyBatis">参考代码</a></li>
<li><a href="http://www.mybatis.org/mybatis-3/">MyBatis 英文文档</a></li>
<li><a href="http://www.mybatis.org/mybatis-3/zh/getting-started.html">MyBatis 中文文档</a>  </li>
</ul>
<p><em>本文内容很大程度地参考了官方文档，mybatis有中文版本的文档并且极其简洁，推荐阅读</em></p>
<h2 id="1-了解MyBatis"><a href="#1-了解MyBatis" class="headerlink" title="1. 了解MyBatis"></a>1. 了解MyBatis</h2><ul>
<li>优秀的持久层框架</li>
<li>支持定制化 SQL、存储过程以及高级映射</li>
<li>避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li>
<li>使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录</li>
</ul>
<span id="more"></span>

<h2 id="2-传统的JDBC"><a href="#2-传统的JDBC" class="headerlink" title="2. 传统的JDBC"></a>2. 传统的JDBC</h2><p>MyBatis是对JDBC的封装，使用JDBC我们需要以下步骤：</p>
<h3 id="2-1-Load-driver-into-memory-注册驱动"><a href="#2-1-Load-driver-into-memory-注册驱动" class="headerlink" title="2.1. Load driver into memory 注册驱动"></a>2.1. Load driver into memory 注册驱动</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Get-connection-from-database-创建connection"><a href="#2-2-Get-connection-from-database-创建connection" class="headerlink" title="2.2. Get connection from database 创建connection"></a>2.2. Get connection from database 创建connection</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/scott&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Create-preparedStatement-to-write-a-Sql"><a href="#2-3-Create-preparedStatement-to-write-a-Sql" class="headerlink" title="2.3. Create preparedStatement to write a Sql"></a>2.3. Create preparedStatement to write a Sql</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PreparedStatement stat = conn.prepareStatement(<span class="string">&quot;select * from dept where deptno = ?&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-4-Replace-all-with-actual-value"><a href="#2-4-Replace-all-with-actual-value" class="headerlink" title="2.4. Replace all ? with actual value"></a>2.4. Replace all ? with actual value</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stat.setInt(<span class="number">1</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-5-execute-sql"><a href="#2-5-execute-sql" class="headerlink" title="2.5 execute sql"></a>2.5 execute sql</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResultSet rs = stat.executeQuery();</span><br></pre></td></tr></table></figure>
<h3 id="2-6-get-the-result"><a href="#2-6-get-the-result" class="headerlink" title="2.6. get the result"></a>2.6. get the result</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(rs.next())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> deptno = rs.getInt(<span class="string">&quot;deptno&quot;</span>);</span><br><span class="line">	String dname = rs.getString(<span class="string">&quot;dname&quot;</span>);</span><br><span class="line">	String loc = rs.getString(<span class="string">&quot;loc&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	System.out.println(deptno+<span class="string">&quot;\t&quot;</span>+dname+<span class="string">&quot;\t&quot;</span>+loc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-试一试MyBatis"><a href="#3-试一试MyBatis" class="headerlink" title="3. 试一试MyBatis"></a>3. 试一试MyBatis</h2><h3 id="3-1-从-XML-中构建-SqlSessionFactory"><a href="#3-1-从-XML-中构建-SqlSessionFactory" class="headerlink" title="3.1. 从 XML 中构建 SqlSessionFactory"></a>3.1. 从 XML 中构建 SqlSessionFactory</h3><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            SqlSessionFactory sqlSessionFactory =</span><br><span class="line">                    <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure>
<p>也可以不从XML而是直接在Java中构建SqlSessionFactory，不做详细讨论。</p>
<h3 id="3-2-从-SqlSessionFactory-中获取-SqlSession"><a href="#3-2-从-SqlSessionFactory-中获取-SqlSession" class="headerlink" title="3.2. 从 SqlSessionFactory 中获取 SqlSession"></a>3.2. 从 SqlSessionFactory 中获取 SqlSession</h3><p>既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dept d = session.selectOne(<span class="string">&quot;com/neuedu/model/DeptMapper.java.selectDept&quot;</span>, <span class="number">20</span>);</span><br><span class="line">System.out.println(d.getDeptno()+<span class="string">&quot;\t&quot;</span>+d.getDname()+<span class="string">&quot;\t&quot;</span>+d.getLoc());</span><br></pre></td></tr></table></figure>
<p>诚然，这种方式能够正常工作，并且对于使用旧版本 MyBatis 的用户来说也比较熟悉。不过现在有了一种更简洁的方式 ——使用正确描述每个语句的参数和返回值的接口（比如 DeptMapper.class），你现在不仅可以执行更清晰和类型安全的代码，而且还不用担心易错的字符串字面值以及强制类型转换。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DeptMapper mapper = session.getMapper(DeptMapper.class);</span><br><span class="line">Dept d = mapper.selectDept(<span class="number">20</span>);</span><br><span class="line">System.out.println(d.getDeptno()+<span class="string">&quot;\t&quot;</span>+d.getDname()+<span class="string">&quot;\t&quot;</span>+d.getLoc());</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>新旧方式对比(个人理解)</strong><br><img src="http://ws3.sinaimg.cn/large/006tNc79ly1g2sifw8z3tj30fz0aujrd.jpg"><br>旧方式业务代码直接根据(namespace+id)调用XML里面的某一个方法<br>新方式将XML和接口双向绑定，业务代码不需要知道XML文件内容，直接调用接口。<br>一个显而易见的变化就是旧方式的namespace随便写，而新方式必须为xml文件所在路径<br>第二种方法有很多优势，首先它不依赖于字符串字面值，会更安全一点； 其次，如果你的 IDE 有代码补全功能，那么代码补全可以帮你快速选择<strong>已映射的 SQL 语句</strong>。<br>这样做的好处在学习初期还不能完全理解，随着学习的加深能逐渐领悟  </p>
</blockquote>
<h3 id="3-3-获取查询结果"><a href="#3-3-获取查询结果" class="headerlink" title="3.3. 获取查询结果"></a>3.3. 获取查询结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//to iterate this list</span></span><br><span class="line">Iterator&lt;Dept&gt; it = d.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    Dept item = it.next();</span><br><span class="line">    <span class="comment">//output its content</span></span><br><span class="line">    System.out.println(item.getDeptno()+<span class="string">&quot;\t&quot;</span>+item.getDname()+<span class="string">&quot;\t&quot;</span>+item.getLoc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-对比JDBC和MyBatis"><a href="#4-对比JDBC和MyBatis" class="headerlink" title="4. 对比JDBC和MyBatis"></a>4. 对比JDBC和MyBatis</h2><p>直观的代码改变是MyBatis需要一个主XML配置文件，需要根据业务需求写一些mapper XML文件，需要为每个mapper XML文件编写对应的接口文件，需要为数据库内实体编写对应的Java类。<br>多了很多文件，但一定有很多好处：<br><a href="https://www.cnblogs.com/love-Stefanie/p/6838269.html">参考资料</a></p>
<h3 id="4-1-优化获取和释放"><a href="#4-1-优化获取和释放" class="headerlink" title="4.1. 优化获取和释放"></a>4.1. 优化获取和释放</h3><p>我们一般在访问数据库时都是通过数据库连接池来操作数据库，数据库连接池有好几种，比如C3P0、DBCP，也可能采用容器本身的JNDI数据库连接池。我们可以通过DataSource进行隔离解耦，我们统一从DataSource里面获取数据库连接，DataSource具体由DBCP实现还是由容器的JNDI实现都可以，所以我们将DataSource的具体实现通过让用户配置来应对变化。</p>
<h3 id="4-2-SQL统一管理，对数据库进行存取操作"><a href="#4-2-SQL统一管理，对数据库进行存取操作" class="headerlink" title="4.2. SQL统一管理，对数据库进行存取操作"></a>4.2. SQL统一管理，对数据库进行存取操作</h3><p>我们使用JDBC对数据库进行操作时，SQL查询语句分布在各个Java类中，这样可读性差，不利于维护，当我们修改Java类中的SQL语句时要重新进行编译。<br>Mybatis可以把SQL语句放在配置文件中统一进行管理，以后修改配置文件，也不需要重新就行编译部署。</p>
<h3 id="4-3-生成动态SQL语句"><a href="#4-3-生成动态SQL语句" class="headerlink" title="4.3. 生成动态SQL语句"></a>4.3. 生成动态SQL语句</h3><p>我们在查询中可能需要根据一些属性进行组合查询，比如我们进行商品查询，我们可以根据商品名称进行查询，也可以根据发货地进行查询，或者两者组合查询。如果使用JDBC进行查询，这样就需要写多条SQL语句。<br>Mybatis可以在配置文件中通过使用<code>&lt;if test=””&gt;&lt;/if&gt;</code>标签进行SQL语句的拼接，生成动态SQL语句。比如下面这个例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCountByInfo&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select count(*) from user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;nickname!=null&quot;</span>&gt;</span></span><br><span class="line">                and nickname = #&#123;nickname&#125; </span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email!=null&quot;</span>&gt;</span></span><br><span class="line">                and email = #&#123;email&#125; </span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就是通过昵称或email或者二者的组合查找用户数。  </p>
<h3 id="4-4-能够对结果集进行映射（手动-gt-自动）"><a href="#4-4-能够对结果集进行映射（手动-gt-自动）" class="headerlink" title="4.4. 能够对结果集进行映射（手动-&gt;自动）"></a>4.4. 能够对结果集进行映射（手动-&gt;自动）</h3><p>我们在使用JDBC进行查询时，返回一个结果集ResultSet，我们要从结果集中取出结果封装为需要的类型。<br>在Mybatis中我们可以设置将结果<strong>直接</strong>映射为自己需要的类型，比如：JavaBean对象、一个Map、一个List等等。</p>
<h2 id="5-对mybatis-config-xml-主配置文件-的配置简化"><a href="#5-对mybatis-config-xml-主配置文件-的配置简化" class="headerlink" title="5. 对mybatis-config.xml(主配置文件)的配置简化"></a>5. 对mybatis-config.xml(主配置文件)的配置简化</h2><h3 id="5-1-使用properties管理变量"><a href="#5-1-使用properties管理变量" class="headerlink" title="5.1. 使用properties管理变量"></a>5.1. 使用properties管理变量</h3><p>数据库driver url username password等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/scott</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br></pre></td></tr></table></figure>
<p>在mybatis-config.xml中导入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Load db.properties--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-使用类型别名"><a href="#5-2-使用类型别名" class="headerlink" title="5.2. 使用类型别名"></a>5.2. 使用类型别名</h3><p>resultType省去路径前缀</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.neuedu.model.po&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-一次引入所有mapper文件"><a href="#5-3-一次引入所有mapper文件" class="headerlink" title="5.3. 一次引入所有mapper文件"></a>5.3. 一次引入所有mapper文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;./mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不过我在intellij里没一次导入成功，貌似找不到路径，只得挨个导入mapper</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/DeptMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/EmpMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/ScoresMapper.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="6-使用log-4j日志管理工具"><a href="#6-使用log-4j日志管理工具" class="headerlink" title="6. 使用log.4j日志管理工具"></a>6. 使用log.4j日志管理工具</h2><p><a href="https://blog.csdn.net/u013870094/article/details/79518028">最详细的Log4J使用教程</a></p>
<h3 id="6-1-配置文件"><a href="#6-1-配置文件" class="headerlink" title="6.1. 配置文件"></a>6.1. 配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Global logging configuration</span><br><span class="line">log4j.rootLogger=DEBUG, stdout</span><br><span class="line"># MyBatis logging configuration...</span><br><span class="line">log4j.logger.org.mybatis.example.BlogMapper=TRACE</span><br><span class="line"># Console output...</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="7-尝试更多sql"><a href="#7-尝试更多sql" class="headerlink" title="7. 尝试更多sql"></a>7. 尝试更多sql</h2><ol>
<li>like语句</li>
<li>更多变量</li>
<li>插入</li>
<li>插入递增字段</li>
<li>插入一个对象instance</li>
<li>指定返回字段</li>
<li>利用hashmap传参</li>
<li>update</li>
<li>delete</li>
<li>多表查询<ul>
<li>返回值不能是po了</li>
<li>在涉及到的表的mapper选一个。一般选主要的一个</li>
</ul>
</li>
</ol>
<h2 id="8-Result-Maps"><a href="#8-Result-Maps" class="headerlink" title="8. Result Maps"></a>8. Result Maps</h2><p>hashmap或者po作为返回值需要字段名与属性名一致，但有时数据库字段的user_id和Java属性的驼峰式userId不一样，需要有一个映射(不用resultmap的话也可以在sql里用别名关键字<code>as</code>)</p>
<h3 id="8-1-一对一多表查询"><a href="#8-1-一对一多表查询" class="headerlink" title="8.1. 一对一多表查询"></a>8.1. 一对一多表查询</h3><h3 id="8-2-一对多多表查询"><a href="#8-2-一对多多表查询" class="headerlink" title="8.2. 一对多多表查询"></a>8.2. 一对多多表查询</h3><h3 id="8-3-多对多多表查询"><a href="#8-3-多对多多表查询" class="headerlink" title="8.3. 多对多多表查询"></a>8.3. 多对多多表查询</h3><h3 id="8-4-LazyLoading"><a href="#8-4-LazyLoading" class="headerlink" title="8.4. LazyLoading"></a>8.4. LazyLoading</h3><h3 id="8-5-利用-lt-sql-gt-替换重复sql代码"><a href="#8-5-利用-lt-sql-gt-替换重复sql代码" class="headerlink" title="8.5. 利用&lt;sql&gt;替换重复sql代码"></a>8.5. 利用<code>&lt;sql&gt;</code>替换重复sql代码</h3><h3 id="8-6-字符串替换"><a href="#8-6-字符串替换" class="headerlink" title="8.6. 字符串替换"></a>8.6. 字符串替换</h3><p>因为Preparestatement后sql的结构不变</p>
<blockquote>
<p>#和$的区别  </p>
<p>理解「sql结构与变量」的概念<br>$可以改变sql的结构有sql注入的风险</p>
</blockquote>
<h2 id="9-动态SQL"><a href="#9-动态SQL" class="headerlink" title="9. 动态SQL"></a>9. 动态SQL</h2><h3 id="9-1-试一下传统方法"><a href="#9-1-试一下传统方法" class="headerlink" title="9.1. 试一下传统方法"></a>9.1. 试一下传统方法</h3><p>需要大量判断或者多次查询</p>
<h3 id="9-2-if标签"><a href="#9-2-if标签" class="headerlink" title="9.2. if标签"></a>9.2. if标签</h3><p>省去了判断根据属性的顺序传值的部分代码，但还是需要写不同if的and代码<br>利用where + if标签完成</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByConditions&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empno != 0&quot;</span>&gt;</span></span><br><span class="line">            and empno = #&#123;empno&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span></span><br><span class="line">            and ename = #&#123;ename&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span></span><br><span class="line">            and job = #&#123;job&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="9-3-choose-when-otherwise-switch-case-default"><a href="#9-3-choose-when-otherwise-switch-case-default" class="headerlink" title="9.3. choose + when + otherwise (switch case default)"></a>9.3. choose + when + otherwise (switch case default)</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByOneCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empno != 0&quot;</span>&gt;</span></span><br><span class="line">                and empno = #&#123;empno&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span></span><br><span class="line">                and ename = #&#123;ename&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span></span><br><span class="line">                and job = #&#123;job&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="9-4-Dynamic-Update"><a href="#9-4-Dynamic-Update" class="headerlink" title="9.4. Dynamic Update"></a>9.4. Dynamic Update</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmpByCondition&quot;</span>&gt;</span></span><br><span class="line">    update emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span></span><br><span class="line">            ename = #&#123;ename&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span></span><br><span class="line">            job = #&#123;job&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where empno = #&#123;empno&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="9-5-foreach"><a href="#9-5-foreach" class="headerlink" title="9.5. foreach"></a>9.5. foreach</h3><h3 id="9-6-分页-limit"><a href="#9-6-分页-limit" class="headerlink" title="9.6. 分页 limit"></a>9.6. 分页 limit</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByPage&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp limit #&#123;index&#125;, #&#123;count&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="10-MyBatis-Cache"><a href="#10-MyBatis-Cache" class="headerlink" title="10. MyBatis Cache"></a>10. MyBatis Cache</h2><p>mybatis的性能是不如JDBC的，但是它通过cache等操作尽力提升了性能(虽然还是差jdbc很多)<br><strong>demo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queryByPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqlSession session = DBUtils.getInstance();</span><br><span class="line">    EmpMapper mapper = session.getMapper(EmpMapper.class);</span><br><span class="line"></span><br><span class="line">    List&lt;Emp&gt; emps = mapper.getEmpByPage(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(Emp e : emps) &#123;</span><br><span class="line">        System.out.println(e.getEmpno() + <span class="string">&quot;\t&quot;</span> + e.getEname() + <span class="string">&quot;\t&quot;</span> + e.getJob());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this time, get data from cache</span></span><br><span class="line">    <span class="comment">// by default, data will be cached and shared in one session</span></span><br><span class="line">    <span class="comment">// if you create two different sessions, data can not be shared</span></span><br><span class="line">    List&lt;Emp&gt; emps2 = mapper.getEmpByPage(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(Emp e : emps) &#123;</span><br><span class="line">        System.out.println(e.getEmpno() + <span class="string">&quot;\t&quot;</span> + e.getEname() + <span class="string">&quot;\t&quot;</span> + e.getJob());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图所示，同一个session里的同样的sql语句只被执行一次<br><img src="http://ws1.sinaimg.cn/large/006tNc79ly1g2uw4nfuc0j31wk0bkwit.jpg"></p>
<h2 id="11-Maven-Project"><a href="#11-Maven-Project" class="headerlink" title="11. Maven Project"></a>11. Maven Project</h2><p>优点</p>
<ul>
<li>在一个位置管理全部依赖包<ul>
<li>只需写几行代码，导入方便</li>
<li>自动将依赖的jar一次性下载完毕</li>
<li>发送给别人方便，不需要附带依赖的jar包，接收方可以根据pom.xml自行导入依赖</li>
</ul>
</li>
<li>有mvn命令，便于打包发布持续集成自动化构建</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="附1：本单元补充知识点"><a href="#附1：本单元补充知识点" class="headerlink" title="附1：本单元补充知识点"></a>附1：本单元补充知识点</h3><h4 id="1-iBatis"><a href="#1-iBatis" class="headerlink" title="1. iBatis"></a>1. iBatis</h4><h4 id="2-Java-Bean"><a href="#2-Java-Bean" class="headerlink" title="2. Java Bean"></a>2. Java Bean</h4><h4 id="3-sql-date-and-utils-date"><a href="#3-sql-date-and-utils-date" class="headerlink" title="3. sql.date and utils.date"></a>3. sql.date and utils.date</h4><p><a href="https://www.cnblogs.com/IamThat/p/3264234.html">java.util.Date和java.sql.Date的区别及应用</a></p>
<h4 id="4-SQL注入与Preparestatement"><a href="#4-SQL注入与Preparestatement" class="headerlink" title="4. SQL注入与Preparestatement"></a>4. SQL注入与Preparestatement</h4><p><a href="https://www.cnblogs.com/yaochc/p/4957833.html">预处理prepareStatement是怎么防止sql注入漏洞的？</a></p>
<h3 id="附2：一点思考"><a href="#附2：一点思考" class="headerlink" title="附2：一点思考"></a>附2：一点思考</h3><ol>
<li>MyBatis底层还是对JDBC的封装，查看运行日志可知最终运行的还是sql代码，只不过使用mybatis可以帮助我们更好地管理复杂的数据库访问代码，以更贴近Java本身的设计思想的方式还访问数据库。  </li>
<li>XML 接口文件 理解这些文件的作用需要领悟<strong>映射</strong>的概念。<br>一个mapper.mxl对应一个接口文件对应一个数据库的表</li>
<li>MyBatis<br>MyBatis作为一个框架，还是对现有接口的封装，可以参考轻量级框架<a href="https://www.sql2o.org/">sql2o</a>的设计思想自行设计一个框架</li>
<li>存储过程的使用场景：阿里巴巴Java开发手册明确写明了禁止使用存储过程，究其原因更多是因为存储过程代码可读性极差、debug困难，对于阿里这样的大企业有其他措施弥补性能；对于东软这样的外包公司，如果是一个<strong>需求明确</strong>的任务还是可以写存储过程的，毕竟因为存储过程在数据库内一次性完成多个操作性能会更好。</li>
</ol>
<h1 id="Day-4-Day-5-Spring-IoC"><a href="#Day-4-Day-5-Spring-IoC" class="headerlink" title="Day 4 - Day 5: Spring IoC"></a>Day 4 - Day 5: Spring IoC</h1><ul>
<li><a href="https://github.com/Raven98/Neuedu/tree/master/SpringCore">参考代码(基于XML)</a>  </li>
<li><a href="https://github.com/Raven98/Neuedu/tree/master/testspringannotation">参考代码(基于注解)</a>  </li>
<li><a href="https://docs.spring.io/spring/docs/5.1.6.RELEASE/spring-framework-reference/core.html">Spring官方文档</a>  </li>
<li><a href="https://www.kancloud.cn/winter1981/spring/543484">费老师著作</a></li>
</ul>
<h2 id="1-了解Spring-IoC"><a href="#1-了解Spring-IoC" class="headerlink" title="1. 了解Spring IoC"></a>1. 了解Spring IoC</h2><h3 id="1-1-IoC-invertion-of-control"><a href="#1-1-IoC-invertion-of-control" class="headerlink" title="1.1. IoC: invertion of control"></a>1.1. IoC: invertion of control</h3><h4 id="Demo-for-IoC"><a href="#Demo-for-IoC" class="headerlink" title="Demo for IoC"></a>Demo for IoC</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// IoC inversion of control, also called DI(dependency injection)</span></span><br><span class="line">    <span class="keyword">private</span> TestDAO testDAO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestDAO</span><span class="params">(TestDAO testDAO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testDAO = testDAO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//get a instance of TestService from Spring</span></span><br><span class="line">        <span class="comment">//ask spring for instance</span></span><br><span class="line">        <span class="comment">//create a Spring container,</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//get instance from Spring container</span></span><br><span class="line">        <span class="comment">//by default, spring uses singleton mode</span></span><br><span class="line">        TestService service = (TestService)context.getBean(<span class="string">&quot;testService&quot;</span>);</span><br><span class="line">        TestService service2 = (TestService)context.getBean(<span class="string">&quot;testService&quot;</span>);</span><br><span class="line">        TestService service3 = (TestService)context.getBean(<span class="string">&quot;testService&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(service);</span><br><span class="line">        System.out.println(service2);</span><br><span class="line">        System.out.println(service3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Ouput"><a href="#Ouput" class="headerlink" title="Ouput"></a>Ouput</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">testspringcore.TestService@6d4b1c02</span><br><span class="line">testspringcore.TestService@6d4b1c02</span><br><span class="line">testspringcore.TestService@6d4b1c02</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>IoC的目的是要让Sring来创建我们所需要的对象，不需要通过new建立。我们在applicationContext.xml配置Java bean对象即可被spring所调用。Spring默认使用单例模式。（上面的hash值指向同一个对象）由Spring所创建的对象被放到Spring的容器中。</p>
<h3 id="1-2-单例模式-Singleton"><a href="#1-2-单例模式-Singleton" class="headerlink" title="1.2.单例模式 Singleton"></a>1.2.单例模式 Singleton</h3><blockquote>
<p>单例模式与静态类<br>观点一：（单例 ）<br>单例模式比静态方法有很多优势：<br>首先，单例可以继承类，实现接口，而静态类不能（可以集成类，但不能集成实例成员）；<br>其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化；<br>再次，单例类可以被集成，他的方法可以被覆写；<br>最后，或许最重要的是，单例类可以被用于多态而无需强迫用户只假定唯一的实例。举个例子，你可能在开始时只写一个配置，但是以后你可能需要支持超过一个配 置集，或者可能需要允许用户从外部从外部文件中加载一个配置对象，或者编写自己的。你的代码不需要关注全局的状态，因此你的代码会更加灵活。</p>
<p>观点二：（静态方法 ） 静态方法中产生的对象，会随着静态方法执行完毕而释放掉，而且执行类中的静态方法时，不会实例化静态方法所在的类。如果是用singleton,   产生的那一个唯一的实例，会一直在内存中，不会被GC清除的(原因是静态的属性变量不会被GC清除)，除非整个JVM退出了。这个问题我之前也想几天，并 且自己写代码来做了个实验。</p>
<p>观点三：（Good！ ）<br>由于DAO的初始化，会比较占系统资源的，如果用静态方法来取，会不断地初始化和释放，所以我个人认为如果不存在比较复杂的事务管理，用 singleton会比较好。个人意见，欢迎各位高手指正。<br>参考链接:<br><a href="https://www.cnblogs.com/zhtao_tony/p/3956047.html">静态类和单例模式区别</a></p>
</blockquote>
<h2 id="2-管理bean的生命周期"><a href="#2-管理bean的生命周期" class="headerlink" title="2. 管理bean的生命周期"></a>2. 管理bean的生命周期</h2><p>对Spring调用bean构造方法的探究(告诉Spring 如何构造对象)</p>
<h3 id="2-1-重写构造方法加入打印调用，发现的确有输出"><a href="#2-1-重写构造方法加入打印调用，发现的确有输出" class="headerlink" title="2.1 重写构造方法加入打印调用，发现的确有输出"></a>2.1 重写构造方法加入打印调用，发现的确有输出</h3><h3 id="2-2-将构造器声明为private也能被创建"><a href="#2-2-将构造器声明为private也能被创建" class="headerlink" title="2.2 将构造器声明为private也能被创建"></a>2.2 将构造器声明为private也能被创建</h3><p><a href="https://blog.csdn.net/tiwerbao/article/details/20838903">反射破坏单例的私有构造函数保护</a><br>帮助理解Spring为何能做到这点</p>
<h3 id="2-3-三种构造方法-告诉Spring怎样构建对象"><a href="#2-3-三种构造方法-告诉Spring怎样构建对象" class="headerlink" title="2.3. 三种构造方法(告诉Spring怎样构建对象)"></a>2.3. 三种构造方法(告诉Spring怎样构建对象)</h3><h4 id="2-3-1-直接调用Constructor-Instantiation-with-a-Constructor"><a href="#2-3-1-直接调用Constructor-Instantiation-with-a-Constructor" class="headerlink" title="2.3.1. 直接调用Constructor(Instantiation with a Constructor)"></a>2.3.1. 直接调用Constructor(Instantiation with a Constructor)</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testDAO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.TestDAO&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最普通的方法，默认新建单例模式的对象，标签内增加<code>scope=&quot;prototype&quot;</code>可以允许新建多个实例。<br>Spring会在最初的<code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code><br>步骤自动创建所有被注册的单例模式的Java bean，标签内增加<code>lazy-init=&quot;true&quot;</code>则指定在需要时在创建。  </p>
<h4 id="2-3-2-绑定getInstance-Instantiation-with-a-Static-Factory-Method"><a href="#2-3-2-绑定getInstance-Instantiation-with-a-Static-Factory-Method" class="headerlink" title="2.3.2. 绑定getInstance() (Instantiation with a Static Factory Method)"></a>2.3.2. 绑定getInstance() (Instantiation with a Static Factory Method)</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.TestBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方法的好处是可以手动规定创建实例的方法，例如通过绑定如下getInstance方法可以规定该类最多被创建10次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//only have ten instance</span></span><br><span class="line"><span class="comment">//This class has the function of producing instance</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestBean <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;factory method invoked&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TestBean();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-绑定Factory-class-Instantiation-by-Using-an-Instance-Factory-Method"><a href="#2-3-3-绑定Factory-class-Instantiation-by-Using-an-Instance-Factory-Method" class="headerlink" title="2.3.3. 绑定Factory.class (Instantiation by Using an Instance Factory Method)"></a>2.3.3. 绑定Factory.class (Instantiation by Using an Instance Factory Method)</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- register factory bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testBean2Factory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.TestBean2Factory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- register testbean2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testBean2&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;testBean2Factory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>与方法2类似，不过这时我们为要新建的bean类构造了一个对应的Factory类。</p>
<h2 id="3-管理bean的依赖（依赖注入-Dependency-Injection）"><a href="#3-管理bean的依赖（依赖注入-Dependency-Injection）" class="headerlink" title="3. 管理bean的依赖（依赖注入 Dependency Injection）"></a>3. 管理bean的依赖（依赖注入 Dependency Injection）</h2><p>可以理解为「管理bean的生命周期」是创建一个实例，「管理bean的依赖」是对这个实例的属性值进行初始化。</p>
<h3 id="3-1-使用XML方式实现依赖注入-2种方式"><a href="#3-1-使用XML方式实现依赖注入-2种方式" class="headerlink" title="3.1. 使用XML方式实现依赖注入(2种方式)"></a>3.1. 使用XML方式实现依赖注入(2种方式)</h3><p>spring会在创建@bean testService之前先创建一个它要依赖的bean的实例</p>
<h4 id="3-1-1-setter注入（常用）"><a href="#3-1-1-setter注入（常用）" class="headerlink" title="3.1.1. setter注入（常用）"></a>3.1.1. setter注入（常用）</h4><p><em>applicationContext.xml</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testDAO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.TestDAO&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.TestService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testDAO&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;testDAO&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>多个属性即多行</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testDAO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.TestDAO&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDAO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.UserDAO&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.TestService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;testDAO&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;testDAO&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDAO&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDAO&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;property&gt;</code>标签内的name对应的是testService的属性，ref对应的是该xml文件其他bean的id<br>TestService类需要有各个属性的setter<br><em>TestService.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TestDAO testDAO;</span><br><span class="line"><span class="keyword">private</span> UserDAO userDAO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestDAO</span><span class="params">(TestDAO testDAO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.testDAO = testDAO;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDAO</span><span class="params">(UserDAO userDAO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userDAO = userDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的setter一定要严格遵守setter方法名命名规范「set+Property驼峰式」，可以用IDE自带的代码生成工具生成setter。</p>
<h4 id="3-1-2-构造注入"><a href="#3-1-2-构造注入" class="headerlink" title="3.1.2. 构造注入"></a>3.1.2. 构造注入</h4><p>（1）普通构造注入<br><em>applicationContext.xml</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testDAO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.TestDAO&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDAO&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.UserDAO&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.TestService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;testDAO&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;userDAO&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>constructor-arg的顺序与构造器参数顺序不用保持一致，可以自动识别，但是如果有重复类型的属性或者有原始类型的属性，需要注明对应关系。<br><em>TestService.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TestDAO testDAO;</span><br><span class="line"><span class="keyword">private</span> UserDAO userDAO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestService</span><span class="params">(UserDAO userDAO, TestDAO testDAO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userDAO = userDAO;</span><br><span class="line">    <span class="keyword">this</span>.testDAO = testDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>（2）有简单类型的构造注入<br>有简单数据类型的构造注入：</p>
<blockquote>
<p>简单数据类型 = 原始类型 + String（String虽然是reference类型但是有很多原始类型的特征）  </p>
</blockquote>
<p><em>applicationContext.xml</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>value内必须用引号，体现不出数据类型，可以用<code>type</code>属性注明<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>可以使用<code>index</code>属性注明传参数据增强可读性<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>利用<code>name</code>属性注明构造器参数名<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;years&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ultimateAnswer&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>setter注入也是可以注入简单类型的，不多做介绍</li>
<li>什么时候简单类型需要被注入？<br>如果我们的代码只被自己使用，其实可以直接在类的属性里给简单数据类型初始化赋值，但是例如如果我们要使用jar包分享我们的代码给其他人使用，就应该利用xml文件进行依赖注入，因为这样不需要重新编译代码，jar包内是二进制文件不是java源代码是不能被修改的。<h4 id="3-1-3-setter注入-vs-构造器注入"><a href="#3-1-3-setter注入-vs-构造器注入" class="headerlink" title="3.1.3. setter注入 vs 构造器注入"></a>3.1.3. setter注入 vs 构造器注入</h4></li>
<li>spring官方文档推荐构造器注入</li>
<li>费老师实际工作常用setter注入</li>
<li>具体使用哪一种方法应该由团队成员讨论后由leader决定</li>
</ul>
<h4 id="3-1-4-collection作为参数"><a href="#3-1-4-collection作为参数" class="headerlink" title="3.1.4. collection作为参数"></a>3.1.4. collection作为参数</h4><p>collection包括：</p>
<ul>
<li>list</li>
<li>set</li>
<li>map</li>
</ul>
<p><em>ExampleBean.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; map;</span><br></pre></td></tr></table></figure>
<p>增加三个集合属性<br><em>applicationContext.xml</em>  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;testspringcore.ExampleBean&quot;</span> <span class="attr">p:years</span>=<span class="string">&quot;7500000&quot;</span> <span class="attr">p:ultimateAnswer</span>=<span class="string">&quot;42&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>str1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>str2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>str3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>strset1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>strset2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>strset3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;an entry&quot;</span> <span class="attr">value</span>=<span class="string">&quot;just some string&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span> =<span class="string">&quot;a ref&quot;</span> <span class="attr">value</span>=<span class="string">&quot;myDataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>p:preperty</code>是另一种更简单的方式用来注入简单数据类型  </p>
<blockquote>
<p>我们一般不常用集合，但是有时候引用的jar包需要我们以collection的方式注入。</p>
</blockquote>
<h4 id="3-1-5-properties读取"><a href="#3-1-5-properties读取" class="headerlink" title="3.1.5. properties读取"></a>3.1.5. properties读取</h4><p>类似集合，常用类似方法读取properties配置<br><em>applicationContext.xml</em>  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;adminEmails&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;administrator&quot;</span>&gt;</span>administrator@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;support&quot;</span>&gt;</span>support@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;development&quot;</span>&gt;</span>development@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="3-1-6-depends-on"><a href="#3-1-6-depends-on" class="headerlink" title="3.1.6. depends-on"></a>3.1.6. depends-on</h4><p>之前我们用ref来指明依赖的类，但有时这种依赖关系不是很明显，这要求我们用<code>depends-on</code>属性强制指明依赖的类。<br><em>applicationContext.xml</em>  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;manager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ManagerBean&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>depends-on</code>内可用分隔符分隔指明多个依赖关系</p>
<h4 id="3-1-7-Lazy-initialized-beans"><a href="#3-1-7-Lazy-initialized-beans" class="headerlink" title="3.1.7. Lazy-initialized beans"></a>3.1.7. Lazy-initialized beans</h4><p>前面我们已经提到过，这代表延迟加载单例bean<br>以前我们不这样做，但是现在内存等硬件条件上升，我们常常对单例实例不使用延迟加载，我们用空间换时间，为了更好性能。<br><em>程序使用<code>ClassPathXmlApplicationContext()</code>注入时只默认注入全部的单例类，非单例类我们不知道该创建多少个，也没必要提前创建</em></p>
<h3 id="3-2-使用注解方式实现依赖注入"><a href="#3-2-使用注解方式实现依赖注入" class="headerlink" title="3.2. 使用注解方式实现依赖注入"></a>3.2. 使用注解方式实现依赖注入</h3><ul>
<li>@Component-&gt;通用组件<br>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</li>
<li>@Controller-&gt;控制器<br>用于标注控制层组件（如struts中的action）</li>
<li>@Service-&gt; Service<br>用于标注业务层组件</li>
<li>@Repository -&gt; DAO<br>用于标注数据访问组件，即DAO组件</li>
</ul>
<p><em>@Component泛指所有组件，其他三个是拥有特殊语义的注解</em><br><em>Spring鼓励使用其他三个更具有语义化的注解，会在日后支持提供feature</em></p>
<h4 id="3-2-1-demo"><a href="#3-2-1-demo" class="headerlink" title="3.2.1. demo"></a>3.2.1. demo</h4><p><em>applicationContext.xml</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- specify where beans locate --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;testspringannotation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时的xml配置文件很简洁，指明了我们用注解的方式来注入依赖。<br><em>TestController.java</em></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//we are sure, Spring uses Java Reflection mechanism to update its private field</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TestService testService;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outputcollaborators</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//invoke method the service</span></span><br><span class="line">		testService.outputinfo();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-Autowired"><a href="#3-2-2-Autowired" class="headerlink" title="3.2.2. @Autowired"></a>3.2.2. @Autowired</h4><blockquote>
<p>wire, 装载；装配<br>autowired, 自动装载  </p>
</blockquote>
<p>我们用<code>@Autowired</code>注明哪些类需要被注入，方式有很多种：</p>
<ol>
<li>在构造器上方注明<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在setter函数上方注明 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在具有任意名称和多个参数的方法上方注明<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line">        <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span></span><br><span class="line"><span class="params"><span class="function">                CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">            <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">4.</span> 在成员变量fields上注明，甚至可以混用注解方法</span><br><span class="line">    ```java</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
 显然，在成员变量上使用<code>@Autowired</code>用到了Java的反射机制。这种方法有一套机制去唯一标识注入的对象，通常先byType，若有冲突再转而byName。<h3 id="3-3-思考"><a href="#3-3-思考" class="headerlink" title="3.3. 思考"></a>3.3. 思考</h3><h4 id="3-3-1-框架设计原则：约定优于配置"><a href="#3-3-1-框架设计原则：约定优于配置" class="headerlink" title="3.3.1. 框架设计原则：约定优于配置"></a>3.3.1. 框架设计原则：约定优于配置</h4>例如约定bean默认不延迟加载。事无巨细的配置降低了框架的便利性。<h4 id="3-3-2-MVC"><a href="#3-3-2-MVC" class="headerlink" title="3.3.2. MVC"></a>3.3.2. MVC</h4><img src="http://ws3.sinaimg.cn/large/006tNc79ly1g2w91nprxrj31000mewkd.jpg" width="500rpx"/>   </li>
</ol>
<p>MVC是所有web项目为了实现“高内聚，低耦合”应遵循的模式。  </p>
<h4 id="3-3-3-对比基于XML与基于注解的注入方式"><a href="#3-3-3-对比基于XML与基于注解的注入方式" class="headerlink" title="3.3.3. 对比基于XML与基于注解的注入方式"></a>3.3.3. 对比基于XML与基于注解的注入方式</h4><ul>
<li>显然有各自的优缺点</li>
<li>不能因为基于注解的方式是较新的就认为它更好</li>
<li><a href="http://blog.csdn.net/y6s6y6y/article/details/80992833">参考资料:spring注解和xml配置的优缺点比较</a></li>
<li>官方文档：<ul>
<li>注解更贴近代码，有更多context，配置更短更精确；</li>
<li>但是违反了POJO的模式，配置变得分散更难控制；</li>
<li>Spring支持两种方式混用，结合各自的有点做出更好的配置；</li>
<li>值得指出的是，通过其JavaConfig选项，Spring允许以非侵入方式使用注释，而无需触及目标组件源代码，并且在工具方面，Spring Tool Suite支持所有配置样式。</li>
</ul>
</li>
</ul>
<h4 id="3-3-4-再议依赖注入"><a href="#3-3-4-再议依赖注入" class="headerlink" title="3.3.4. 再议依赖注入"></a>3.3.4. 再议依赖注入</h4><p><a href="https://zhuanlan.zhihu.com/p/29426019">用小说的形式讲解为什么需要依赖注入</a></p>
<blockquote>
<p>Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系。那么我们今天的主角依赖注入到底有什么神奇之处呢？请往下继续看。<br>了解过设计模式的朋友肯定知道工厂模式吧，即所有的对象的创建都交给工厂来完成，是一个典型的面向接口编程。这比直接用new直接创建对象更合理，因为直接用new创建对象，会导致调用者与被调用者的硬编码耦合；而工厂模式，则把责任转向了工厂，形成调用者与被调用者的接口的耦合，这样就避免了类层次的硬编码耦合。这样的工厂模式确实比传统创建对象好很多。但是，正如之前所说的，工厂模式只是把责任推给了工厂，造成了调用者与被调用者工厂的耦合。<br>Spring框架则避免了调用者与工厂之间的耦合，通过spring容器“宏观调控”，调用者只要被动接受spring容器为调用者的成员变量赋值即可，而不需要主动获取被依赖对象。这种被动获取的方式就叫做依赖注入，又叫控制反转。依赖注入又分为设值注入和构造注入。而spring框架则负责通过配置xml文件来实现依赖注入。而设值注入和构造注入则通过配置上的差异来区分。</p>
</blockquote>
<p><strong>依赖注入 == 控制反转</strong></p>
<h1 id="Day-6-Day-7-Spring-AOP"><a href="#Day-6-Day-7-Spring-AOP" class="headerlink" title="Day 6 - Day 7: Spring AOP"></a>Day 6 - Day 7: Spring AOP</h1><h2 id="1-了解AOP"><a href="#1-了解AOP" class="headerlink" title="1. 了解AOP"></a>1. 了解AOP</h2><h3 id="1-1-名词解释"><a href="#1-1-名词解释" class="headerlink" title="1.1. 名词解释"></a>1.1. 名词解释</h3><ul>
<li>AOP: Aspect-Oriented Programming: 面向切面编程<br>分布于应用中多处的功能称为横切关注点，通过这些横切关注点在概念上是与应用的业务逻辑相分离的，但其代码往往直接嵌入在应用的业务逻辑之中。将这些横切关注点与业务逻辑相分离正是面向切面编程（AOP）所要解决的。切面实现了横切关注点的模块化<br>一句话概括：切面是跟具体业务无关的一类共同功能。</li>
<li>advice: 通知</li>
<li>pointcut: 切入点</li>
<li>weaving: 织入</li>
</ul>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><p>这里我们不用xml用注解配置，例如<code>@Before(&quot;execution(* com.neuedu.model.service.AccountService.*(..))&quot;)</code></p>
<h3 id="2-1-Before"><a href="#2-1-Before" class="headerlink" title="2.1. @Before"></a>2.1. @Before</h3><h3 id="2-2-AfterReturning"><a href="#2-2-AfterReturning" class="headerlink" title="2.2. @AfterReturning"></a>2.2. @AfterReturning</h3><h3 id="2-3-AfterThrowing"><a href="#2-3-AfterThrowing" class="headerlink" title="2.3. @AfterThrowing"></a>2.3. @AfterThrowing</h3><p>业务方法一定要抛出异常（try catch throw / throws）皆可，否则<code>@AfterThrowing</code>注解无法起作用。</p>
<h3 id="2-4-After"><a href="#2-4-After" class="headerlink" title="2.4. @After"></a>2.4. @After</h3><h3 id="2-5-执行顺序探究"><a href="#2-5-执行顺序探究" class="headerlink" title="2.5. 执行顺序探究"></a>2.5. 执行顺序探究</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//@Before</span></span><br><span class="line">        method.invoke(..);</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//@After</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//@AfterReturning</span></span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">    <span class="comment">//@AfterThrowing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@After</code>和<code>@AfterReturning</code>注解的执行顺序以及生成的动态代理类结果在新版本中有变化，有待进一步探究。<br><a href="http://www.imooc.com/qadetail/75298">aop after-returning 和after的区别？</a></p>
<h2 id="3-Demo"><a href="#3-Demo" class="headerlink" title="3.Demo"></a>3.Demo</h2><p>JDBC事务处理是经常使用AOP的一个典型事例（其他还有诸如日志等），我们举例对比使用AOP前后代码量与代码结构的变化。</p>
<h3 id="3-1-使用切面之前"><a href="#3-1-使用切面之前" class="headerlink" title="3.1. 使用切面之前"></a>3.1. 使用切面之前</h3><p><em>DBUtils.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtils</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//加载数据库驱动</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//1.得到数据库连接</span></span><br><span class="line">		Connection conn = getConnection();</span><br><span class="line">		<span class="comment">//2.设置自动提交为false    </span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Connection conn = tl.get();</span><br><span class="line">		<span class="keyword">if</span>(conn==<span class="keyword">null</span>)</span><br><span class="line">		&#123;			</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				conn = DriverManager.</span><br><span class="line">						getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mydb?useUnicode=true&amp;characterEncoding=utf8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//放在本地线程</span></span><br><span class="line">			tl.set(conn);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> conn;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//1.得到数据库连接</span></span><br><span class="line">		Connection conn = getConnection();</span><br><span class="line">		<span class="comment">//2. 提交</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			conn.commit();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//1.得到数据库连接</span></span><br><span class="line">		Connection conn = getConnection();</span><br><span class="line">		<span class="comment">//2. 提交</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			conn.rollback();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//1.得到数据库连接</span></span><br><span class="line">		Connection conn = getConnection();</span><br><span class="line">		<span class="comment">//2. 提交</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			conn.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.把conn从tl中移除</span></span><br><span class="line">		tl.remove();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>ThreadLocal</code>：保证连接是共享的，同一个连接</p>
<p><em>Service类 Service.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	AccountDAO accountDAO;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;		</span><br><span class="line">		<span class="comment">//1. 获得数据库连接，开启事务</span></span><br><span class="line">		DBUtils.beginTransaction();</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;			</span><br><span class="line">			accountDAO.deduct();</span><br><span class="line">			accountDAO.add();</span><br><span class="line">			</span><br><span class="line">			DBUtils.commit();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(Exception e)</span><br><span class="line">		&#123;</span><br><span class="line">			DBUtils.rollback();</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		&#123;</span><br><span class="line">			DBUtils.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1. 开启spring容器</span></span><br><span class="line">		ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		AccountService accountService = (AccountService)context.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		accountService.transferMoney();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>AccountDAO.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDAO</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deduct</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//1. 获得连接</span></span><br><span class="line">		Connection conn = DBUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">		PreparedStatement ps = conn.prepareStatement(<span class="string">&quot;update account set balance = balance-10 where accountid =2&quot;</span>);</span><br><span class="line">	    ps.executeUpdate();	     </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//1. 获得连接</span></span><br><span class="line">		Connection conn = DBUtils.getConnection();</span><br><span class="line">		</span><br><span class="line">		PreparedStatement ps = conn.prepareStatement(<span class="string">&quot;update account set balance = balance+10 where accountid =1&quot;</span>);</span><br><span class="line">	    ps.executeUpdate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-使用切面之后"><a href="#3-2-使用切面之后" class="headerlink" title="3.2. 使用切面之后"></a>3.2. 使用切面之后</h3><p><em>切面类 TransactionAspect.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAspect</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Before(&quot;execution(* com.neuedu.model.service.AccountService.*(..))&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		DBUtils.getConnection();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@AfterReturning(&quot;execution(* com.neuedu.model.service.AccountService.*(..))&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		DBUtils.commitConnection();</span><br><span class="line">		DBUtils.closeConnection();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@AfterThrowing(&quot;execution(* com.neuedu.model.service.AccountService.*(..))&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollbackConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		DBUtils.rollbackConnection();</span><br><span class="line">		DBUtils.closeConnection();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@After(&quot;execution(* com.neuedu.model.service.AccountService.*(..))&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		DBUtils.closeConnection();		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Service类 MyService.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;       </span><br><span class="line">           MyDAO myDAO = <span class="keyword">new</span> MyDAO();</span><br><span class="line">           myDAO.deduct();          </span><br><span class="line">           myDAO.add();         </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，Service类被简化了，目前Service只有一个方法，显然可以预测随着业务的增多Service将提供越来越多的业务函数，利用切面将只关注真正的业务逻辑而不再需要写context比较低的代码。</p>
<h2 id="3-探究AOP实现机制：动态代理"><a href="#3-探究AOP实现机制：动态代理" class="headerlink" title="3. 探究AOP实现机制：动态代理"></a>3. 探究AOP实现机制：动态代理</h2><p><strong>注意:</strong> AOP不是代码拷贝，是方法调用<br>有两种动态代理方式</p>
<h3 id="3-1-运行时创建临时对象"><a href="#3-1-运行时创建临时对象" class="headerlink" title="3.1. 运行时创建临时对象"></a>3.1. 运行时创建临时对象</h3><ul>
<li>方法1: 实现一个接口，spring直接调用jdk，创建一个类，实现一个接口</li>
<li>方法2: 没实现接口，spring调用内置的cglib</li>
</ul>
<h3 id="3-2-编译过程修改编译生成的class文件"><a href="#3-2-编译过程修改编译生成的class文件" class="headerlink" title="3.2. 编译过程修改编译生成的class文件"></a>3.2. 编译过程修改编译生成的class文件</h3><ul>
<li>Aspectj修改.class文件</li>
<li>Spring AOP依赖IoC</li>
</ul>
<h2 id="4-Around"><a href="#4-Around" class="headerlink" title="4. @Around"></a>4. @Around</h2><p>利用<code>@Around</code>我们可以显式地指明语句插入的位置，利用<code>@Around</code>代替上面的四个注解完成JDBC事务管理如下：<br><em>TranscationAspect.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* com.neuedu.model.service.AccountService.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	DBUtils.getConnection();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		pjp.proceed();</span><br><span class="line"></span><br><span class="line">		DBUtils.commitConnection();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">		System.out.println(e);</span><br><span class="line"></span><br><span class="line">		DBUtils.rollbackConnection();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">throw</span> e;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		DBUtils.closeConnection();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这和前四个注解共同使用的实现逻辑类似，其中传入参数<code>ProceedingJoinPoint pjp</code>代表切入点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//@Before</span></span><br><span class="line">        method.invoke(..);</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//@After</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//@AfterReturning</span></span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">    <span class="comment">//@AfterThrowing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只不过利用<code>@Around</code>注解我们手动实现了其中的 try, finally, catch关系，这有助于我们更好地理解AOP切入的位置。</p>
<h2 id="5-XML配置"><a href="#5-XML配置" class="headerlink" title="5. XML配置"></a>5. XML配置</h2><p>下面再来尝试不用注解用XML配置切面<br>使用场景</p>
<ul>
<li>用了jar包里的Aspect类</li>
<li>xml配置便于集中管理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//before the method executes:</span></span><br><span class="line">		System.out.println(<span class="string">&quot;methods before&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//after the method executes:</span></span><br><span class="line">		System.out.println(<span class="string">&quot;methods after&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterthrowing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;methods exception&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterreturnning</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;methods runs without exception&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-Advisor顾问"><a href="#6-Advisor顾问" class="headerlink" title="6. Advisor顾问"></a>6. Advisor顾问</h2><p>Advisor顾问：只有一个方法的Aspect切面<br>（因为<code>@Around</code>很流行，使用很多切面类里只有一个方法，如果一个切面只有一个advice，我们叫它advisor。）</p>
<h3 id="6-1-配置方法"><a href="#6-1-配置方法" class="headerlink" title="6.1. 配置方法"></a>6.1. 配置方法</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;transactionAdvisor&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.neuedu.model.service.AccountService.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionAdvisor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * because a advisor only have one advice, to specify the type of the advice, </span></span><br><span class="line"><span class="comment">	 * you must implements different interface.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * because we must implement a interface, this is called invasive design（侵入式设计） </span></span><br><span class="line"><span class="comment">	 * which is actually not good.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation arg0)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		</span><br><span class="line">		DBUtils.getConnection();</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//call our business logic</span></span><br><span class="line">			<span class="comment">//dao.deductMoney();</span></span><br><span class="line">			<span class="comment">//dao.addMoney();</span></span><br><span class="line">			arg0.proceed();</span><br><span class="line">			</span><br><span class="line">			DBUtils.commitConnection();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			</span><br><span class="line">			DBUtils.rollbackConnection();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">throw</span> e;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		&#123;</span><br><span class="line">			DBUtils.closeConnection();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过实现接口代表是哪一种切面</p>
<h3 id="6-2-优点"><a href="#6-2-优点" class="headerlink" title="6.2. 优点"></a>6.2. 优点</h3><ul>
<li>配置简化</li>
<li>便于使用第三方切面</li>
</ul>
<h3 id="6-3-小结"><a href="#6-3-小结" class="headerlink" title="6.3. 小结"></a>6.3. 小结</h3><p>这体现了框架是在不断演变的，框架设计者也在不断根据用户使用情况及反馈调整框架的设计。如此例，设计者发现很多只有一个方法的切面类也需要繁琐的<br>配置因而引入了顾问的概念帮助简化这些只有一个方法的切面的配置。<br>各种主流框架一般都支持xml配置和注解配置，xml配置和注解配置是两套并行的配置方法。Java在5.0版本中引入了注解，之后注解迅速流行，但是对于<br>一些早期项目，考虑到项目稳定性以及团队成员的学习问题还更喜欢xml，当然xml配置也有自身的有点，在上面提到过最显著的两点。</p>
<h2 id="7-MyBatis-Spring"><a href="#7-MyBatis-Spring" class="headerlink" title="7. MyBatis + Spring"></a>7. MyBatis + Spring</h2><p><strong>核心问题：</strong>MyBatis实现IoC由Spring创建并控制</p>
<blockquote>
<p>数据库连接池</p>
</blockquote>
<h3 id="7-1-分析配置文件"><a href="#7-1-分析配置文件" class="headerlink" title="7.1. 分析配置文件"></a>7.1. 分析配置文件</h3><p>由配置文件即可看出配置的思想：配置SqlSession Fac<br><em>applicationContext.xml</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--注明通过注解来配置AOP--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.neuedu.model.service&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- to enable AOP aspect weave --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- connect spring with mybatis --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源，类似于属性文件，下面会用到，使用了dbcp2数据连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ds&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/scott&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- (1) --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- configure MyBatis sessionFactory --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置MyBatis的sessionFactory，将其交由Spring管理 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 加载mybatis的主配置文件 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 注入数据源 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ds&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- (2) --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tell Spring about Mapper information --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- MyBatis: 指定mapper，即可用的DAO方法 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 指定扫描的包名，如果扫描多个包，每个包中间使用半角逗号分隔--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.neuedu.model.mapper&quot;</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 自动创建session（connection）去数据库交互 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sessionFactory&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">&lt;!-- (3) --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 以下为Spring AOP的配置 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- configure Spring transaction manager which is a advisor --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置AOP，该事务AOP由Spring提供 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txm&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ds&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- if we want to use annotation to control transaction --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 指定利用注解的方式配置 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txm&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>分析利用Spring来管理MyBatis的配置文件需要回想之前手动管理MyBatis的步骤</p>
<ul>
<li>(1) 配置MyBatis的sessionFactory<br>之前我们采用如下方式新建sessionFactory<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">InputStream inputStream;</span><br><span class="line">SqlSession session = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1. Create a sqlsessionFactory</span></span><br><span class="line">    inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>(2) 指定可以使用的mapper实现</li>
<li>(3) 配置Spring AOP</li>
</ul>
<p><strong>这其中，之前由我们手写的例如TransactionManager切面类等都由Spring提供的类来实现！配置一次后其他的使用就很简单了！</strong><br><strong>初次接触配置文件可能比较陌生，想要理解好要回想不用Spring框架我们要做哪些工作</strong></p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><h3 id="8-1-补充知识点"><a href="#8-1-补充知识点" class="headerlink" title="8.1. 补充知识点"></a>8.1. 补充知识点</h3><ul>
<li><p>判断是否是同一个对象：打印对象地址。</p>
</li>
<li><p>什么时候把类加载到内存？三种情况：</p>
<ul>
<li>new类的对象</li>
<li>调用类的静态方法</li>
<li><code>Class.forName(&quot;&quot;);</code></li>
</ul>
</li>
<li><p>JDBC事务</p>
<blockquote>
<p>事务是必须满足4个条件（ACID）<br>事务的原子性（ Atomicity）：一组事务，要么成功；要么撤回。<br>  一致性 （Consistency）：事务执行后，数据库状态与其他业务规则保持一致。如转账业务，无论事务执行成功否，参与转账的两个账号余额之和应该是不变的。<br>  隔离性（Isolation）：事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。<br>  持久性（Durability）：软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得， innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。</p>
</blockquote>
</li>
<li><p>DML<br>SQL分为DML数据库操纵语言（SELECT INSERT DELETE UPDATE）和DDL数据库定义语言（创建表时的一些定义操作ALTER等）<br>JDBC默认自动提交，即<code>executeUpdate()</code>后自动执行了commit()。但是我们想保持数据库的原子性，所以在上面通过<code>conn.setAutoCommit(false);</code>禁用自动提交。禁用后支持<code>rollback()</code>回滚操作及<code>rollback(Savepoint savepoint) </code>回滚到固定位置。数据库在<code>commit()</code>前都没被真正改变，都能通过<code>rollback()</code>撤销之前做的<code>executeUpdate()</code>操作。数据库应该只是有一个临时的镜像而已。COMMIT命令用于把事务所做的修改保存到数据库。</p>
</li>
<li><p>joinpoint &amp; pointcut<br>连接点joinpoint指方法的执行，pointcut指定位到一堆连接点</p>
<h3 id="8-2-再议异常处理"><a href="#8-2-再议异常处理" class="headerlink" title="8.2. 再议异常处理"></a>8.2. 再议异常处理</h3></li>
<li><p>try catch<br>自行处理</p>
</li>
<li><p>throws<br>交给上级处理</p>
</li>
<li><p>try catch + throw<br>自行处理+通知上级发生过异常</p>
</li>
</ul>
<p>如果想使<code>@AfterThrowing</code>起作用就不要手动try catch处理了异常~ 不过如果在catch里处理完再throw也是可以的</p>
<p>不能在主方法里向上抛出异常，不是好的代码</p>
<h3 id="8-3-数据库连接池"><a href="#8-3-数据库连接池" class="headerlink" title="8.3. 数据库连接池"></a>8.3. 数据库连接池</h3><p>7.1中的<code>ds bean</code>使用了dbcp2数据库连接池，下面我们简单介绍一下数据库连接池。戳下面的链接    </p>
<ul>
<li><a href="https://ravenxu.top/2019/05/15/%E5%88%9D%E6%8E%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">参考资料</a></li>
</ul>
<h3 id="8-4-一点想法"><a href="#8-4-一点想法" class="headerlink" title="8.4. 一点想法"></a>8.4. 一点想法</h3><p>在实现了Spring+MyBatis整合配置后，我惊讶的发现项目代码量减少很多，主要原因是常用的类<br>都交由Spring内置的类实现了，所以如果我们直接学习内置类使用的话就很难理解深层次的细节问题，所以还是得从头学起，了解JDBC和MyBatis的差异，了解Spring IoC怎样作为容器管理实例，了解Spring AOP怎样实现动态代理。<br>举例说明项目代码量减少，我们最后的项目不用手写数据库事务管理类，二是用了Spring提供的<code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code>类，这主要是因为AOP的主流使用场景就固定那几种，Spring作为一个好用的框架自然无死角的帮助开发者少做工作，懒惰是推动技术进步的动力哈哈。</p>
<p><strong>高效学习框架知识：注重阅读文档，兼而学习底层知识。</strong></p>
<h1 id="Day-8-Day-12-Spring-MVC"><a href="#Day-8-Day-12-Spring-MVC" class="headerlink" title="Day 8 - Day 12: Spring MVC"></a>Day 8 - Day 12: Spring MVC</h1><h2 id="1-Spring-MVC介绍"><a href="#1-Spring-MVC介绍" class="headerlink" title="1. Spring MVC介绍"></a>1. Spring MVC介绍</h2><h3 id="1-1-回想"><a href="#1-1-回想" class="headerlink" title="1.1 回想"></a>1.1 回想</h3><p>回想之前我们学习的三个技术，加上今天要学习的Spring MVC，共同组成了一个web项目要使用的基本框架。<br>这四个技术分别应用的MVC模型中的如下部分：</p>
<ul>
<li>Spring MVC: Controller Layer</li>
<li>Spring IoC: All</li>
<li>Spring AOP: Service Layer</li>
<li>MyBatis: mapper</li>
</ul>
<h3 id="1-2-概述"><a href="#1-2-概述" class="headerlink" title="1.2 概述"></a>1.2 概述</h3><p>Spring MVC工作在控制层， 替代的是servlet<br>Servlet不好的地方：</p>
<ol>
<li>一个请求对应一个servlet, servlet类的数量特别多</li>
<li>处理请求参数麻烦  <ul>
<li>request.getParameter()</li>
<li>手动新建对象<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User u = <span class="keyword">new</span> User();</span><br><span class="line">u.setxx();</span><br><span class="line">u.setxxx();</span><br><span class="line"></span><br><span class="line">MyService.addUser(u);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<img src="http://ws4.sinaimg.cn/large/006tNc79ly1g31razzyhxj30zw0m8418.jpg" width="500px"/> 

<h3 id="1-3-DispatcherServlet"><a href="#1-3-DispatcherServlet" class="headerlink" title="1.3 DispatcherServlet"></a>1.3 DispatcherServlet</h3><p>之前做的项目就总遇到<code>DispatcherServlet</code>的保错，这次来深入了解一下什么是<code>DispatcherServlet</code><br>请求到达服务器后，Tomcat创建request对象给<code>DispatcherServlet</code>，request对象包含客户端的所有信息，<code>DispatcherServlet</code><br>再把request传给controller和jsp文件。controller和jsp使用同一个request，因而<code>controller</code>可以利用request暂存数据传值<br>给jsp文件。例子见下方3.4<br>另外Tomcat还会自动创建response对象。<br>作用域：request, session, application等</p>
<h2 id="2-环境配置-Hello-world-demo"><a href="#2-环境配置-Hello-world-demo" class="headerlink" title="2. 环境配置 + Hello world demo"></a>2. 环境配置 + Hello world demo</h2><p><em>web.xml</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;WebApp_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;3.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>testmvc<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- configure listenner --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置监听器，即一旦监测到Tomcat启动，则创建Spring容器(现在的主函数在Tomcat里！所以我们没有办法手动创建Spring容器) --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- purpose of listenning, listen the startup of tomcat, the listener runs when tomcat startup --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ContextLoaderListener initialize spring container --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- register Dispatcher servlet, this servlet gets all requests from user, and then decide which java file should handle this request --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每次的request和response由DispatcherServlet承载 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 过滤器，防止中文乱码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-路径与参数传递"><a href="#3-路径与参数传递" class="headerlink" title="3. 路径与参数传递"></a>3. 路径与参数传递</h2><h3 id="3-1-普通传参"><a href="#3-1-普通传参" class="headerlink" title="3.1 普通传参"></a>3.1 普通传参</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String username,String password)</span></span></span><br><span class="line"><span class="function"></span>&#123;		</span><br><span class="line">    <span class="comment">//invoke service method to query database.</span></span><br><span class="line">    System.out.println(username);</span><br><span class="line">    System.out.println(password);</span><br><span class="line">    </span><br><span class="line">    session.setAttribute(<span class="string">&quot;userinfo&quot;</span>, username);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-比较int与Integer"><a href="#3-2-比较int与Integer" class="headerlink" title="3.2 比较int与Integer"></a>3.2 比较int与Integer</h3><p>对于可选参数，若为传参使用int会报错，而Integer会设置没传过来的可选的参数为null</p>
<h3 id="3-3-静态资源"><a href="#3-3-静态资源" class="headerlink" title="3.3 静态资源"></a>3.3 静态资源</h3><p>伪装：可以把路径名设置为<code>login.html</code>等，以为是请求一个html文件，实则是一个路径<br>出于对安全因素的考量<code>/WEB-INF</code>文件夹下的文件是不可以被直接访问的，但是可以通过路径跳转到此</p>
<h3 id="3-4-Rest风格的变量参数"><a href="#3-4-Rest风格的变量参数" class="headerlink" title="3.4 Rest风格的变量参数"></a>3.4 Rest风格的变量参数</h3><p><code>@RequestMapping(&quot;/rest/&#123;username&#125;/&#123;password&#125;&quot;)</code></p>
<h3 id="3-5-参数为对象"><a href="#3-5-参数为对象" class="headerlink" title="3.5 参数为对象"></a>3.5 参数为对象</h3><p>自动映射</p>
<h3 id="3-4-向页面返回信息"><a href="#3-4-向页面返回信息" class="headerlink" title="3.4 向页面返回信息"></a>3.4 向页面返回信息</h3><h4 id="3-4-1-vo与po"><a href="#3-4-1-vo与po" class="headerlink" title="3.4.1 vo与po"></a>3.4.1 vo与po</h4><p>vo与po</p>
<ul>
<li>po: posistent object</li>
<li>vo: value object<br>vo与po分离是比较好的策略，但是对于mybatis不分离也可以。但是hibernate这种全自动框架(不需要写sql语句)必须分离。<br>po对应数据库表，对于po的date类型，前端页面不能直接显示（格式问题），有两种解决方案</li>
</ul>
<ol>
<li>对于jsp使用java做转换，对于html使用js做转换</li>
<li>定义两个字段（常用）</li>
</ol>
<p>vo和po分离： 页面显示的内容和数据库的内容和数据类型不一定一致，应该采用不同的对象。</p>
<ul>
<li>dto(vo), data transfer object 数据传输对象，对应页面</li>
<li>bo(po)，business object 业务对象，对应数据库</li>
</ul>
<p>当使用了mybatis或者是hibernate这样的框架时，习惯使用以下说法：</p>
<ul>
<li><p>vo: value object 值对象，对应页面</p>
</li>
<li><p>po: persistent object 持久化对象，对应数据库</p>
</li>
<li><p>vo: 对应页面：String birthday</p>
</li>
<li><p>po: 对应数据库： Date birthday</p>
</li>
</ul>
<p>View(vo) -&gt; Controller(vo) -&gt; Service(vo&lt;-&gt;po) -&gt; Mapper(po)</p>
<h4 id="3-4-2-el-jstl-JSP标签库"><a href="#3-4-2-el-jstl-JSP标签库" class="headerlink" title="3.4.2 el jstl JSP标签库"></a>3.4.2 el jstl JSP标签库</h4><p>多端项目前后端分离vs企业级单PC端项目</p>
<h4 id="3-4-3-forward-vs-redirect"><a href="#3-4-3-forward-vs-redirect" class="headerlink" title="3.4.3 forward vs redirect"></a>3.4.3 forward vs redirect</h4><ul>
<li>forward：请求转发</li>
<li>redirect：请求重定向<br>请求重定向可以跳转到别的网站的页面<br>【经验谈】能不用请求转发就不用请求转发。<br>以注册页面–&gt;结果页为例，若用户在结果页刷新，注册请求被重新提交了一次，会造成数据库重复记录（请求转发情况下即便返回新页面，但是地址栏的url还是不变的）<br>在ajax下没有请求转发和请求重定向的概念。</li>
</ul>
<img src="http://ws4.sinaimg.cn/large/006tNc79ly1g330cngueqj30z00ju43n.jpg" width="500px" />

<h4 id="3-4-4-request与session"><a href="#3-4-4-request与session" class="headerlink" title="3.4.4 request与session"></a>3.4.4 request与session</h4><p>request的作用域太小，我们需要使用session使用户保持长时间身份认证。</p>
<h4 id="3-4-5-上传文件"><a href="#3-4-5-上传文件" class="headerlink" title="3.4.5 上传文件"></a>3.4.5 上传文件</h4><p><em>springmvc.xml</em>新增</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用于处理请求参数里有文件的情况 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring考虑得极其周全，它知道传文件这样一个使用场景，所以和之前我们用的类似数据库事务类一样，提供了文件处理类<code>MultipartFile</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(User u, MultipartFile photo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(u.getUsername());</span><br><span class="line">    System.out.println(u.getPassword());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//the photo we have this is location somewhere in your temparary folder.</span></span><br><span class="line">    <span class="comment">//put it in D://</span></span><br><span class="line">    File destination = <span class="keyword">new</span> File(<span class="string">&quot;/Users/raven/Downloads/test&quot;</span>,photo.getOriginalFilename());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        photo.transferTo(destination); <span class="comment">//after transfer to the destination, the temparary file will be deleted automatically.</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException | IOException e) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-拦截器"><a href="#4-拦截器" class="headerlink" title="4. 拦截器"></a>4. 拦截器</h2><h3 id="4-1-案例一：未登录，不能访问系统页面"><a href="#4-1-案例一：未登录，不能访问系统页面" class="headerlink" title="4.1 案例一：未登录，不能访问系统页面"></a>4.1 案例一：未登录，不能访问系统页面</h3><p><em>AdminInterceptor.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminInterceptor</span> <span class="keyword">implements</span>  <span class="title">HandlerInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpRequest,</span></span></span><br><span class="line"><span class="params"><span class="function">                                HttpServletResponse httpResponse, Object arg2, Exception arg3)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Object arg2, ModelAndView arg3)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Object object)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="keyword">if</span> (session!= <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (session.getAttribute(<span class="string">&quot;isLogin&quot;</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (session.getAttribute(<span class="string">&quot;isLogin&quot;</span>).equals(<span class="string">&quot;Yes&quot;</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/back/admin_login.jsp&quot;</span>).forward(request,response);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>springmvc.xml</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/Admin/*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;mvc:exclude-mapping path=&quot;/admin/*&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.neuedu.tools.AdminInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-案例二：解决前后端分离开发中的ajax跨域访问问题"><a href="#4-2-案例二：解决前后端分离开发中的ajax跨域访问问题" class="headerlink" title="4.2 案例二：解决前后端分离开发中的ajax跨域访问问题"></a>4.2 案例二：解决前后端分离开发中的ajax跨域访问问题</h3><p><em>AccessControllAllowInterceptor.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessControllAllowInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest arg0, HttpServletResponse response, Object arg2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//CROS</span></span><br><span class="line">		 response.addHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">         </span><br><span class="line">         response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;x-requested-with&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>springmvc.xml</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 跨域访问 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.lamport.education.interceptor.AccessControllAllowInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-3-附录：关于跨域"><a href="#4-3-附录：关于跨域" class="headerlink" title="4.3 附录：关于跨域"></a>4.3 附录：关于跨域</h3><ol>
<li><p>什么是跨域？<br>跨域是指从一个域名的网页去请求另一个域名的资源。比如从<a href="http://www.baidu.com/">www.baidu.com</a> 页面去请求 <a href="http://www.google.com/">www.google.com</a> 的资源。跨域的严格一点的定义是：只要 协议，域名，端口有任何一个的不同，就被当作是跨域</p>
</li>
<li><p>为什么浏览器要限制跨域？<br>原因就是安全问题：如果一个网页可以随意地访问另外一个网站的资源，那么就有可能在客户完全不知情的情况下出现安全问题。比如下面的操作就有安全问题：<br>用户访问<a href="http://www.mybank.com/">www.mybank.com</a> ，登陆并进行网银操作，这时cookie啥的都生成并存放在浏览器<br>用户突然想起件事，并迷迷糊糊地访问了一个邪恶的网站 <a href="http://www.xiee.com/">www.xiee.com</a><br>这时该网站就可以在它的页面中，拿到银行的cookie，比如用户名，登陆token等，然后发起对<a href="http://www.mybank.com/">www.mybank.com</a> 的操作。<br>如果这时浏览器不予限制，并且银行也没有做响应的安全处理的话，那么用户的信息有可能就这么泄露了。  </p>
</li>
<li><p>为什么要跨域？<br>既然有安全问题，那为什么又要跨域呢？ 有时公司内部有多个不同的子域，比如一个是location.company.com ,而应用是放在app.company.com , 这时想从 app.company.com去访问 location.company.com 的资源就属于跨域。</p>
</li>
</ol>
<h2 id="5-SSM整合"><a href="#5-SSM整合" class="headerlink" title="5. SSM整合"></a>5. SSM整合</h2><h3 id="5-1-步骤"><a href="#5-1-步骤" class="headerlink" title="5.1 步骤"></a>5.1 步骤</h3><ol>
<li>新建一个web工程</li>
<li>建立mvc包结构<ul>
<li>com.neuedu.controllers</li>
<li>com.neuedu.model.service</li>
<li>com.neuedu.model.mapper</li>
<li>com.neuedu.model.po</li>
</ul>
</li>
<li>添加3个框架的jar包</li>
<li>添加mybatis的功能<ul>
<li>建立接口和xml</li>
<li>编写myBatis配置文件 SqlMapConfig.xml</li>
</ul>
</li>
<li>添加springmvc的功能<ul>
<li>springmvc配置文件 springmvc.xml</li>
<li>web.xml(配置前端控制器，配置字符编码过滤器)</li>
</ul>
</li>
<li>添加spring的功能<ul>
<li>编写spring的配置文件 applicationContext.xml<ul>
<li>配置数据库源和session工厂</li>
<li>配置service和mapper</li>
<li>配置事务管理</li>
</ul>
</li>
<li>web.xml(配置监听器，启动spring容器)<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置监听器（启动spring容器） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tomcat启动完成以后，自动启动Spring容器<br>监听器（Listener）- 监听application作用域的创建<br>监听器监听作用域（request, session, application）</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="5-2-注意"><a href="#5-2-注意" class="headerlink" title="5.2 注意"></a>5.2 注意</h3><ol>
<li>controller配置文件不和service所在的<code>applicationContext.xml</code>在一起（spring mvc相对spring来说相当于一个更小的容器）</li>
<li>tomcat将项目发布到某一个指定位置，可以看一下Tomcat文件夹以便对web项目整体有更深理解，例如什么时候需要重启一下Tomcat</li>
</ol>
<h2 id="6-探究ajax"><a href="#6-探究ajax" class="headerlink" title="6. 探究ajax"></a>6. 探究ajax</h2><p>利用ajax是另外一种向后台提交数据的方式，ajax的优势如下：</p>
<ul>
<li>表单方式我们不得不刷新整个页面，而ajax可以局部刷新</li>
<li>ajax是异步请求asynchronous，意味着我们可以同时发送多个ajax请求</li>
</ul>
<h3 id="6-1-利用vue框架发送请求"><a href="#6-1-利用vue框架发送请求" class="headerlink" title="6.1 利用vue框架发送请求"></a>6.1 利用vue框架发送请求</h3><p><a href="https://cn.vuejs.org/v2/guide/">Vue介绍</a><br>vue是三大流行前端框架之一，也是其中最简单的一个。vue支持发送类ajax请求，且其具有的其他功能帮助我们更快展示页面。</p>
<h4 id="6-1-1-安装"><a href="#6-1-1-安装" class="headerlink" title="6.1.1 安装"></a>6.1.1 安装</h4><ul>
<li>直接用 <code>&lt;script&gt;</code> 引入<br>直接下载并用 <code>&lt;script&gt;</code> 标签引入，Vue 会被注册为一个全局变量。</li>
<li>NPM<br>在用 Vue 构建大型应用时推荐使用 NPM 安装。NPM 能很好地和诸如 webpack 或 Browserify 模块打包器配合使用。同时 Vue 也提供配套工具来开发单文件组件。</li>
</ul>
<p>对于我们的小demo，我们选择使用更轻量级的外链方式。</p>
<h4 id="6-1-2-数据绑定"><a href="#6-1-2-数据绑定" class="headerlink" title="6.1.2 数据绑定"></a>6.1.2 数据绑定</h4><ul>
<li><code>&#123;&#123; message &#125;&#125;</code> 用于绑定DOM内数据</li>
<li><code>v-bind</code> 用于绑定DOM的属性值</li>
</ul>
<h4 id="6-1-3-其他常用基础操作"><a href="#6-1-3-其他常用基础操作" class="headerlink" title="6.1.3 其他常用基础操作"></a>6.1.3 其他常用基础操作</h4><p>文档写的很全面，不做详细介绍。</p>
<ul>
<li>v-if 条件渲染</li>
<li>v-for 列表循环</li>
<li>v-on 方法调用</li>
<li>v-model 表单输入与应用状态绑定（在表单元素外使用不起作用）<br>v-bind 不支持双向绑定，v-model 支持</li>
</ul>
<h4 id="6-1-4-methods-computed-watch"><a href="#6-1-4-methods-computed-watch" class="headerlink" title="6.1.4 methods, computed, watch"></a>6.1.4 methods, computed, watch</h4><p>计算属性computed<br>Vue.js 的内联表达式非常方便，但如果涉及到比较复杂的场景，我们应该使用计算属性。<br>计算属性是用来声明式的描述一个值依赖了其它的值，当依赖的值发生改变时，其值才会相应的发生更改并更新相关的ＤＯＭ。<br>计算属性的方法名必须和属性名一样。</p>
<blockquote>
<p>在new Vue的配置参数中的computed和methods都可以处理大量的逻辑代码，但是什么时候用哪个属性，要好好区分一下才能做到正确的运用vue。<br>computed称为计算属性，顾名思义，计算就要返回一个计算的结果，所以，当我们要处理大量的逻辑，但是最后要取得最后的结果的时候可以用computed。<br>计算属性也避免了在页面内写逻辑代码，保护代码的结构层次清晰</p>
</blockquote>
<p>watch则关注数据改变，数据改变即被触发</p>
<h4 id="6-1-5-http-request"><a href="#6-1-5-http-request" class="headerlink" title="6.1.5 http request"></a>6.1.5 http request</h4><p>注意跨域的问题</p>
<h3 id="6-2-返回json"><a href="#6-2-返回json" class="headerlink" title="6.2 返回json"></a>6.2 返回json</h3><h4 id="6-2-1-json选用"><a href="#6-2-1-json选用" class="headerlink" title="6.2.1 json选用"></a>6.2.1 json选用</h4><p>有很多json库可以选用，GJSON，fastjson等，Spring MVC 推荐 Jackson。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- this dependency is used to convert between json str and js object --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-2-编写RestController"><a href="#6-2-2-编写RestController" class="headerlink" title="6.2.2 编写RestController"></a>6.2.2 编写RestController</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AjaxController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testajax&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ajax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// convert from json string to js object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;username\&quot;:\&quot;raven\&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>RestController 与 Controller<br>知识点：@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。  </p>
</blockquote>
<blockquote>
<p>1.如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，或者html，配置的视图解析器 InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。<br>2.如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。<br>3.如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。</p>
</blockquote>
<blockquote>
<p>例如：<br>1.使用@Controller 注解，在对应的方法上，视图解析器可以解析return 的jsp,html页面，并且跳转到相应页面。若返回json等内容到页面，则需要加@ResponseBody注解。<br>2.@RestController注解，相当于@Controller+@ResponseBody两个注解的结合，返回json数据不需要在方法前面加@ResponseBody注解了，但使用@RestController这个注解，就不能返回jsp,html页面，视图解析器无法解析jsp,html页面</p>
</blockquote>
<h4 id="6-2-3-前端效果"><a href="#6-2-3-前端效果" class="headerlink" title="6.2.3 前端效果"></a>6.2.3 前端效果</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">//send an ajax request to our controller</span></span><br><span class="line">    axios.get(<span class="string">&#x27;http://localhost:8080/testmvc/testajax&#x27;</span>)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//console.log(response.data.username);</span></span><br><span class="line">            that.user = response.data;</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-4-支持更多"><a href="#6-2-4-支持更多" class="headerlink" title="6.2.4 支持更多"></a>6.2.4 支持更多</h4><p><code>@RestController</code>标记下，<code>return</code>后的内容自动被转为JSON（利用前面加入的Jackson依赖）。<code>return</code>可以返回字符串、json字符串、Java Collection等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/emps&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title">getAllEmps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Emp e1 = <span class="keyword">new</span> Emp();</span><br><span class="line">    e1.setEmpno(<span class="number">1</span>);</span><br><span class="line">    e1.setEname(<span class="string">&quot;KING&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Emp e2 = <span class="keyword">new</span> Emp();</span><br><span class="line">    e2.setEmpno(<span class="number">2</span>);</span><br><span class="line">    e2.setEname(<span class="string">&quot;SMITH&quot;</span>);</span><br><span class="line"></span><br><span class="line">    list.add(e1);</span><br><span class="line">    list.add(e2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//jackson works to convert list to json str</span></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/getmap&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Emp&gt; <span class="title">getMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Map&lt;String,Emp&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Emp e = <span class="keyword">new</span> Emp();</span><br><span class="line">    e.setEmpno(<span class="number">1</span>);</span><br><span class="line">    e.setEname(<span class="string">&quot;CLARK&quot;</span>);</span><br><span class="line">    e.setHiredatestr(<span class="string">&quot;2018-4-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    m.put(<span class="string">&quot;CLARK&quot;</span>, e); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Day-13-Day-13-Springboot"><a href="#Day-13-Day-13-Springboot" class="headerlink" title="Day 13 - Day 13: Springboot"></a>Day 13 - Day 13: Springboot</h1><ul>
<li><a href="https://start.spring.io/">SpringInitializr</a></li>
<li><a href="https://www.cnblogs.com/ityouknow/p/5662753.html">参考博客</a><br>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。</li>
</ul>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><h3 id="1-1-核心思想"><a href="#1-1-核心思想" class="headerlink" title="1.1 核心思想"></a>1.1 核心思想</h3><p>约定优于配置convention is better than configuration</p>
<h3 id="1-2-好处"><a href="#1-2-好处" class="headerlink" title="1.2 好处"></a>1.2 好处</h3><p>其实就是简单、快速、方便！平时如果我们需要搭建一个 Spring Web 项目的时候需要怎么做呢？</p>
<ul>
<li>1）配置 web.xml，加载 Spring 和 Spring mvc</li>
<li>2）配置数据库连接、配置 Spring 事务</li>
<li>3）配置加载配置文件的读取，开启注解</li>
<li>4）配置日志文件</li>
<li>…</li>
<li>配置完成之后部署 Tomcat 调试</li>
<li>…<br>现在非常流行微服务，如果我这个项目仅仅只是需要发送一个邮件，如果我们的项目仅仅是生产一个积分；我都需要这样折腾一遍!<br>但是如果使用 Spring Boot 呢？<br>很简单，我们仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套 Web 项目或者是构建一个微服务！  </li>
</ul>
<h2 id="2-上手"><a href="#2-上手" class="headerlink" title="2. 上手"></a>2. 上手</h2><h3 id="2-1-新建文件"><a href="#2-1-新建文件" class="headerlink" title="2.1 新建文件"></a>2.1 新建文件</h3><p>有两种常用方式创建springboot项目</p>
<ul>
<li>在<a href="https://start.spring.io/">官网</a>上配置并下载springboot项目包，而后导入IDE</li>
<li>直接使用intellij IDEA –&gt; New –&gt; Project –&gt; Spring Initializr 新建项目<br>观察可见，如下图，IDEA其实也是帮助你去从官网下载springboot项目包  <img src="http://ww2.sinaimg.cn/large/006tNc79ly1g3a2m5pxdnj30vu0u00xt.jpg" width="400px" ></li>
</ul>
<h3 id="2-2-项目结构介绍"><a href="#2-2-项目结构介绍" class="headerlink" title="2.2 项目结构介绍"></a>2.2 项目结构介绍</h3><ul>
<li>src/main/java  程序开发以及主程序入口</li>
<li>src/main/resources 配置文件</li>
<li>src/test/java  测试程序</li>
</ul>
<h2 id="3-Demo-1"><a href="#3-Demo-1" class="headerlink" title="3. Demo"></a>3. Demo</h2><h3 id="3-1-Controller"><a href="#3-1-Controller" class="headerlink" title="3.1 Controller"></a>3.1 Controller</h3><p><em>TestController.java</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestController</span><span class="params">(TestService testService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testService = testService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;result\&quot;:true&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-启动主程序"><a href="#3-2-启动主程序" class="headerlink" title="3.2 启动主程序"></a>3.2 启动主程序</h3><p><em>SpringbootdemoApplication</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootdemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootdemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h3><p>是的，快速启动一个springboot非常简单，尤其是免去了Tomcat的配置，springboot依赖了一个内嵌的Tomcat。<br>同时要注意包的命名，springboot约定了一些包名，例如它会自动在<code>controller</code>包内搜索路径。想在其他包内编写路径也可以，不过就需要额外的配置了。再次体现<strong>约定优于配置</strong>的设计思想。<br>Springboot将本就简化了开发工作的Spring MVC再一次简化，尤其是对于小型应用可快速完成部署。使用 Spring Boot 可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用 Spring Boot 非常适合构建微服务。<br>另外，Springboot还提供热部署功能，安装一个依赖即可，<a href="https://blog.csdn.net/sinat_32867867/article/details/81535770">参考</a>  </p>
<h1 id="Day-14-Day-X-Team-Project-First-Part"><a href="#Day-14-Day-X-Team-Project-First-Part" class="headerlink" title="Day 14 - Day X: Team Project (First Part)"></a>Day 14 - Day X: Team Project (First Part)</h1><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g3cckd0xxhj30i7050gm1.jpg" width="400px" />

<p><em>项目代码将在答辩结束后全部开源</em></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>Java</tag>
        <tag>东软睿道</tag>
        <tag>互联网架构</tag>
        <tag>MyBatis</tag>
        <tag>Spring IoC</tag>
        <tag>Spring AOP</tag>
      </tags>
  </entry>
</search>
